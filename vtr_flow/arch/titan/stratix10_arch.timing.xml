<architecture>
  <models>

    <!-- LAB Primitives -->
    <model name="fourteennm_lcell_comb">
      <input_ports>
        <port name="dataa" combinational_sink_ports="combout sumout cout"/>
        <port name="datab" combinational_sink_ports="combout sumout cout"/>
        <port name="datac" combinational_sink_ports="combout sumout cout"/>
        <port name="datad" combinational_sink_ports="combout sumout cout"/>
        <port name="datae" combinational_sink_ports="combout"/>
        <port name="dataf" combinational_sink_ports="combout"/>
        <port name="datag" combinational_sink_ports="combout"/>
        <port name="datah" combinational_sink_ports="combout"/>
        <port name="cin" combinational_sink_ports="sumout cout"/>
      </input_ports>
      <output_ports>
        <port name="combout"/>
        <port name="sumout"/>
        <port name="cout"/>
      </output_ports>
    </model>

    <model name="fourteennm_ff">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="ena" clock="clk"/>
        <port name="clrn" clock="clk"/>
        <port name="sclr" clock="clk"/>
        <port name="d" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="q" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mlab_cell">
      <input_ports>
        <port name="clk0" is_clock="1"/>
        <port name="ena0" clock="clk0"/>
        <port name="clr" clock="clk0"/>
        <port name="portaaddr" clock="clk0"/>
        <port name="portabyteenamasks" clock="clk0"/>
        <port name="portadatain" clock="clk0"/>
        <port name="portbaddr" clock="clk0"/>
      </input_ports>
      <output_ports>
        <port name="portbdataout" clock="clk0"/>
      </output_ports>
    </model>

    <!-- OCT Primitives -->
    <model name="fourteennm_termination">
      <input_ports>
        <port name="rzqin" clock="clkusr"/> 
        <port name="enserusr" clock="clkusr"/> 
        <port name="nclrusr" clock="clkusr"/>
        <port name="clkenusr" clock="clkusr"/>
        <port name="clkusr" is_clock="1"/>
        <port name="ser_data_dq_from_core" clock="clkusr"/>
        <port name="ser_data_ca_from_core" clock="clkusr"/>
        <port name="test_clkusr_en_n" clock="clkusr"/>
        <port name="oct_scanin" clock="clkusr"/>
      </input_ports>
      <output_ports>
        <port name="clkusr_dft_out" clock="clkusr"/>
        <port name="oct_scanout" clock="clkusr"/>
        <port name="compout_rdn" clock="clkusr"/>
        <port name="compout_rup" clock="clkusr"/>
        <port name="serdataout" clock="clkusr"/>
        <port name="ser_data_dq_to_core" clock="clkusr"/>
        <port name="ser_data_ca_to_core" clock="clkusr"/>
      </output_ports>
    </model>

    <model name="fourteennm_termination_logic">
      <input_ports>
        <port name="s2pload" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="serdata" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_shift_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
      </input_ports>
      <output_ports>
        <port name="scan_out" />
        <port name="seriesterminationcontrol" />
        <port name="parallelterminationcontrol" />
      </output_ports>
    </model>

    <!-- PLL Primitive -->
    <model name="fourteennm_iopll">
      <input_ports>
        <port name="clken" clock="core_refclk"/>
        <port name="cnt_sel" clock="core_refclk"/> 
        <port name="core_refclk" is_clock="1"/> 
        <port name="dps_rst_n" clock="core_refclk"/> 
        <port name="extswitch" clock="core_refclk"/> 
        <port name="fbclk_in" clock="core_refclk"/> 
        <port name="fblvds_in" clock="core_refclk"/> 
        <port name="refclk" clock="core_refclk"/> 
        <port name="mdio_dis" clock="core_refclk"/>
        <port name="rst_n" clock="core_refclk"/>
        <port name="num_phase_shifts" clock="core_refclk"/> 
        <port name="pfden" clock="core_refclk"/> 
        <port name="pll_cascade_in" clock="core_refclk"/> 
        <port name="scan_mode_n" clock="core_refclk"/> 
        <port name="scan_shift_n" clock="core_refclk"/>
        <port name="csr_clk" clock="core_refclk"/>
        <port name="csr_en" clock="core_refclk"/>
        <port name="phase_en" clock="core_refclk"/>
        <port name="csr_in" clock="core_refclk"/>
        <port name="uc_cal_addr" clock="core_refclk"/>
        <port name="uc_cal_clk" clock="core_refclk"/>
        <port name="uc_cal_read" clock="core_refclk"/>
        <port name="uc_cal_write" clock="core_refclk"/>
        <port name="uc_cal_writedata" clock="core_refclk"/>  
        <port name="up_dn" clock="core_refclk"/> 
        <port name="user_mode" clock="core_refclk"/> 
        <port name="zdb_in" clock="core_refclk"/> 
        <port name="dprio_address" clock="core_refclk"/>                                 
        <port name="dprio_clk" clock="core_refclk"/>                                 
        <port name="read" clock="core_refclk"/>   
        <port name="write" clock="core_refclk"/> 
        <port name="writedata" clock="core_refclk"/> 
        <port name="dprio_rst_n" clock="core_refclk"/>                                 
        <port name="pipeline_global_en_n" clock="core_refclk"/>
        <port name="pma_csr_test_dis" clock="core_refclk"/>
      </input_ports>
      <output_ports>
        <port name="block_select" clock="core_refclk"/>
        <port name="clk0_bad" clock="core_refclk"/> 
        <port name="clk1_bad" clock="core_refclk"/> 
        <port name="clksel" clock="core_refclk"/>
        <port name="cal_ok" clock="core_refclk"/> 
        <port name="core_avl_busy" clock="core_refclk"/>
        <port name="core_cal_done" clock="core_refclk"/>
        <port name="extclk_output" clock="core_refclk"/> 
        <port name="extclk_dft" clock="core_refclk"/>
        <port name="fblvds_out" clock="core_refclk"/>
        <port name="lf_reset" clock="core_refclk"/> 
        <port name="loaden" clock="core_refclk"/> 
        <port name="lock" clock="core_refclk"/> 
        <port name="lock2io12lane0" clock="core_refclk"/> 
        <port name="lock2io12lane1" clock="core_refclk"/> 
        <port name="lock2io12lane2" clock="core_refclk"/> 
        <port name="lock2io12lane3" clock="core_refclk"/> 
        <port name="lock2iohmc" clock="core_refclk"/> 
        <port name="phase_done" clock="core_refclk"/> 
        <port name="pll_cascade_out" clock="core_refclk"/> 
        <port name="pll_pd" clock="core_refclk"/> 
        <port name="outclk" clock="core_refclk"/> 
        <port name="dll_output" clock="core_refclk"/> 
        <port name="fbclk_out" clock="core_refclk"/> 
        <port name="uc_cal_readdata" clock="core_refclk"/>
        <port name="vcop_en" clock="core_refclk"/>
        <port name="vcoph" clock="core_refclk"/> 
        <port name="iopll_out_sig1" clock="core_refclk"/>
        <port name="iopll_out_sig2" clock="core_refclk"/>
        <port name="readdata" clock="core_refclk"/>
        <port name="lvds_clk" clock="core_refclk"/>
        <port name="csr_out" clock="core_refclk"/>
      </output_ports>
    </model>

    <!-- Clock divider Primitive -->
    <model name="fourteennm_clk_divider">
      <input_ports>
        <port name="inclk" is_clock="1"/> 
      </input_ports>
      <output_ports>
        <port name="clock_div1" clock="inclk"/>
        <port name="clock_div2" clock="inclk"/> 
        <port name="clock_div4" clock="inclk"/> 
      </output_ports>
    </model>

    <!-- Clock gate Primitive -->
    <model name="fourteennm_clk_gate">
      <input_ports>
        <port name="inclk" is_clock="1"/> 
        <port name="enable" clock="inclk"/> 
      </input_ports>
      <output_ports>
        <port name="outclk" clock="inclk"/>
      </output_ports>
    </model>
    <!-- IO Primitives -->
    <model name="fourteennm_io_obuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar"/> 
        <port name="oe" combinational_sink_ports="o obar"/> 
        <port name="dynamicterminationcontrol" combinational_sink_ports="o obar"/> 
        <port name="seriesterminationcontrol" combinational_sink_ports="o obar"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o obar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
      </output_ports>
    </model>

    <model name="fourteennm_io_ibuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o"/>
        <port name="ibar" combinational_sink_ports="o"/>
        <port name="dynamicterminationcontrol" combinational_sink_ports="o"/>
        <port name="seriesterminationcontrol" combinational_sink_ports="o"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o"/>
      </input_ports>
      <output_ports>
        <port name="o" />
      </output_ports>
    </model>

    <model name="fourteennm_pseudo_diff_out">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="ibar" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oein" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oebin"  combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcbarin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
        <port name="oeout" />
        <port name="oebout" />
        <port name="dtc" />
        <port name="dtcbar" />
      </output_ports>
    </model>

    <model name="fourteennm_ddio_out">
      <input_ports>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <port name="clk" is_clock="1"/>
        <port name="clkhi" clock="clk"/>
        <port name="clklo" clock="clk"/>
        <port name="muxsel" clock="clk"/>
        <port name="datainlo" clock="clk"/>
        <port name="datainhi" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="dataout" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_ddio_in">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="clkn" clock="clk"/>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <port name="datain" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="regoutlo" clock="clk"/>
        <port name="regouthi" clock="clk"/>
      </output_ports>
    </model>

    <!-- DSP Primitives -->

    <!-- independent multiplier mode -->
    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resultb"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resultb scanout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resultb"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resultb"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta resultb scanout"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" />
        <port name="resultb" />
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta scanout"/>
        <port name="az" combinational_sink_ports="resulta"/>
        <port name="coefsela" combinational_sink_ports="resulta"/>
        <port name="bx" combinational_sink_ports="resultb"/>
        <port name="by" combinational_sink_ports="resultb scanout"/>
        <port name="bz" combinational_sink_ports="resultb"/>
        <port name="coefselb" combinational_sink_ports="resultb"/>
        <port name="scanin" combinational_sink_ports="resulta resultb scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" clock="output_clk"/>
        <port name="resultb" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="clr" combinational_sink_ports="resulta resultb"/>
        <port name="ax" combinational_sink_ports="resulta dftout"/>
        <port name="ay" combinational_sink_ports="resulta scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta dftout"/>
        <port name="bx" combinational_sink_ports="resultb dftout"/>
        <port name="by" combinational_sink_ports="resultb scanout dftout"/>
        <port name="bz" combinational_sink_ports="resultb dftout"/>
        <port name="coefselb" combinational_sink_ports="resultb dftout"/>
        <port name="scanin" combinational_sink_ports="resulta resultb scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta resultb dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta resultb dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta resultb dftout"/>
      </input_ports>
      <output_ports>
        <port name="resulta"/>
        <port name="resultb"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resultb"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resultb"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resultb"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resultb"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta resultb"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" clock="output_clk"/>
        <port name="resultb" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>    
    </model>

    <!-- multiplier adder sum mode -->
    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="by_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout dftout"/>
        <port name="clr" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ax" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout dftout"/>
        <port name="bx" combinational_sink_ports="resulta chainout dftout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="bz" combinational_sink_ports="resulta chainout dftout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="sub" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout dftout"/>
      </input_ports>
      <output_ports>
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!--  18x19 multiplication summed with 36-bit input -->

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{comb}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{comb}">
      <input_ports> 
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout dftout"/>
        <port name="bx" combinational_sink_ports="resulta chainout dftout"/>
        <port name="by" combinational_sink_ports="resulta chainout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="sub" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- systolic fir mode -->  
    <model name="fourteennm_mac.opmode{m18x18_systolic}.input_type{comb}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_systolic}.input_type{reg}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- 27x27 independent multiplier -->
    <model name="fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{comb}">
      <input_ports>       
        <port name="accumulate" clock="accumulate_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk" combinational_sink_ports="resulta chainout"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>     
    <model name="fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{reg}">
      <input_ports>       
        <port name="accumulate" clock="output_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout"/>
        <port name="negate" clock="output_clk"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>
    <model name="fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{comb}">
      <input_ports>       
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="clr" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ax" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout scanout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports> 
    </model>
    <model name="fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{reg}">
      <input_ports>       
        <port name="accumulate" clock="accumulate_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk" combinational_sink_ports="resulta chainout"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- single 18x18 multiplier mode -->
    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{comb}">
      <input_ports>       
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{reg}">
      <input_ports>       
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta scanout"/>
        <port name="az" combinational_sink_ports="resulta"/>
        <port name="coefsela" combinational_sink_ports="resulta"/>
        <port name="scanin" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="sub" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta" clock="output_clk"/>
        <port name="scanout"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{comb}">
      <input_ports>       
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta scanout dftout"/>
        <port name="ay" combinational_sink_ports="resulta scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta scanout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta scanout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta scanout dftout"/>
        <port name="sub" combinational_sink_ports="resulta scanout dftout"/>
        <port name="negate" combinational_sink_ports="resulta scanout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta scanout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta scanout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{reg}">
      <input_ports>       
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- fp multiplication mode -->
    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{comb}">
      <input_ports>  
        <port name="chainin"  combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ay_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{reg}">
      <input_ports>  
        <port name="chainin" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{comb}">
      <input_ports>  
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{reg}">
      <input_ports>  
        <port name="chainin"  combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- fp multiply accumulate mode -->


    <model name="fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin" clock="accumulate_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="accumulate"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp multiply add mode-->
    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp adder or subtract mode -->
    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" />
        <port name="resulta" />
        <port name="adder_inexact" />
        <port name="adder_invalid" />
        <port name="adder_overflow" />
        <port name="adder_underflow" />
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- vector one mode -->

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{comb}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{reg}">
      <input_ports>        
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{comb}">
      <input_ports>  
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>      
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta chainout"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{reg}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp vector two mode -->

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{comb}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{reg}">
      <input_ports>        
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{comb}">
      <input_ports>        
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{reg}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

  </models>
  <tiles>

    <tile name="iolane">
      <sub_tile name="iolane" >
        <equivalent_sites>
          <site pb_type="iolane" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="55" equivalent="none"/>
        <output name="core_out" num_pins="24" equivalent="none"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375"/>
        <pinlocations pattern="custom">
          
          <loc side="left">  iolane.core_in[0:26]  iolane.core_out[0:11]  iolane.clk</loc>
          <loc side="right"> iolane.core_in[27:54] iolane.core_out[12:23] iolane.clk</loc>
          <loc side="top">   iolane.core_in[0:26]  iolane.core_out[0:11]  iolane.clk</loc>
          <loc side="bottom">iolane.core_in[27:54] iolane.core_out[12:23] iolane.clk</loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile name="LAB">
      <sub_tile name="LAB">
        <equivalent_sites>
          <site pb_type="LAB" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="data_in" num_pins="60" equivalent="full"/>
        <input name="control_in" num_pins="5" equivalent="full"/>
        <input name="cin" num_pins="1" equivalent="none"/>
        <!-- Stratix 10 does have instance equivalence only for the data_out port
             where ALM outputs can be swapped to reach the most suitable pin location
             for routers. However, it may require significant changes to packing results
             which is not supported yet.
             Therefore, we assume full equivalence here, so that ALM outputs can be swapped
             through a local routing architecture without changing packing results.
             Please note that this may cause optimistic routing results, being
             better in routability than what actual hardware can support
          -->
        <output name="data_out" num_pins="40" equivalent="full"/>
        <output name="cout" num_pins="1" equivalent="none"/>
        <clock name="clk" num_pins="2"/>
        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375">
          <!-- Based on mux size info Startix 10 has approximately the following effective Fc values:
                   Fc_in: 0.055
                   Fc_out: 0.075

               However, we allow half the pins to connect to the left side, the other half to the right side
               and all pins to connect to the top side of the LAB (3-sided architecture).

               As a result we divide the effective Fc values by 2 (since each pin can connect to two sides)
               to keep roughly the same number of switches, yielding:

                    Fc_in: 0.0275
                    Fc_out: 0.0375
               -->
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
          <!-- Stratix 10 is a 3 sided architecture, the LABs can connect to routing on their
               left, top, and right.  To model this we spread the various ports around the three sides.

               The exceptions to the above are the LAB chain ports, which propogate downward between blocks.

               We model that half the pins can connect to each vertical channel (left/right),
               and all can connect to the horizontal channel (top). This models the fact that
               each block pin can connect to some Vertical and some Horizontal wires in Stratix IV.
               Note that Fc_in/Fc_out have been scaled to account for this.
             -->
          <loc side="left">  LAB.data_in[0:39]  LAB.control_in[0:3] LAB.data_out[0:19]  LAB.clk</loc>
          <loc side="right"> LAB.data_in[40:79] LAB.control_in[4:6] LAB.data_out[20:39]</loc>
          <loc side="top">   LAB.data_in        LAB.control_in      LAB.data_out        LAB.clk LAB.cin</loc>
          <loc side="bottom">LAB.cout</loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile height="1" name="PLL">
      <sub_tile name="PLL">
        <equivalent_sites>
          <site pb_type="PLL" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="10"/>
        <output name="core_out" num_pins="36"/>
        <clock name="clk" num_pins="2"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="right">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="top">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="bottom">PLL.core_in PLL.core_out PLL.clk </loc>
        </pinlocations>
      </sub_tile>
      <sub_tile name="clock_div">
        <equivalent_sites>
          <site pb_type="clock_div" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="inclk" num_pins="1"/>
        <output name="clock_div_out" num_pins="3"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="right">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="top">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="bottom">clock_div.inclk clock_div.clock_div_out </loc>
        </pinlocations>
      </sub_tile>
      <sub_tile name="clock_gate">
        <equivalent_sites>
          <site pb_type="clock_gate" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="inclk" num_pins="1"/>
        <input name="enable" num_pins="1"/>
        <output name="outclk" num_pins="1"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">clock_gate.inclk clock_gate.enable clock_gate.outclk</loc>
          <loc side="right">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
          <loc side="top">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
          <loc side="bottom">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile height="1" name="OCT">
      <sub_tile name="OCT">
        <equivalent_sites>
          <site pb_type="OCT" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="10"/>
        <output name="core_out" num_pins="36"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">OCT.core_in OCT.core_out OCT.clk </loc>
          <loc side="right">OCT.core_in OCT.core_out OCT.clk </loc>
          <loc side="top">OCT.core_in OCT.core_out OCT.clk </loc>
          <loc side="bottom">OCT.core_in OCT.core_out OCT.clk </loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile height="4" name="DSP">
      <sub_tile name="DSP">
        <equivalent_sites>
          <site pb_type="DSP" pin_mapping="direct" />
        </equivalent_sites>
      <input name="datain" num_pins="110" />
      <input name="chainin" num_pins="64" />
      <input name="controlin" num_pins="17" />
      <input name="scanin" num_pins="27" />
      <clock name="clk" num_pins="3" />
      <output name="result" num_pins="74" />
      <output name="chainout" num_pins="64" />
      <output name="scanout" num_pins="27" />
      <output name="dftout" num_pins="1" />
        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375">
          
        </fc>
        <pinlocations pattern="custom">
          
          
          
          
          <loc side="left" yoffset="3">DSP.datain[8:0]    DSP.chainin[4:0] DSP.chainout[4:0] DSP.controlin[0] DSP.scanin[1:0] DSP.clk[0] DSP.result[17:0]  DSP.scanout[1:0]   DSP.dftout                  </loc>
          <loc side="left" yoffset="2">DSP.datain[17:9]   DSP.chainin[9:5] DSP.chainout[9:5] DSP.controlin[2:1] DSP.scanin[4:2]            DSP.result[35:18] DSP.scanout[4:2]  </loc>
          <loc side="right" yoffset="3">DSP.datain[26:18]  DSP.chainin[14:10] DSP.chainout[14:10] DSP.controlin[3] DSP.scanin[6:5] DSP.clk[1] DSP.result[53:36] DSP.scanout[6:5]  </loc>
          <loc side="right" yoffset="2">DSP.datain[35:27] DSP.chainin[19:15] DSP.chainout[19:15] DSP.controlin[5:4] DSP.scanin[8:7]            DSP.result[71:54] DSP.scanout[8:7]  </loc>
          <loc side="top" yoffset="3">DSP.datain[44:36]  DSP.chainin[24:20] DSP.chainout[24:20] DSP.controlin[6] DSP.scanin[10:9]    DSP.clk[2] DSP.result[35:0]  DSP.scanout[10:9]  </loc>
          <loc side="top" yoffset="2">DSP.datain[53:45]    DSP.chainin[29:25] DSP.chainout[29:25] DSP.controlin[8:7] DSP.scanin[12:11]    DSP.clk[1] DSP.result[73:36] DSP.scanout[12:11]  </loc>
          <loc side="bottom" yoffset="3" />
          <loc side="bottom" yoffset="2" />
          
          <loc side="left" yoffset="1">DSP.datain[61:54] DSP.chainin[34:30] DSP.chainout[34:30] DSP.controlin[9]  DSP.scanin[14:13]     DSP.clk[2] DSP.result[17:0]  DSP.scanout[14:13]                      </loc>
          <loc side="left" yoffset="0">DSP.datain[70:62] DSP.chainin[39:35] DSP.chainout[39:35] DSP.controlin[11:10] DSP.scanin[16:15]               DSP.result[35:18] DSP.scanout[16:15] </loc>
          <loc side="right" yoffset="1">DSP.datain[79:71] DSP.chainin[44:40] DSP.chainout[44:40] DSP.controlin[12] DSP.scanin[18:17]               DSP.result[53:36] DSP.scanout[18:17] </loc>
          <loc side="right" yoffset="0">DSP.datain[88:80] DSP.chainin[49:45] DSP.chainout[49:45] DSP.controlin[14:13] DSP.scanin[20:19]    DSP.clk[0] DSP.result[71:54] DSP.scanout[20:19] </loc>
          <loc side="top" yoffset="1">DSP.datain[97:89] DSP.chainin[54:50] DSP.chainout[54:50] DSP.controlin[15]  DSP.scanin[22:21]     DSP.clk[2] DSP.result[35:0]  DSP.scanout[22:21] </loc>
          <loc side="top" yoffset="0">DSP.datain[109:98] DSP.chainin[63:55] DSP.chainout[63:55] DSP.controlin[16] DSP.scanin[26:23]    DSP.clk[0] DSP.result[73:36] DSP.scanout[26:23] </loc>
          <loc side="bottom" yoffset="1" />
          <loc side="bottom" yoffset="0">DSP.chainout</loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile name="M20K">
      <sub_tile name="M20K">
        <equivalent_sites>
          <site pb_type="M20K" pin_mapping="direct" />
        </equivalent_sites>
        <input name="data_addr_control_in" num_pins="104" />
        <output name="data_out" num_pins="40" />
        <output name="control_out" num_pins="2" />
        <clock name="clk_in" num_pins="2" />

        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375">
          
          
          
        </fc>
        <pinlocations pattern="custom">
          
          <loc side="left">  M20K.data_addr_control_in[0:51]  M20K.control_out[0] M20K.data_out[0:19]  M20K.clk_in </loc>
          <loc side="right"> M20K.data_addr_control_in[52:103] M20K.control_out[1] M20K.data_out[20:39] </loc>
          <loc side="top">   M20K.data_addr_control_in        M20K.control_out      M20K.data_out        M20K.clk_in </loc>
        </pinlocations>
      </sub_tile>
    </tile>
  </tiles>
  <layout>
    <auto_layout aspect_ratio="1.35">
      <!-- Stratix IV IO blocks connect to both horizontal and vertical
             routing channels. We approximate this by placing them one unit
             'in' from the true perimeter (which is left empty). This means
             that they are fully surrounded by routing channels, allowing them
             to connect to both horizontal and vertical channels. This is a
             minor approximation since on real Stratix IV devices there is no 
             perimeter-side vertical routing channel -->
      <perimeter type="EMPTY" priority="5000"/>

      <!-- In Stratix 10 devices, IO pins are located in two columns each with a 20% margin from the side borders -->

      <!--Column of 'IO' declared with 'EMPTY' blocks of length 1 wherever an IO block of length 4 does not fit. Vertical offset by 1 for perimeter.-->
      <col type="EMPTY" startx="W/5" priority="1000"/>
      <col type="iolane" startx="W/5" priority="1001"/>
      <!-- Left column -->
      <col type="EMPTY" startx="4*W/5" priority="1000"/>
      <col type="iolane" startx="4*W/5" priority="1001"/>
      <!-- Right column -->



      <!-- Stratix 10 devices support up to 24 PLLs and OCTs located 
            in the same columns as IOs occuring after every 6 consecutive IO blocks-->
      <!-- It's been assumed that PLL and OCT each take half their actual length. A more accurate alternative that can be implemented in the future is to define them as subtime belonging to the same tile -->
      <row type="PLL" startx="W/5" starty="1" repeaty="36" priority="1997"/>
      <row type="PLL" startx="4*W/5" starty="1" repeaty="36" priority="1997"/>

      <row type="OCT" startx="W/5" starty="13" repeaty="36" priority="1996"/>
      <row type="OCT" startx="4*W/5" starty="13" repeaty="36" priority="1996"/> 

      <!--Fill with 'LAB'-->
      <fill type="LAB" priority="10"/>
      <!--Column of 'DSP' with 'EMPTY' blocks wherever a 'DSP' does not fit. Vertical offset by 1 for perimeter.-->
      <col type="DSP" startx="20" starty="2" repeatx="20" priority="150"/>
      <col type="EMPTY" startx="20" repeatx="20" starty="1" priority="149"/>
      <!--Column of 'M20K' with 'EMPTY' blocks wherever a 'M20K' does not fit. Vertical offset by 1 for perimeter.-->
      <col type="M20K" startx="5" starty="2" repeatx="10" priority="50"/>
      <col type="EMPTY" startx="5" repeatx="10" starty="1" priority="49"/>

    </auto_layout>

  </layout>
  <switchlist>
    <!-- AA: July 19, 2020
         We define three types of drivers, one for each of the segment types (see comment in <segmentlist> section)
         In the model for Stratix 10 we put all the delay on switch and connection blocks in the form of Tdel; Meaning that we assume the resistance and capticance of the switches are set to 0. 
         Stratix 10 is modelled here to have 3 different segment wire types per horizational/vertical channel.           
       -->

    <!-- AA: The mux_tran_size and buf_size parameters for switches are kept the same as ones in Startix IV since modelling area in Stratix 10 is of little intrest and difficult.-->
    <switch type="mux" name="seg_h2_driver" R="0" Cin="0" Cout="0" Tdel="89e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h4_driver" R="0" Cin="0" Cout="0" Tdel="133e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h10_driver" R="0" Cin="0" Cout="0" Tdel="203e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h24_driver" R="0" Cin="0" Cout="0" Tdel="188e-12" mux_trans_size="2.630740" buf_size="27.647901"/>

    <switch type="mux" name="seg_v2_driver" R="0" Cin="0" Cout="0" Tdel="95e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v3_driver" R="0" Cin="0" Cout="0" Tdel="194e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v4_driver" R="0" Cin="0" Cout="0" Tdel="146e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v16_driver" R="0" Cin="0" Cout="0" Tdel="213e-12" mux_trans_size="2.630740" buf_size="27.647901"/>

  </switchlist>
  <segmentlist>
    <!-- AA: July 19, 2021

           Wire distribution:
             In stratix 10 there are eight types of wires: R2,R4,R10,R20,C2,C3,C4,C12
             R wires are row wires running horizontally accross the chip
             C wires are column wires running vertically accross the chip

             The wire counts for Stratix IV channels are:
                R2 : 152
                C2 : 160
                R4 : 152
                C3 : 160
                R10: 210
                C4 : 160
                R24:  48
                C16:  32
                Total horizontal tracks: 562
                Total vertical tracks: 512

                6.5% of vertical & 8.5% of horizontal wires are long. (7.5% in average)

                92.5% of horizontal wires &  93.5% of veritcal wires are intermediate wires. 

                We will divide the wires into L2, L4, and L20 wires keeping in mind that VPR doesn't support non-uniform horizontal and vertical channels: 

                 The combination of R2,C2, and C3 wires gives the channel width for L2 wires:
                 
                 (152+160+160)/2=236 

                 The combination of R4,C4,and R10 wires gives the channel width for L4:

                 (210+152+152)/3=257
                
                 The average of C16 and R24 wires gives the channel width for L20 wires: 

                 (32+48)/2=40

                 The average channel width for the horizontal and vertical channels is: (562+512)/2=537 ~540 

                 The difference between the target channel width and total of wires thus far will be added to L4 wires since the total of R4,C4, and R10 
                 wires is larger than R2,C2, and C3 wires:  

                 540-257-236-40=6 -> 6 additional L4 wires 

                 Finally we have: 
                
                 L2:236
                 L4:264
                 L20:40

                 We get the following ratios with this distribution: 
                
                 7.4% are long wires.  
                 92.6% are short wires. 

                 which is reasonable.

              Thus to model the routing we have the following: 
                - A channel width of 540 wires (provided on the command line)
                - 7.4% of wires are L20 wires
                - 42.4% of wires are L4 wires
                - 50.2% of wires are L2 wires

           NOTE: In Startix10 we do not model metal data since all the delay is put on the driving muxes. 
        
           Wire delays:

             The average delays of the actual wires using Quartus PrimePro came to be the following: 

              C2: 95 ps     R2: 89  ps
              C3: 194 ps    R4: 133 ps
              C4: 146 ps    R10: 203  ps
              C16: 213 ps   R24: 188  ps


             Averaging accross wires of the same type we attempt to make the wires total delays correlate to the following values:
              L2: 92 ps
              L4: 140 ps
              L20: 201 ps  

          NOTE: We don't model minimum capacitances for Stratix10. 
    -->
    <segment name="H2" axis="x" freq="40" length="2" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h2_driver"/>
      <sb type="pattern">1 1 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment name="H4" axis="x" freq="112" length="4" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h4_driver"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>

    <segment name="H10" axis="x" freq="200" length="10" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h10_driver"/>
      <sb type="pattern">1 0 1 0 1 0 1 0 1 0 1</sb>
      <cb type="pattern">1 1 1 1 1 1 1 1 1 1</cb>
    </segment>

    <segment name="H24" axis="x" freq="48" length="24" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h24_driver"/>
      <sb type="pattern">1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1</sb>
      <cb type="pattern">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</cb>
    </segment>
    
    <segment name="V2" axis="y" freq="24" length="2" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v2_driver"/>
      <sb type="pattern">1 1 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment name="V3" axis="y" freq="72" length="3" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v3_driver"/>
      <sb type="pattern">1 1 1 1</sb>
      <cb type="pattern">1 1 1</cb>
    </segment>

    <segment name="V4" axis="y" freq="64" length="4" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v4_driver"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>

    <segment name="V16" axis="y" freq="32" length="16" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v16_driver"/>
      <sb type="pattern">1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</sb>
      <cb type="pattern">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</cb>
    </segment>
  </segmentlist>
  <directlist>
    <!--Carry chain propogates downward between LAB blocks-->
    <direct name="LAB_carry_chain" from_pin="LAB.cout" to_pin="LAB.cin" x_offset="0" y_offset="-1" z_offset="0"/>
  </directlist>
  <complexblocklist>

    <pb_type name="PLL">
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="2"/>

      <pb_type blif_model=".subckt fourteennm_iopll" name="iopll" num_pb="1">
        <input name="clken" num_pins="2"/>
        <input name="cnt_sel" num_pins="4"/> <!-- counter selector for dynamic phase shift -->
        <input name="dprio_address" num_pins="9"/>  <!--  Avalon-MM Interface - address of the databus for dynamic partial reconfiguration -->
        <input name="dprio_clk" num_pins="1"/>  <!--  Avalon-MM Interface - clock port for dynamic partial reconfiguration -->
        <input name="read" num_pins="1"/>  <!--  Avalon-MM Interface - indicate a read operation during dynamic partial reconfiguration -->
        <input name="write" num_pins="1"/>  <!--  Avalon-MM Interface - indicate a write operation during dynamic partial reconfiguration -->
        <input name="writedata" num_pins="8"/>  <!--  Avalon-MM Interface - data to be written to the given address during dynamic partial reconfiguration -->
        <clock name="core_refclk" num_pins="1"/> <!-- use core clock as an input reference clock -->
        <input name="csr_clk" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface - clock signal-->
        <input name="csr_en" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface - enable signal-->
        <input name="phase_en" num_pins="1"/> 
        <input name="csr_in" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface -->
        <input name="dprio_rst_n" num_pins="1"/> <!--  Avalon-MM Interface - reset port for dynamic partial reconfiguration -->
        <input name="dps_rst_n" num_pins="1"/> <!--  dynamic phase shift reset -->
        <input name="extswitch" num_pins="1"/> <!--  controlling clock switchover -->
        <input name="fbclk_in" num_pins="1"/> <!--  feedback clock used for external feedback compensation -->
        <input name="fblvds_in" num_pins="1"/> <!--  feedback clock used for LVDS compensation -->
        <input name="refclk" num_pins="4"/> <!--  reference clock source driving the IO PLL -->
        <input name="mdio_dis" num_pins="1"/>
        <input name="rst_n" num_pins="1"/>
        <input name="num_phase_shifts" num_pins="3"/> <!--  number of phase shifts per dynamic phase shift operation -->
        <input name="pfden" num_pins="1"/> <!--  enabling dynamic phase shift operation -->
        <input name="pipeline_global_en_n" num_pins="1"/>
        <input name="pma_csr_test_dis" num_pins="1"/>  <!-- disable PMA CSR test  -->
        <input name="pll_cascade_in" num_pins="1"/> <!-- cascade input from IO PLL in the same IO column  -->
        <input name="scan_mode_n" num_pins="1"/> <!-- dynamic phase shift clock -->
        <input name="scan_shift_n" num_pins="1"/>
        <input name="uc_cal_addr" num_pins="20"/>
        <input name="uc_cal_clk" num_pins="1"/>
        <input name="uc_cal_read" num_pins="1"/>
        <input name="uc_cal_write" num_pins="1"/>
        <input name="uc_cal_writedata" num_pins="8"/>  
        <input name="up_dn" num_pins="1"/> <!-- direction of phase shift -->
        <input name="user_mode" num_pins="1"/> <!-- enable user mode  -->
        <input name="zdb_in" num_pins="1"/> <!-- zero delay buffer compensation feedback -->

        <output name="block_select" num_pins="1"/>
        <output name="clk0_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clk1_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clksel" num_pins="1"/>
        <output name="cal_ok" num_pins="1"/> <!-- indicates the calibration status -->
        <output name="core_avl_busy" num_pins="1"/>
        <output name="core_cal_done" num_pins="1"/>
        <output name="readdata" num_pins="8"/> <!-- Avalon-MM Interface - data read from the given address during dynamic partial reconfiguration -->
        <output name="csr_out" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface !-->
        <output name="extclk_output" num_pins="2"/> <!-- external clock output port -->
        <output name="extclk_dft" num_pins="2"/>
        <output name="fblvds_out" num_pins="1"/>
        <output name="lf_reset" num_pins="1"/> <!-- loop filter reset -->
        <output name="loaden" num_pins="2"/> <!-- signal to the LVDS receiver -->
        <output name="lock" num_pins="1"/> <!-- indicate wether the PLL is locked - signal to the core logic -->
        <output name="lock2io12lane0" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 0 -->
        <output name="lock2io12lane1" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 1 -->
        <output name="lock2io12lane2" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 2 -->
        <output name="lock2io12lane3" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 3 -->
        <output name="lock2iohmc" num_pins="1"/> <!-- indicate wether the PLL is locked - going to Hybrid Memory Cube (HMC)-->
        <output name="lvds_clk" num_pins="2"/> <!-- the output clk feeding the LVDS SERDES block -->
        <output name="phase_done" num_pins="1"/> <!-- indicates completion of dynamic phase shift operation -->
        <output name="pll_cascade_out" num_pins="1"/> <!-- the output from the source PLL feeding the downstream PLL in cascade mode -->
        <output name="pll_pd" num_pins="1"/> <!-- indicating power down - going to the exteral PLLs  -->
        <output name="outclk" num_pins="9"/> <!-- PLL output clocks -->
        <output name="dll_output" num_pins="1"/> <!-- going to the External Memory Interface DLL -->
        <output name="fbclk_out" num_pins="1"/> <!-- output of the M counter -->
        <output name="uc_cal_readdata" num_pins="8"/>
        <output name="vcop_en" num_pins="1"/>
        <output name="vcoph" num_pins="8"/> <!-- VCO output clocks -->
        <output name="iopll_out_sig1" num_pins="1"/>
        <output name="iopll_out_sig2" num_pins="1"/>
      </pb_type>
       <interconnect>
       
        <complete input="PLL.core_in" name="core_to_pll" output="iopll.refclk iopll.clken iopll.cnt_sel iopll.dprio_address iopll.dprio_clk iopll.read iopll.write iopll.writedata iopll.csr_clk iopll.csr_en iopll.csr_in iopll.dprio_rst_n iopll.dps_rst_n iopll.extswitch iopll.fbclk_in iopll.fblvds_in iopll.mdio_dis iopll.rst_n  iopll.phase_en iopll.num_phase_shifts iopll.pfden iopll.pipeline_global_en_n iopll.pma_csr_test_dis iopll.pll_cascade_in iopll.scan_mode_n iopll.scan_shift_n iopll.uc_cal_addr iopll.uc_cal_clk iopll.uc_cal_read  iopll.uc_cal_write iopll.uc_cal_writedata iopll.up_dn iopll.user_mode iopll.zdb_in"/>

        <complete input="PLL.clk" name="pll_clock" output="iopll.core_refclk"/>

        <complete input="iopll.readdata iopll.lvds_clk iopll.csr_out iopll.block_select iopll.clk0_bad iopll.clk1_bad iopll.clksel iopll.cal_ok iopll.core_avl_busy iopll.core_cal_done iopll.extclk_output iopll.extclk_dft iopll.fblvds_out iopll.lf_reset iopll.loaden iopll.lock iopll.lock2io12lane0 iopll.lock2io12lane1 iopll.lock2io12lane2 iopll.lock2io12lane3 iopll.lock2iohmc iopll.phase_done iopll.pll_cascade_out iopll.pll_pd iopll.outclk iopll.dll_output iopll.fbclk_out iopll.uc_cal_readdata iopll.vcop_en iopll.vcoph iopll.iopll_out_sig1 iopll.iopll_out_sig2" name="pll_to_core" output="PLL.core_out"/>
      </interconnect>
    </pb_type>

    <pb_type name="clock_gate">
      <input name="inclk" num_pins="1"/>
      <input name="enable" num_pins="1"/>
      <output name="outclk" num_pins="1"/>

      <pb_type blif_model=".subckt fourteennm_clk_gate" name="clk_gate" num_pb="1">
        <clock name="inclk" num_pins="1"/>
        <input name="enable" num_pins="1"/>
        <output name="outclk" num_pins="1"/> 
      </pb_type>
       <interconnect>    
        <direct input="clock_gate.inclk" name="core_to_clk_gate" output="clk_gate.inclk"/>
        <direct input="clock_gate.enable" name="core_to_clk_gate2" output="clk_gate.enable"/>
        <direct input="clk_gate.outclk" name="clk_gate_to_core" output="clock_gate.outclk"/>
      </interconnect>
    </pb_type>

    <pb_type name="clock_div">
      <input name="inclk" num_pins="1"/>
      <output name="clock_div_out" num_pins="3"/>

      <pb_type blif_model=".subckt fourteennm_clk_divider" name="clk_div" num_pb="1">
        <clock name="inclk" num_pins="1"/>
        <output name="clock_div1" num_pins="1"/> 
        <output name="clock_div2" num_pins="1"/>
        <output name="clock_div4" num_pins="1"/>
      </pb_type>
       <interconnect>    
        <complete input="clock_div.inclk" name="core_to_clk_div" output="clk_div.inclk"/>
        <complete input="clk_div.clock_div1 clk_div.clock_div2 clk_div.clock_div4" name="clk_div_to_core" output="clock_div.clock_div_out"/>
      </interconnect>
    </pb_type>


    <pb_type name="LAB">
      <input name="data_in" num_pins="60" equivalent="full"/>
      <input name="control_in" num_pins="5" equivalent="full"/>
      <input name="cin" num_pins="1" equivalent="none"/>
      <output name="data_out" num_pins="40" equivalent="full"/>
      <output name="cout" num_pins="1" equivalent="none"/>
      <clock name="clk" num_pins="2"/>
      <mode name="LAB">
        <pb_type name="alm" num_pb="10">
          <input name="data_in" num_pins="8"/>
          <input name="control" num_pins="5"/>
          <input name="cin" num_pins="1"/>
          <output name="data_out" num_pins="4"/>
          <output name="cout" num_pins="1"/>
          <clock name="clock" num_pins="1"/>
          <mode name="alm">
            <pb_type name="comb_block" num_pb="1">
              <input name="lin" num_pins="8"/>
              <input name="cin" num_pins="1"/>
              <output name="combout" num_pins="2"/>
              <output name="sumout" num_pins="2"/>
              <output name="cout" num_pins="1"/>
              <mode name="comb_block">
                  <pb_type name="lut" num_pb="2">
                    <input name="lin" num_pins="8"/>
                    <input name="cin" num_pins="1"/>
                    <output name="combout" num_pins="1"/>
                    <output name="sumout" num_pins="1"/>
                    <output name="cout" num_pins="1"/>
                    <mode name="fourteennm_lcell">
                      <pb_type blif_model=".subckt fourteennm_lcell_comb" name="lcell_comb" num_pb="1">
                        <input name="dataa" num_pins="1"/>
                        <input name="datab" num_pins="1"/>
                        <input name="datac" num_pins="1"/>
                        <input name="datad" num_pins="1"/>
                        <input name="datae" num_pins="1"/>
                        <input name="dataf" num_pins="1"/>
                        <input name="datag" num_pins="1"/>
                        <input name="datah" num_pins="1"/>
                        <input name="cin" num_pins="1"/>
                        <output name="combout" num_pins="1"/>
                        <output name="sumout" num_pins="1"/>
                        <output name="cout" num_pins="1"/>


                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.combout"/>
                        <delay_constant max="197e-12" min="197e-12" in_port="lcell_comb.datab" out_port="lcell_comb.combout"/>
                        <delay_constant max="78e-12" min="78e-12" in_port="lcell_comb.datac" out_port="lcell_comb.combout"/>
                        <delay_constant max="60e-12" min="60e-12" in_port="lcell_comb.datad" out_port="lcell_comb.combout"/>
                        <delay_constant max="34e-12" min="34e-12" in_port="lcell_comb.datae" out_port="lcell_comb.combout"/>
                        <delay_constant max="4e-12" min="4e-12" in_port="lcell_comb.dataf" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datag" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datah" out_port="lcell_comb.combout"/>

                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.sumout"/>
                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.datab" out_port="lcell_comb.sumout"/>
                        <delay_constant max="122e-12" min="122e-12" in_port="lcell_comb.datac" out_port="lcell_comb.sumout"/>
                        <delay_constant max="103e-12" min="103e-12" in_port="lcell_comb.datad" out_port="lcell_comb.sumout"/>
                        <delay_constant max="67e-12" min="67e-12" in_port="lcell_comb.cin" out_port="lcell_comb.sumout"/>

                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.cout"/>
                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.datab" out_port="lcell_comb.cout"/>
                        <delay_constant max="205e-12" min="205e-12" in_port="lcell_comb.datac" out_port="lcell_comb.cout"/>
                        <delay_constant max="249e-12" min="249e-12" in_port="lcell_comb.datad" out_port="lcell_comb.cout"/>
                        <delay_constant max="40e-12" min="40e-12" in_port="lcell_comb.cin" out_port="lcell_comb.cout"/>
 
                      </pb_type>
                      <interconnect>
                        <!-- LUT inputs -->
                        <direct input="lut.lin[0]" name="in_comp1" output="lcell_comb.dataa"/>
                        <direct input="lut.lin[1]" name="in_comp2" output="lcell_comb.datab"/>
                        <direct input="lut.lin[2]" name="in_comp3" output="lcell_comb.datac"/>
                        <direct input="lut.lin[3]" name="in_comp4" output="lcell_comb.datad"/>
                        <direct input="lut.lin[4]" name="in_comp5" output="lcell_comb.datae"/>
                        <direct input="lut.lin[5]" name="in_comp6" output="lcell_comb.dataf"/>
                        <direct input="lut.lin[6]" name="in_comp7" output="lcell_comb.datag"/>
                        <direct input="lut.lin[7]" name="in_comp8" output="lcell_comb.datah"/>
                        <!-- LUT outputs -->
                        <direct input="lcell_comb.combout" name="out_comp1" output="lut.combout"/>
                        <direct input="lcell_comb.sumout" name="out_comp2" output="lut.sumout"/>
                        <!-- LUT carry chain -->
                        <direct input="lut.cin" name="lut_cin" output="lcell_comb.cin">
                          <pack_pattern name="LAB_carry_chain" in_port="lut.cin" out_port="lcell_comb.cin"/>
                        </direct>
                        <direct input="lcell_comb.cout" name="out_comp3" output="lut.cout">
                          <pack_pattern name="LAB_carry_chain" in_port="lcell_comb.cout" out_port="lut.cout"/>
                        </direct>
                      </interconnect>
                    </mode>
                    <mode name="names_lut">
                      <pb_type blif_model=".names" class="lut" name="lut6" num_pb="1">
                        <input name="in" num_pins="6" port_class="lut_in"/>
                        <output name="out" num_pins="1" port_class="lut_out"/>

                        <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                      </delay_matrix>
                      <delay_matrix type="min" in_port="lut6.in" out_port="lut6.out">
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                      </delay_matrix>
                      </pb_type>


                      <interconnect>
                        <complete input="lut.lin" name="l_complete1" output="lut6.in[5:0]"/>
                        <complete input="lut6.out" name="l_complete2" output="lut.sumout lut.combout"/>
                      </interconnect>
                    </mode>
                  </pb_type>
                  <interconnect>
                    <!-- Inputs to the LUTs -->
                    <complete input="comb_block.lin" name="in_lut0" output="lut[0].lin"/>
                    <complete input="comb_block.lin" name="in_lut1" output="lut[1].lin"/>
                    <!-- Combinational Block Carry Chain -->
                    <direct input="comb_block.cin" name="comb_block_cin" output="lut[0].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="comb_block.cin" out_port="lut[0].cin"/>
                    </direct>
                    <direct input="lut[0].cout" name="lut_to_lut_carry" output="lut[1].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[0].cout" out_port="lut[1].cin"/>
                    </direct>
                    <direct input="lut[1].cout" name="alm_cout" output="comb_block.cout">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[1].cout" out_port="comb_block.cout"/>
                    </direct>
                    <!-- Outputs to the Combinational Block -->
                    <direct input="lut[0].combout" name="lut0_comb" output=" comb_block.combout[0]"/>
                    <direct input="lut[1].combout" name="lut1_comb" output=" comb_block.combout[1]"/>
                    <direct input="lut[0].sumout" name="lut0_sum" output=" comb_block.sumout[0]"/>
                    <direct input="lut[1].sumout" name="lut1_sum" output=" comb_block.sumout[1]"/>
                  </interconnect>
              </mode>
              
            </pb_type>
            <pb_type name="dff" num_pb="4">
              <input name="clrn" num_pins="1"/>
              <input name="sclr" num_pins="1"/>
              <input name="ena" num_pins="1"/>
              <input name="d" num_pins="1"/>
              <output name="q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="stratix10_ff">
                <pb_type blif_model=".subckt fourteennm_ff" name="fourteennm_ff" num_pb="1">
                  <input name="clrn" num_pins="1"/>
                  <input name="sclr" num_pins="1"/>
                  <input name="ena" num_pins="1"/>
                  <input name="d" num_pins="1"/>
                  <output name="q" num_pins="1"/>
                  <clock name="clk" num_pins="1"/>
                  <T_setup value="89e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_hold value="162e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_clock_to_Q max="283e-12" min="283e-12" port="fourteennm_ff.q" clock="clk"/>

                </pb_type>
                <interconnect>
                  <direct input="dff.clrn" name="fourteennm_ff_clrn" output="fourteennm_ff.clrn"/>
                  <direct input="dff.sclr" name="fourteennm_ff_sclr" output="fourteennm_ff.sclr"/>
                  <direct input="dff.ena" name="fourteennm_ff_ena" output="fourteennm_ff.ena"/>
                  <direct input="dff.d" name="fourteennm_ff_d" output="fourteennm_ff.d"/>
                  <direct input="fourteennm_ff.q" name="fourteennm_ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="fourteennm_ff_clk" output="fourteennm_ff.clk"/>
                </interconnect>
              </mode>
              <mode name="latch">
                <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="ff.D" clock="clk"/>
                  <T_hold value="37e-12" port="ff.D" clock="clk"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="ff.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.d" name="ff_d" output="ff.D"/>
                  <direct input="ff.Q" name="ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="ff_clk" output="ff.clk"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <!-- Inputs to LUTs -->
              <direct input="alm.data_in[2:7]" name="in_lut_2_7" output="comb_block.lin[2:7]"/>
              <mux input="alm.data_in[0] comb_block.sumout[0] dff[0].q" name="in_lut_0" output="comb_block.lin[0]"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1] dff[2].q" name="in_lut_1" output="comb_block.lin[1]"/>

              <!-- Inputs to FFs -->
              <mux input="alm.data_in[0] comb_block.sumout[0]" name="in_dff_0" output="dff[0].d"/>
              <direct input="comb_block.combout[0]" name="in_dff_1" output="dff[1].d"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1]" name="in_dff_2" output="dff[2].d"/>
              <direct input="comb_block.combout[1]" name="in_dff_3" output="dff[3].d"/>

              <!-- ALM Outputs-->
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out0" output="alm.data_out[0]"/>
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out1" output="alm.data_out[1]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out2" output="alm.data_out[2]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out3" output="alm.data_out[3]"/>

              <!-- FF Clocks -->
              <direct input="alm.clock" name="clock_dff0" output="dff[0].clk"/>
              <direct input="alm.clock" name="clock_dff1" output="dff[1].clk"/>
              <direct input="alm.clock" name="clock_dff2" output="dff[2].clk"/>
              <direct input="alm.clock" name="clock_dff3" output="dff[3].clk"/>
              <!-- ALM Carry Chain -->
              <direct input="alm.cin" name="alm_cin" output="comb_block.cin">
                <pack_pattern name="LAB_carry_chain" in_port="alm.cin" out_port="comb_block.cin"/>
              </direct>

              <direct input="comb_block.cout" name="alm_cout" output="alm.cout">
                <pack_pattern name="LAB_carry_chain" in_port="comb_block.cout" out_port="alm.cout"/>
              </direct>

              <direct input="alm.control[4]" name="control_1_dff0" output="dff[0].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff0" output="dff[0].ena"/>
              <direct input="alm.control[3]" name="control_3_dff0" output="dff[0].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff1" output="dff[1].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff1" output="dff[1].ena"/>
              <direct input="alm.control[3]" name="control_3_dff1" output="dff[1].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff2" output="dff[2].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff2" output="dff[2].ena"/>
              <direct input="alm.control[0]" name="control_3_dff2" output="dff[2].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff3" output="dff[3].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff3" output="dff[3].ena"/>
              <direct input="alm.control[0]" name="control_3_dff3" output="dff[3].sclr"/>
            </interconnect>
          </mode>
        </pb_type>
        <interconnect>
          <!--LAB-ALM Interconnect-->
          <!-- LAB Input: Global Routing to ALM inputs -->
          <complete input="LAB.data_in" name="LAB_datain" output="alm[9:0].data_in">
            <delay_constant max="145e-12" min="145e-12" in_port="LAB.data_in" out_port="alm[9:0].data_in"/>
          </complete>
          <!-- ALM Outputs: directly drive global routing -->
          <complete input="alm[9:0].data_out" name="LAB_dataout" output="LAB.data_out">
            <delay_constant max="56e-12" min="56e-12" in_port="alm[9:0].data_out" out_port="LAB.data_out"/>
          </complete>   
          <!-- ALM Control Inputs -->
          <complete input="LAB.control_in" name="LAB_control" output="alm[9:0].control">
            <delay_constant max="145e-12" min="145e-12" in_port="LAB.control_in" out_port="alm[9:0].control"/>
          </complete>  
          <!-- LAB Clocks -->
          <complete input="LAB.clk" name="LAB_clock" output="alm[9:0].clock"/>
          <!-- LAB Carry Chain mid-point entry/exit points, this allows the chain to jump early to
               the next LAB, if the full chain would overuse the number of LAB inputs -->
          <!--<complete input="alm[4].cout" name="alm4_midpoint_exit_carry" output="LAB.data_out"/>-->
          <!--<complete input="LAB.data_in" name="alm5_midpoint_entry_carry" output="alm[5].cin"/>-->
          <!--LAB carry chain-->
          <direct input="LAB.cin" name="LAB_cin" output="alm[0].cin">
            <pack_pattern name="LAB_carry_chain" in_port="LAB.cin" out_port="alm[0].cin"/>
          </direct>
          <direct input="alm[0].cout" name="alm0_alm1_carry" output="alm[1].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[0].cout" out_port="alm[1].cin"/>
          </direct>
          <direct input="alm[1].cout" name="alm1_alm2_carry" output="alm[2].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[1].cout" out_port="alm[2].cin"/>
          </direct>
          <direct input="alm[2].cout" name="alm2_alm3_carry" output="alm[3].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[2].cout" out_port="alm[3].cin"/>
          </direct>
          <direct input="alm[3].cout" name="alm3_alm4_carry" output="alm[4].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[3].cout" out_port="alm[4].cin"/>
          </direct>
          <direct input="alm[4].cout" name="alm4_alm5_carry" output="alm[5].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[4].cout" out_port="alm[5].cin"/>
          </direct>
          <direct input="alm[5].cout" name="alm5_alm6_carry" output="alm[6].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[5].cout" out_port="alm[6].cin"/>
          </direct>
          <direct input="alm[6].cout" name="alm6_alm7_carry" output="alm[7].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[6].cout" out_port="alm[7].cin"/>
          </direct>
          <direct input="alm[7].cout" name="alm7_alm8_carry" output="alm[8].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[7].cout" out_port="alm[8].cin"/>
          </direct>
          <direct input="alm[8].cout" name="alm8_alm9_carry" output="alm[9].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[8].cout" out_port="alm[9].cin"/>
          </direct>
          <direct input="alm[9].cout" name="LAB_cout" output="LAB.cout">
            <pack_pattern name="LAB_carry_chain" in_port="alm[9].cout" out_port="LAB.cout"/>
          </direct>


        </interconnect>
      </mode>
      <mode name="MLAB">

        <pb_type name="MLAB" num_pb="1">
          <clock name="clk0" num_pins="1"/>
          <input name="ena0" num_pins="1"/>
          <input name="clr" num_pins="1"/>
          <input name="portaaddr" num_pins="5"/>
          <input name="portabyteenamasks" num_pins="20"/>
          <input name="portadatain" num_pins="20"/>
          <input name="portbaddr" num_pins="5"/>
          <output name="portbdataout" num_pins="20"/>
          <mode name="mlab_cell">
          <pb_type blif_model=".subckt fourteennm_mlab_cell" name="mlab_cell" num_pb="10">
            <input name="ena0" num_pins="1"/>
            <clock name="clk0" num_pins="1"/>
            <input name="clr" num_pins="1"/>
            <input name="portaaddr" num_pins="5"/>
            <input name="portabyteenamasks" num_pins="2"/>
            <input name="portadatain" num_pins="2"/>
            <input name="portbaddr" num_pins="5"/>
            <output name="portbdataout" num_pins="2"/>
                  <T_setup value="66e-12" port="mlab_cell.ena0" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="mlab_cell.portbdataout" clock="clk0"/>

          </pb_type>
          <interconnect>
              <!-- Enable Input: From MLAB block to MLAB cells enable input -->
              <direct input="MLAB.ena0" name="ena0" output="mlab_cell[0].ena0"/>
              <direct input="MLAB.ena0" name="ena1" output="mlab_cell[1].ena0"/>
              <direct input="MLAB.ena0" name="ena2" output="mlab_cell[2].ena0"/>
              <direct input="MLAB.ena0" name="ena3" output="mlab_cell[3].ena0"/>
              <direct input="MLAB.ena0" name="ena4" output="mlab_cell[4].ena0"/>
              <direct input="MLAB.ena0" name="ena5" output="mlab_cell[5].ena0"/>
              <direct input="MLAB.ena0" name="ena6" output="mlab_cell[6].ena0"/>
              <direct input="MLAB.ena0" name="ena7" output="mlab_cell[7].ena0"/>
              <direct input="MLAB.ena0" name="ena8" output="mlab_cell[8].ena0"/>
              <direct input="MLAB.ena0" name="ena9" output="mlab_cell[9].ena0"/>

              <!-- Clear Input: From MLAB block to MLAB cells clear input -->
              <direct input="MLAB.clr" name="clr0" output="mlab_cell[0].clr"/>
              <direct input="MLAB.clr" name="clr1" output="mlab_cell[1].clr"/>
              <direct input="MLAB.clr" name="clr2" output="mlab_cell[2].clr"/>
              <direct input="MLAB.clr" name="clr3" output="mlab_cell[3].clr"/>
              <direct input="MLAB.clr" name="clr4" output="mlab_cell[4].clr"/>
              <direct input="MLAB.clr" name="clr5" output="mlab_cell[5].clr"/>
              <direct input="MLAB.clr" name="clr6" output="mlab_cell[6].clr"/>
              <direct input="MLAB.clr" name="clr7" output="mlab_cell[7].clr"/>
              <direct input="MLAB.clr" name="clr8" output="mlab_cell[8].clr"/>
              <direct input="MLAB.clr" name="clr9" output="mlab_cell[9].clr"/>

              <!-- Write Address: Input write address to the MLAB cells -->
              <direct input="MLAB.portaaddr" name="portaaddr0" output="mlab_cell[0].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr1" output="mlab_cell[1].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr2" output="mlab_cell[2].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr3" output="mlab_cell[3].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr4" output="mlab_cell[4].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr5" output="mlab_cell[5].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr6" output="mlab_cell[6].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr7" output="mlab_cell[7].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr8" output="mlab_cell[8].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr9" output="mlab_cell[9].portaaddr"/>

              <!-- Byte Enable Mask: Input byte enable mask to the MLAB cells -->
              <direct input="MLAB.portabyteenamasks[1:0]" name="portabytenamasks0" output="mlab_cell[0].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[3:2]" name="portabytenamasks1" output="mlab_cell[1].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[5:4]" name="portabytenamasks2" output="mlab_cell[2].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[7:6]" name="portabytenamasks3" output="mlab_cell[3].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[9:8]" name="portabytenamasks4" output="mlab_cell[4].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[11:10]" name="portabytenamasks5" output="mlab_cell[5].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[13:12]" name="portabytenamasks6" output="mlab_cell[6].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[15:14]" name="portabytenamasks7" output="mlab_cell[7].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[17:16]" name="portabytenamasks8" output="mlab_cell[8].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[19:18]" name="portabytenamasks9" output="mlab_cell[9].portabyteenamasks"/>

              <!-- Write Data: Input data to the MLAB cells -->
              <direct input="MLAB.portadatain[1:0]" name="portadatain0" output="mlab_cell[0].portadatain"/>
              <direct input="MLAB.portadatain[3:2]" name="portadatain1" output="mlab_cell[1].portadatain"/>
              <direct input="MLAB.portadatain[5:4]" name="portadatain2" output="mlab_cell[2].portadatain"/>
              <direct input="MLAB.portadatain[7:6]" name="portadatain3" output="mlab_cell[3].portadatain"/>
              <direct input="MLAB.portadatain[9:8]" name="portadatain4" output="mlab_cell[4].portadatain"/>
              <direct input="MLAB.portadatain[11:10]" name="portadatain5" output="mlab_cell[5].portadatain"/>
              <direct input="MLAB.portadatain[13:12]" name="portadatain6" output="mlab_cell[6].portadatain"/>
              <direct input="MLAB.portadatain[15:14]" name="portadatain7" output="mlab_cell[7].portadatain"/>
              <direct input="MLAB.portadatain[17:16]" name="portadatain8" output="mlab_cell[8].portadatain"/>
              <direct input="MLAB.portadatain[19:18]" name="portadatain9" output="mlab_cell[9].portadatain"/>

              <!-- Read Address: Input read address to the MLAB cells -->
              <direct input="MLAB.portbaddr" name="portbaddr0" output="mlab_cell[0].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr1" output="mlab_cell[1].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr2" output="mlab_cell[2].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr3" output="mlab_cell[3].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr4" output="mlab_cell[4].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr5" output="mlab_cell[5].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr6" output="mlab_cell[6].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr7" output="mlab_cell[7].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr8" output="mlab_cell[8].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr9" output="mlab_cell[9].portbaddr"/>

              <!-- Read data: Output data from MLAB cells to the MLAB output -->
              <direct input="mlab_cell[0].portbdataout" name="portbdataout0" output="MLAB.portbdataout[1:0]"/>
              <direct input="mlab_cell[1].portbdataout" name="portbdataout1" output="MLAB.portbdataout[3:2]"/>
              <direct input="mlab_cell[2].portbdataout" name="portbdataout2" output="MLAB.portbdataout[5:4]"/>
              <direct input="mlab_cell[3].portbdataout" name="portbdataout3" output="MLAB.portbdataout[7:6]"/>
              <direct input="mlab_cell[4].portbdataout" name="portbdataout4" output="MLAB.portbdataout[9:8]"/>
              <direct input="mlab_cell[5].portbdataout" name="portbdataout5" output="MLAB.portbdataout[11:10]"/>
              <direct input="mlab_cell[6].portbdataout" name="portbdataout6" output="MLAB.portbdataout[13:12]"/>
              <direct input="mlab_cell[7].portbdataout" name="portbdataout7" output="MLAB.portbdataout[15:14]"/>
              <direct input="mlab_cell[8].portbdataout" name="portbdataout8" output="MLAB.portbdataout[17:16]"/>
              <direct input="mlab_cell[9].portbdataout" name="portbdataout9" output="MLAB.portbdataout[19:18]"/>

              <!-- MLAB cell clocks -->
              <direct input="MLAB.clk0" name="clk0" output="mlab_cell[0].clk0"/>
              <direct input="MLAB.clk0" name="clk1" output="mlab_cell[1].clk0"/>
              <direct input="MLAB.clk0" name="clk2" output="mlab_cell[2].clk0"/>
              <direct input="MLAB.clk0" name="clk3" output="mlab_cell[3].clk0"/>
              <direct input="MLAB.clk0" name="clk4" output="mlab_cell[4].clk0"/>
              <direct input="MLAB.clk0" name="clk5" output="mlab_cell[5].clk0"/>
              <direct input="MLAB.clk0" name="clk6" output="mlab_cell[6].clk0"/>
              <direct input="MLAB.clk0" name="clk7" output="mlab_cell[7].clk0"/>
              <direct input="MLAB.clk0" name="clk8" output="mlab_cell[8].clk0"/>
              <direct input="MLAB.clk0" name="clk9" output="mlab_cell[9].clk0"/>
            </interconnect>
        </mode>
        </pb_type>
        <interconnect>
          <complete input="LAB.clk" name="mlab_clk" output="MLAB.clk0"/>
          <complete input="LAB.data_in" name="mlab_in1" output="MLAB.ena0"/>
          <complete input="LAB.data_in" name="mlab_in2" output="MLAB.clr"/>
          <complete input="LAB.data_in" name="mlab_in3" output="MLAB.portaaddr"/>
          <complete input="LAB.data_in" name="mlab_in4" output="MLAB.portabyteenamasks"/>
          <complete input="LAB.data_in" name="mlab_in5" output="MLAB.portadatain"/>
          <complete input="LAB.data_in" name="mlab_in6" output="MLAB.portbaddr"/>
          <complete input="MLAB.portbdataout" name="mlab_out" output="LAB.data_out"/>
        </interconnect>
      </mode>
    </pb_type>

    <pb_type name="OCT" >
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="1"/>

       <!-- the input pad is used is connected to rzqin pin -->
      <pb_type blif_model=".input" name="inpad" num_pb="1">
        <output name="inpad" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination" name="oct_block" num_pb="1">
        <input name="rzqin" num_pins="1"/> <!-- connects to an external reference resistor -->
        <input name="enserusr" num_pins="1"/> <!-- specifies the oct block to read from  -->
        <input name="nclrusr" num_pins="1"/> <!-- clear signal -->
        <input name="clkenusr" num_pins="1"/>
        <clock name="clkusr" num_pins="1"/>
        <input name="ser_data_dq_from_core" num_pins="1"/>
        <input name="ser_data_ca_from_core" num_pins="1"/>
        <input name="test_clkusr_en_n" num_pins="1"/>
        <input name="oct_scanin" num_pins="1"/>
        <output name="clkusr_dft_out" num_pins="1"/>
        <output name="oct_scanout" num_pins="1"/>
        <output name="compout_rdn" num_pins="1"/>
        <output name="compout_rup" num_pins="1"/>
        <output name="serdataout" num_pins="1"/>
        <output name="ser_data_dq_to_core" num_pins="1"/>
        <output name="ser_data_ca_to_core" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination_logic" name="oct_logic" num_pb="1">
        <input name="s2pload" num_pins="1"/>
        <input name="serdata" num_pins="1"/>
        <input name="scan_in" num_pins="1"/>
        <input name="scan_shift_in" num_pins="1"/>
        <output name="scan_out" num_pins="1"/>
        <output name="seriesterminationcontrol" num_pins="16"/>
        <output name="parallelterminationcontrol" num_pins="16"/>
      </pb_type>

      <interconnect>
        <direct input="OCT.clk" name="clk_to_oct_block" output="oct_block.clkusr"/>

        <!-- the rzqin pin is connected to an external resistor -->
        <direct input="inpad.inpad" name="rzqin_in" output="oct_block.rzqin"/>

        <!-- oct_block inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_block" output="oct_block.enserusr oct_block.nclrusr oct_block.clkenusr oct_block.ser_data_dq_from_core oct_block.ser_data_ca_from_core oct_block.test_clkusr_en_n oct_block.oct_scanin"/>

        <!-- oct_logic inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_logic" output="oct_logic.s2pload oct_logic.scan_in oct_logic.scan_shift_in" />
        <!-- oct_logic serdata coming from serdataout of the oct block -->
        <direct input="oct_block.serdataout" name="serdata_path" output="oct_logic.serdata"/>

        <!-- oct_block outputs going to the core logic -->
        <complete input="oct_block.clkusr_dft_out oct_block.oct_scanout oct_block.compout_rdn oct_block.compout_rup oct_block.ser_data_dq_to_core oct_block.ser_data_ca_to_core" name="oct_block_to_core" output="OCT.core_out"/>

        <!-- oct_logic outputs going to the core logic -->
        <complete input="oct_logic.scan_out oct_logic.seriesterminationcontrol oct_logic.parallelterminationcontrol" name="oct_logic_to_core" output="OCT.core_out"/>
        
      </interconnect>
    </pb_type>

    <pb_type name="iolane">
      <input name="core_in" num_pins="55"/>
      <output name="core_out" num_pins="24"/>
      <clock name="clk" num_pins="1"/>

      <pb_type name="io_cell" num_pb="4">
        <input name="data_in" num_pins="36"/>
        <output name="data_out" num_pins="6"/>
        <clock name="clk" num_pins="1"/>

        <mode name="io_cell" num_pb="1">

          <pb_type name="pad" num_pb="1">
            <output name="recieve_off_chip" num_pins="1"/>
            <input name="drive_off_chip" num_pins="1"/>

            <pb_type blif_model=".input" name="inpad" num_pb="1">
              <output name="inpad" num_pins="1"/>
            </pb_type>

            <pb_type blif_model=".output" name="outpad" num_pb="1">
              <input name="outpad" num_pins="1"/>
            </pb_type>

            <interconnect>
            <direct input="inpad.inpad" name="inpad" output="pad.recieve_off_chip"/>
            <direct input="pad.drive_off_chip" name="outpad" output="outpad.outpad"/>
            </interconnect>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ff" name="oe_ff" num_pb="1">
            <input name="clrn" num_pins="1"/> <!-- driver signal for clrn, sclr, ena, and d comes from the core logic -->
            <input name="sclr" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="d" num_pins="1"/>
            <output name="q" num_pins="1"/> <!-- driving the output enable port of the output buffer -->
            <clock name="clk" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_obuf" name="obuf" num_pb="1">
            <input name="i" num_pins="1"/> <!-- can be driven by the core logic through obuf_i port of the parent pb_type or by the dataout port of the ddio_out -->
            <input name="oe" num_pins="1"/> <!-- output enable port driven by the q output of the OE flip flop or the core logic -->
            <input name="dynamicterminationcontrol" num_pins="1"/> <!-- the following three ports driven by the corresponding ports in the parent pb_type -->
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <!-- <input name="devoe" num_pins="1"/>
            <input name="emif_phy_in" num_pins="2"/> -->
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_ibuf" name="ibuf" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="dynamicterminationcontrol" num_pins="1"/>
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <output name="o" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_out" name="ddio_out" num_pb="1">
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <input name="clkhi" num_pins="1"/>
            <input name="clklo" num_pins="1"/>
            <input name="muxsel" num_pins="1"/>
            <input name="datainlo" num_pins="1"/>
            <input name="datainhi" num_pins="1"/>
            <output name="dataout" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="dffhi" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="hrbypass" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_in" name="ddio_in" num_pb="1">
            <clock name="clk" num_pins="1"/>
            <input name="clkn" num_pins="1"/>
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="datain" num_pins="1"/>
            <output name="regoutlo" num_pins="1"/>
            <output name="regouthi" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_pseudo_diff_out" name="pseudo_diff_out" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="oein" num_pins="1"/>
            <input name="oebin"  num_pins="1"/>
            <input name="dtcin" num_pins="1"/>
            <input name="dtcbarin" num_pins="1"/>
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
            <output name="oeout" num_pins="1"/>
            <output name="oebout" num_pins="1"/>
            <output name="dtc" num_pins="1"/>
            <output name="dtcbar" num_pins="1"/>
            <!-- <input name="emif_phy_in" num_pins="2"/>
            <input name="emif_phy_inb" num_pins="2"/>
            <output name="emif_phy_out" num_pins="2"/>
            <output name="emif_phy_outb" num_pins="2"/> -->
          </pb_type>

          <interconnect>
            <!-- inputs coming from the FPGA core and going to OE flip flop -->
            <complete input="io_cell.data_in" name="core_to_ff" output="oe_ff.clrn oe_ff.sclr oe_ff.ena oe_ff.d"/>
            <direct input="io_cell.clk" name="ff_clk" num_pins="1" output="oe_ff.clk"/>

            <!-- inputs coming from the FPGA core and going to ddio out primitive -->
            <complete input="io_cell.data_in" name="core_to_ddio_out" num_pins="1" output="ddio_out.areset ddio_out.sreset ddio_out.ena ddio_out.clkhi ddio_out.clklo ddio_out.muxsel ddio_out.datainlo ddio_out.datainhi"/>
            <direct input="io_cell.clk" name="ddio_out_clk" num_pins="1" output="ddio_out.clk"/>

            <!-- inputs coming from the FPGA core and going to the output buffer -->
            <complete input="io_cell.data_in" name="core_to_obuf" output="obuf.dynamicterminationcontrol obuf.seriesterminationcontrol obuf.parallelterminationcontrol"/>
            <!-- the i port of the output buffer can be driven by the output of the ddio out module or the core logic or the o output of the pseudo diff out-->
            <complete input="io_cell.data_in ddio_out.dataout pseudo_diff_out.o" name="i_obuff" num_pins="1" output="obuf.i"/>
            <!-- the oe port of the output buffer can be driven by the output of the oe flip flop or the core logic or the oeout output of the pseudo diff out-->
            <complete input="io_cell.data_in oe_ff.q pseudo_diff_out.oeout" name="oe_obuff" num_pins="1" output="obuf.oe"/>

            <!-- inputs coming from the FPGA core and going to the input buffer -->
            <complete input="io_cell.data_in" name="core_to_ibuff" output="ibuf.ibar ibuf.dynamicterminationcontrol ibuf.seriesterminationcontrol ibuf.parallelterminationcontrol"/>
            <!-- the output of the padin will directly drive the input buffer  -->
            <direct input="pad.recieve_off_chip" name="pad_receive" num_pins="1" output="ibuf.i">
              <pack_pattern name="pad_to_ibuf" in_port="pad.recieve_off_chip" out_port="ibuf.i"/>
            </direct>

            <!-- inputs coming from the FPGA core and going to pseudo diff out primitive -->
            <complete input="io_cell.data_in" name="core_to_pseudo_diff_out" num_pins="1" output="pseudo_diff_out.ibar pseudo_diff_out.oebin pseudo_diff_out.dtcin pseudo_diff_out.dtcbarin"/>
            <!-- the i port of the  pseudo diff out can be driven by the output of the ddio out module or the core logic -->
            <complete input="io_cell.data_in ddio_out.dataout" name="i_pseudo_diff" num_pins="1" output=" pseudo_diff_out.i"/>
            <!-- the oein port of the pseudo diff out can be driven by the output of the oe flip flop or the core logic -->
            <complete input="io_cell.data_in oe_ff.q" name="oe_pseudo_diff" num_pins="1" output="pseudo_diff_out.oein"/>

            <!-- inputs coming from the FPGA core and going to ddio in primitive -->
            <complete input="io_cell.data_in" name="core_to_ddio_in" num_pins="1" output="ddio_in.clkn ddio_in.areset ddio_in.sreset ddio_in.ena"/>
            <direct input="io_cell.clk" name="ddioi_clk" num_pins="1" output="ddio_in.clk"/>

            <!-- the data port of theddio in is driven by the output of the input buffer or by FPGA global routing -->
            <complete input="ibuf.o io_cell.data_in" name="ddioi_datain" num_pins="1" output="ddio_in.datain"/>

            <!-- the pad out can be driven by the output ports of the output buffer or by FPGA core  -->
            <complete input="io_cell.data_in obuf.o obuf.obar" name="pad_drive" num_pins="1" output="pad.drive_off_chip">
              <pack_pattern name="obuf_to_pad" in_port="obuf.o" out_port="pad.drive_off_chip"/>
            </complete>

            <!-- the outputs of the io_cell block going to the core -->
            <direct input="pseudo_diff_out.obar" name="io_cell_obar" num_pins="1" output="io_cell.data_out[0]"/>
            <direct input="pseudo_diff_out.oebout" name="io_cell_oeout" num_pins="1" output="io_cell.data_out[1]"/>
            <direct input="pseudo_diff_out.dtc" name="io_cell_dtc" num_pins="1" output="io_cell.data_out[2]"/>
            <direct input="pseudo_diff_out.dtcbar" name="io_cell_dtcbar" num_pins="1" output="io_cell.data_out[3]"/>
            <complete input="ibuf.o ddio_in.regoutlo pad.recieve_off_chip" name="io_cell_regoutlo" num_pins="1" output="io_cell.data_out[4]"/>
            <direct input="ddio_in.regouthi" name="io_cell_regouthi" num_pins="1" output="io_cell.data_out[5]"/>

          </interconnect>
        </mode>
      </pb_type>

      <interconnect>
        <complete input="iolane.core_in" name="core_to_io" output="io_cell.data_in"/>
        <complete input="io_cell.data_out" name="io_to_core" output="iolane.core_out"/>
        <direct input="iolane.clk" name="clk_connection0" output="io_cell[0].clk" />
        <direct input="iolane.clk" name="clk_connection1" output="io_cell[1].clk" />
        <direct input="iolane.clk" name="clk_connection2" output="io_cell[2].clk" />
        <direct input="iolane.clk" name="clk_connection3" output="io_cell[3].clk" />
      </interconnect>
    </pb_type>

    <pb_type name="DSP">
      <input name="datain" num_pins="110"/>
      <input name="chainin" num_pins="64"/>
      <input name="controlin" num_pins="17"/>
      <input name="scanin" num_pins="27"/>
      <clock name="clk" num_pins="3"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <output name="dftout" num_pins="1"/>
      <!-- 
           We model several different operation modes of the fourteennm_mac primitive:
                independent multiplier 
                multiplier adder sum 
                18x19 multiplication summed with 36-bit input 
                systolic fir 
                27x27 independent multiplier 
                single 18x18 multiplier

            As well as several operation modes of the fourteennm_fp_mac primitive:
                multiplication
                multiply accumulate
                multiply add
                adder or subtract
                vector one mode
                vector two mode

           We also model 4 variations of each operation mode to capture timing differences based on whether the inputs and/or outputs are 
           registered or combinational.

           This is itself an approximation of the actual Stratix 10 architecture, which can support multiple levels of internal registers
           inside each DSP block.  To model this would be extremely verbose and time consuming. The approximation mentioned above is a 
           reasonable compromise, since it captures the key timing characteristics of the fourteennm_mac or fourteennm_fp_mac from an external perspective (which is
           what most pack/place/route CAD tools would care about).  
        -->

        <!-- independent multiplier mode -->
			<mode name="m18x18_full.input_type{reg}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{comb}" name="mac18x18_full" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="64"/>
					<output name="resultb" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
					<direct input="mac18x18_full.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_full.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
					<direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="DSP.result[73:37]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_full.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{reg}" name="mac18x18_full" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="64"/>
					<output name="resultb" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
					<direct input="mac18x18_full.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_full.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
					<direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="DSP.result[73:37]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_full.input_type{comb}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{comb}" name="mac18x18_full" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="64"/>
					<output name="resultb" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
          <clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
					<direct input="mac18x18_full.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_full.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
					<direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="DSP.result[73:37]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_full.output_clk"/>          
				</interconnect>
			</mode>

			<mode name="m18x18_full.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{reg}" name="mac18x18_full" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="64"/>
					<output name="resultb" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
					<direct input="mac18x18_full.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_full.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
					<direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="DSP.result[73:37]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
				</interconnect>
			</mode>

        <!-- multiplier adder sum mode -->
			<mode name="m18x18_sumof2.input_type{reg}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{comb}" name="mac18x18_sumof2" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
					<direct input="mac18x18_sumof2.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
					<direct input="mac18x18_sumof2.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_sumof2.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
					<direct input="mac18x18_sumof2.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_sumof2.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{reg}" name="mac18x18_sumof2" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
					<direct input="mac18x18_sumof2.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
					<direct input="mac18x18_sumof2.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_sumof2.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
					<direct input="mac18x18_sumof2.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_sumof2.input_type{comb}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{comb}" name="mac18x18_sumof2" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
					<direct input="mac18x18_sumof2.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
					<direct input="mac18x18_sumof2.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_sumof2.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
					<direct input="mac18x18_sumof2.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_sumof2.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{reg}" name="mac18x18_sumof2" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
					<direct input="mac18x18_sumof2.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
					<direct input="mac18x18_sumof2.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_sumof2.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
					<direct input="mac18x18_sumof2.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
				</interconnect>
			</mode>
 

        <!-- 18x19 multiplication summed with 36-bit input -->
			<mode name="m18x18_plus36.input_type{reg}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{comb}" name="mac18x18_plus36" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="18"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
					<direct input="mac18x18_plus36.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="mac18x18_plus36.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
					<direct input="DSP.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
					<direct input="mac18x18_plus36.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_plus36.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{reg}" name="mac18x18_plus36" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="18"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
					<direct input="mac18x18_plus36.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="mac18x18_plus36.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
					<direct input="DSP.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
					<direct input="mac18x18_plus36.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_plus36.input_type{comb}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{comb}" name="mac18x18_plus36" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="18"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
					<direct input="mac18x18_plus36.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="mac18x18_plus36.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
					<direct input="DSP.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
					<direct input="mac18x18_plus36.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
				</interconnect>
			</mode>
      
			<mode name="m18x18_plus36.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{reg}" name="mac18x18_plus36" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="18"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
					<direct input="mac18x18_plus36.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="mac18x18_plus36.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
					<direct input="DSP.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
					<direct input="mac18x18_plus36.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
				</interconnect>
			</mode>


        <!-- systolic fir mode -->
			<mode name="m18x18_systolic.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_systolic}.input_type{comb}.output_type{reg}" name="mac18x18_systolic" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_systolic.chainin"/>
					<direct input="mac18x18_systolic.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_systolic.scanin"/>
					<direct input="mac18x18_systolic.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_systolic.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_systolic.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_systolic.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_systolic.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_systolic.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_systolic.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_systolic.bz"/>
					<direct input="mac18x18_systolic.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_systolic.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_systolic.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_systolic.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_systolic.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_systolic.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_systolic.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_systolic.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_systolic.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_systolic.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_systolic.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_systolic.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_systolic.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_systolic.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_systolic.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_systolic.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_systolic.bz_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_systolic.sub_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_systolic.negate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_systolic.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_systolic.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_systolic.output_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_systolic.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_systolic.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_systolic.coef_sel_b_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_systolic.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_systolic}.input_type{reg}.output_type{reg}" name="mac18x18_systolic" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="19"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="bx" num_pins="18"/>
					<input name="by" num_pins="19"/>
					<input name="bz" num_pins="18"/>
					<input name="coefselb" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="19"/>
					<input name="sub" num_pins="1"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="bx_clk" num_pins="1"/>
					<clock name="by_clk" num_pins="1"/>
					<clock name="bz_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
					<clock name="coef_sel_b_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac18x18_systolic.chainin"/>
					<direct input="mac18x18_systolic.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_systolic.scanin"/>
					<direct input="mac18x18_systolic.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_systolic.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_systolic.ax"/>
					<direct input="DSP.datain[36:18]" name="ay_in" output="mac18x18_systolic.ay"/>
					<direct input="DSP.datain[54:37]" name="az_in" output="mac18x18_systolic.az"/>
					<direct input="DSP.datain[72:55]" name="bx_in" output="mac18x18_systolic.bx"/>
					<direct input="DSP.datain[91:73]" name="by_in" output="mac18x18_systolic.by"/>
					<direct input="DSP.datain[109:92]" name="bz_in" output="mac18x18_systolic.bz"/>
					<direct input="mac18x18_systolic.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_systolic.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_systolic.coefsela"/>
					<direct input="DSP.controlin[7:5]" name="coefselb_in" output="mac18x18_systolic.coefselb"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_systolic.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_systolic.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_systolic.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac18x18_systolic.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac18x18_systolic.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_systolic.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_systolic.sub"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_systolic.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_systolic.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_systolic.az_clk"/>
					<complete input="DSP.clk" name="clk_in3" output="mac18x18_systolic.bx_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_systolic.by_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_systolic.bz_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_systolic.sub_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac18x18_systolic.negate_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac18x18_systolic.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac18x18_systolic.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in11" output="mac18x18_systolic.output_clk"/>
					<complete input="DSP.clk" name="clk_in12" output="mac18x18_systolic.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in13" output="mac18x18_systolic.coef_sel_a_clk"/>
					<complete input="DSP.clk" name="clk_in14" output="mac18x18_systolic.coef_sel_b_clk"/>
				</interconnect>
			</mode>

        <!-- 27x27 independent multiplier mode -->
			<mode name="m27x27.input_type{reg}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{comb}" name="mac27x27" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="27"/>
					<input name="ay" num_pins="27"/>
					<input name="az" num_pins="26"/>
					<input name="coefsela" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="27"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="27"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac27x27.chainin"/>
					<direct input="mac27x27.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin" name="scan_in" output="mac27x27.scanin"/>
					<direct input="mac27x27.scanout" name="scan_out" output="DSP.scanout"/>
					<direct input="mac27x27.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
					<direct input="DSP.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
					<direct input="DSP.datain[79:54]" name="az_in" output="mac27x27.az"/>
					<direct input="mac27x27.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac27x27.negate"/>
					<complete input="DSP.clk" name="clk_in0" output="mac27x27.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac27x27.az_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac27x27.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac27x27.output_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m27x27.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{reg}" name="mac27x27" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="27"/>
					<input name="ay" num_pins="27"/>
					<input name="az" num_pins="26"/>
					<input name="coefsela" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="27"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="27"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac27x27.chainin"/>
					<direct input="mac27x27.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin" name="scan_in" output="mac27x27.scanin"/>
					<direct input="mac27x27.scanout" name="scan_out" output="DSP.scanout"/>
					<direct input="mac27x27.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
					<direct input="DSP.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
					<direct input="DSP.datain[79:54]" name="az_in" output="mac27x27.az"/>
					<direct input="mac27x27.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac27x27.negate"/>
					<complete input="DSP.clk" name="clk_in0" output="mac27x27.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac27x27.az_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac27x27.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac27x27.output_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m27x27.input_type{comb}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{comb}" name="mac27x27" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="27"/>
					<input name="ay" num_pins="27"/>
					<input name="az" num_pins="26"/>
					<input name="coefsela" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="27"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="27"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac27x27.chainin"/>
					<direct input="mac27x27.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin" name="scan_in" output="mac27x27.scanin"/>
					<direct input="mac27x27.scanout" name="scan_out" output="DSP.scanout"/>
					<direct input="mac27x27.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
					<direct input="DSP.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
					<direct input="DSP.datain[79:54]" name="az_in" output="mac27x27.az"/>
					<direct input="mac27x27.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac27x27.negate"/>
					<complete input="DSP.clk" name="clk_in0" output="mac27x27.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac27x27.az_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac27x27.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac27x27.output_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m27x27.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{reg}" name="mac27x27" num_pb="1">
					<input name="accumulate" num_pins="1"/>
					<input name="chainin" num_pins="64"/>
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="27"/>
					<input name="ay" num_pins="27"/>
					<input name="az" num_pins="26"/>
					<input name="coefsela" num_pins="3"/>
					<input name="loadconst" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="scanin" num_pins="27"/>
					<input name="ena" num_pins="3"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="chainout" num_pins="64"/>
					<output name="resulta" num_pins="64"/>
					<output name="scanout" num_pins="27"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="loadconst_clk" num_pins="1"/>
					<clock name="accumulate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="chainout_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.chainin" name="chain_in" output="mac27x27.chainin"/>
					<direct input="mac27x27.chainout" name="chain_out" output="DSP.chainout"/>
					<direct input="DSP.scanin" name="scan_in" output="mac27x27.scanin"/>
					<direct input="mac27x27.scanout" name="scan_out" output="DSP.scanout"/>
					<direct input="mac27x27.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
					<direct input="DSP.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
					<direct input="DSP.datain[79:54]" name="az_in" output="mac27x27.az"/>
					<direct input="mac27x27.resulta" name="resulta_out" output="DSP.result[63:0]"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac27x27.negate"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
					<direct input="DSP.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
					<direct input="DSP.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
					<complete input="DSP.clk" name="clk_in0" output="mac27x27.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac27x27.az_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac27x27.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
					<complete input="DSP.clk" name="clk_in8" output="mac27x27.output_clk"/>
					<complete input="DSP.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
					<complete input="DSP.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
				</interconnect>
			</mode>

        <!-- single 18x18 multiplier mode -->
			<mode name="m18x18_top.input_type{reg}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{comb}" name="mac18x18_top" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="18"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="sub" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="37"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
					<direct input="mac18x18_top.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_top.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
					<direct input="DSP.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
					<direct input="DSP.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
					<direct input="mac18x18_top.resulta" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_top.input_type{comb}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{reg}" name="mac18x18_top" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="18"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="sub" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="37"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
					<direct input="mac18x18_top.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_top.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
					<direct input="DSP.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
					<direct input="DSP.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
					<direct input="mac18x18_top.resulta" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_top.input_type{comb}.output_type{comb}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{comb}" name="mac18x18_top" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="18"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="sub" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="37"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
					<direct input="mac18x18_top.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_top.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
					<direct input="DSP.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
					<direct input="DSP.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
					<direct input="mac18x18_top.resulta" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
				</interconnect>
			</mode>

			<mode name="m18x18_top.input_type{reg}.output_type{reg}">
				<pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{reg}" name="mac18x18_top" num_pb="1">
					<input name="clr" num_pins="2"/>
					<input name="ax" num_pins="18"/>
					<input name="ay" num_pins="18"/>
					<input name="az" num_pins="18"/>
					<input name="coefsela" num_pins="3"/>
					<input name="scanin" num_pins="19"/>
					<input name="ena" num_pins="3"/>
					<input name="sub" num_pins="1"/>
					<input name="negate" num_pins="1"/>
					<input name="dfxlfsrena" num_pins="1"/>
					<input name="dfxmisrena" num_pins="1"/>
					<output name="resulta" num_pins="37"/>
					<output name="scanout" num_pins="19"/>
					<output name="dftout" num_pins="1"/>
					<clock name="ax_clk" num_pins="1"/>
					<clock name="ay_scan_in_clk" num_pins="1"/>
					<clock name="az_clk" num_pins="1"/>
					<clock name="sub_clk" num_pins="1"/>
					<clock name="negate_clk" num_pins="1"/>
					<clock name="output_clk" num_pins="1"/>
					<clock name="coef_sel_a_clk" num_pins="1"/>
				</pb_type>
				<interconnect>
					<direct input="DSP.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
					<direct input="mac18x18_top.scanout" name="scan_out" output="DSP.scanout[18:0]"/>
					<direct input="mac18x18_top.dftout" name="dft_out" output="DSP.dftout"/>
					<direct input="DSP.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
					<direct input="DSP.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
					<direct input="DSP.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
					<direct input="mac18x18_top.resulta" name="resulta_out" output="DSP.result[36:0]"/>
					<direct input="DSP.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
					<direct input="DSP.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
					<direct input="DSP.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
					<direct input="DSP.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
					<direct input="DSP.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
					<direct input="DSP.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
					<direct input="DSP.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
					<complete input="DSP.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
					<complete input="DSP.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
					<complete input="DSP.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
					<complete input="DSP.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
					<complete input="DSP.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
					<complete input="DSP.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
					<complete input="DSP.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
				</interconnect>
			</mode>


        <!-- fp multiplication mode -->
        <mode name="sp_mult.input_type{reg}.output_type{comb}">
           <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_mult.chainin"/>
                <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_mult.dftout" output="DSP.dftout"/>

                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_mult.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_mult.az"/>

                <direct name="resulta_out" input="fp_mac_mult.resulta" output="DSP.result[31:0]"/>
                <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_mult.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_mult.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                <complete name="clk_in" input="DSP.clk" output="fp_mac_mult.ay_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_mult.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_mult.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_mult.input_type{comb}.output_type{reg}">
           <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_mult.chainin"/>
                <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_mult.dftout" output="DSP.dftout"/>

                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_mult.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_mult.az"/>

                <direct name="resulta_out" input="fp_mac_mult.resulta" output="DSP.result[31:0]"/>
                <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_mult.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_mult.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                <complete name="clk_in" input="DSP.clk" output="fp_mac_mult.ay_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_mult.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_mult.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_mult.input_type{comb}.output_type{comb}">
           <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>

                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_mult.chainin"/>
                <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_mult.dftout" output="DSP.dftout"/>

                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_mult.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_mult.az"/>

                <direct name="resulta_out" input="fp_mac_mult.resulta" output="DSP.result[31:0]"/>
                <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_mult.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_mult.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                <complete name="clk_in" input="DSP.clk" output="fp_mac_mult.ay_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_mult.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_mult.output_clk"/>
            </interconnect> 
        </mode>

        <mode name="sp_mult.input_type{reg}.output_type{reg}">
           <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_mult.chainin"/>
                <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_mult.dftout" output="DSP.dftout"/>

                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_mult.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_mult.az"/>

                <direct name="resulta_out" input="fp_mac_mult.resulta" output="DSP.result[31:0]"/>
                <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_mult.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_mult.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_mult.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_mult.ay_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_mult.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_mult.output_clk"/>

            </interconnect> 
        </mode>

        <!-- fp multiply accumulate mode -->
        <mode name="sp_mult_acc.input_type{comb}.output_type{reg}">
          <pb_type name="fp_mac_multacc" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{comb}.output_type{reg}" num_pb="1">
            <input name="accumulate" num_pins="1"/>
            <input name="chainin" num_pins="32"/>
            <input name="clr" num_pins="2"/>
            <clock name="accumulate_clk" num_pins="1"/>
            <clock name="az_clk" num_pins="1"/>
            <clock name="ay_clk" num_pins="1"/>
            <clock name="output_clk" num_pins="1"/>
            <input name="ay" num_pins="32"/>
            <input name="az" num_pins="32"/>
            <input name="ena" num_pins="3"/>
            <input name="dfxlfsrena" num_pins="1"/>
            <input name="dfxmisrena" num_pins="1"/>

            <output name="chainout" num_pins="32"/>
            <output name="resulta" num_pins="32"/>
            <output name="adder_inexact" num_pins="1"/>
            <output name="adder_invalid" num_pins="1"/>
            <output name="adder_overflow" num_pins="1"/>
            <output name="adder_underflow" num_pins="1"/>
            <output name="mult_inexact" num_pins="1"/>
            <output name="mult_invalid" num_pins="1"/>
            <output name="mult_overflow" num_pins="1"/>
            <output name="mult_underflow" num_pins="1"/>
            <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

            <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multacc.chainin"/>
            <direct name="chain_out" input="fp_mac_multacc.chainout[31:0]" output="DSP.chainout[31:0]"/>
            <direct name="dft_out" input="fp_mac_multacc.dftout" output="DSP.dftout"/>

            <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multacc.ay"/>
            <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multacc.az"/>

            <direct name="resulta_out" input="fp_mac_multacc.resulta" output="DSP.result[31:0]"/>
            <direct name="adder_inexact_out" input="fp_mac_multacc.adder_inexact" output="DSP.result[32]" />
            <direct name="adder_invalid_out" input="fp_mac_multacc.adder_invalid" output="DSP.result[33]" />
            <direct name="adder_overflow_out" input="fp_mac_multacc.adder_overflow" output="DSP.result[34]" />
            <direct name="adder_underflow_out" input="fp_mac_multacc.adder_underflow" output="DSP.result[35]" />
            <direct name="mult_inexact_out" input="fp_mac_multacc.mult_inexact" output="DSP.result[36]" />
            <direct name="mult_invlid_out" input="fp_mac_multacc.mult_invalid" output="DSP.result[37]" />
            <direct name="mult_overflow_out" input="fp_mac_multacc.mult_overflow" output="DSP.result[38]" />
            <direct name="mult_underflow_out" input="fp_mac_multacc.mult_underflow" output="DSP.result[39]" />

            
            <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multacc.clr"/>
            <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multacc.ena"/>
            <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multacc.dfxlfsrena"/>
            <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multacc.dfxmisrena"/>
            <direct name="accumulate" input="DSP.controlin[13]" output="fp_mac_multacc.accumulate"/>

            <complete name="clk_in" input="DSP.clk" output="fp_mac_multacc.az_clk"/>
            <complete name="clk_in2" input="DSP.clk" output="fp_mac_multacc.ay_clk"/>
            <complete name="clk_in3" input="DSP.clk" output="fp_mac_multacc.output_clk"/>
            <complete name="clk_in4" input="DSP.clk" output="fp_mac_multacc.accumulate_clk"/>

          </interconnect> 
        </mode>

        <mode name="sp_mult_acc.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_multacc" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="accumulate" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <clock name="accumulate_clk" num_pins="1"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multacc.chainin"/>
                <direct name="chain_out" input="fp_mac_multacc.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_multacc.dftout" output="DSP.dftout"/>

                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multacc.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multacc.az"/>

                <direct name="resulta_out" input="fp_mac_multacc.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_multacc.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_multacc.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_multacc.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_multacc.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_multacc.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_multacc.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_multacc.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_multacc.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multacc.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multacc.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multacc.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multacc.dfxmisrena"/>
                <direct name="accumulate" input="DSP.controlin[13]" output="fp_mac_multacc.accumulate"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_multacc.az_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_multacc.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_multacc.output_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_multacc.accumulate_clk"/>

            </interconnect> 
        </mode>

        <!-- fp multiply add mode -->
        <mode name="sp_mult_add.input_type{reg}.output_type{comb}">
            <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_multadd.dftout" output="DSP.dftout"/>
                
                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_multadd.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multadd.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multadd.az"/>

                <direct name="resulta_out" input="fp_mac_multadd.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multadd.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multadd.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>
                <complete name="clk_in" input="DSP.clk" output="fp_mac_multadd.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_multadd.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_multadd.ay_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_multadd.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_mult_add.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_multadd.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_multadd.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multadd.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multadd.az"/>

                <direct name="resulta_out" input="fp_mac_multadd.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multadd.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multadd.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_multadd.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_multadd.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_multadd.ay_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_multadd.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_mult_add.input_type{comb}.output_type{comb}">
            <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>

                <clock name="ax_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_multadd.dftout" output="DSP.dftout"/>
                
                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_multadd.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multadd.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multadd.az"/>

                <direct name="resulta_out" input="fp_mac_multadd.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multadd.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multadd.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_multadd.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_multadd.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_multadd.ay_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_multadd.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_mult_add.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_multadd.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_multadd.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_multadd.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_multadd.az"/>

                <direct name="resulta_out" input="fp_mac_multadd.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_multadd.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_multadd.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_multadd.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_multadd.az_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_multadd.ay_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_multadd.output_clk"/>

            </interconnect> 
        </mode>

        <!-- fp adder or subtract mode -->
        <mode name="sp_add.input_type{reg}.output_type{comb}">
            <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_add.chainin"/>
                <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_add.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_add.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_add.ay"/>

                <direct name="resulta_out" input="fp_mac_add.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="DSP.result[35]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_add.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_add.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_add.dfxmisrena"/>
                <complete name="clk_in" input="DSP.clk" output="fp_mac_add.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_add.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_add.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_add.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_add.chainin"/>
                <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_add.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_add.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_add.ay"/>

                <direct name="resulta_out" input="fp_mac_add.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="DSP.result[35]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_add.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_add.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_add.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_add.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_add.output_clk"/>
            </interconnect> 
        </mode>

        <mode name="sp_add.input_type{comb}.output_type{comb}">
            <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_add.chainin"/>
                <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_add.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_add.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_add.ay"/>

                <direct name="resulta_out" input="fp_mac_add.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="DSP.result[35]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_add.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_add.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_add.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_add.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_add.output_clk"/>

            </interconnect> 
        </mode>
        
        <mode name="sp_add.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_add.chainin"/>
                <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_add.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_add.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_add.ay"/>

                <direct name="resulta_out" input="fp_mac_add.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="DSP.result[35]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_add.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_add.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_add.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_add.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_add.output_clk"/>

            </interconnect> 
        </mode>

        <!-- fp vector one mode -->
        <mode name="sp_vector1.input_type{reg}.output_type{comb}">
            <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect1.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect1.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect1.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect1.az"/>

                <direct name="resulta_out" input="fp_mac_vect1.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect1.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect1.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect1.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect1.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect1.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect1.output_clk"/>
            </interconnect> 
        </mode>

        <mode name="sp_vector1.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect1.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect1.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect1.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect1.az"/>

                <direct name="resulta_out" input="fp_mac_vect1.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect1.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect1.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>
                
                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect1.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect1.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect1.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect1.output_clk"/>
           </interconnect> 
        </mode>

        <mode name="sp_vector1.input_type{comb}.output_type{comb}">
            <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect1.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect1.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect1.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect1.az"/>

                <direct name="resulta_out" input="fp_mac_vect1.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect1.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect1.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect1.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect1.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect1.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect1.output_clk"/>
            </interconnect> 
        </mode>

        <mode name="sp_vector1.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect1.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect1.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect1.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect1.az"/>

                <direct name="resulta_out" input="fp_mac_vect1.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect1.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect1.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect1.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect1.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect1.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect1.output_clk"/>
            </interconnect> 
        </mode>

        <!-- fp vector two mode -->
        <mode name="sp_vector2.input_type{reg}.output_type{comb}">
            <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect2.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect2.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect2.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect2.az"/>

                <direct name="resulta_out" input="fp_mac_vect2.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect2.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect2.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect2.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect2.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect2.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect2.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_vector2.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect2.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect2.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect2.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect2.az"/>

                <direct name="resulta_out" input="fp_mac_vect2.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect2.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect2.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>
                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect2.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect2.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect2.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect2.output_clk"/>

            </interconnect> 
        </mode>

        <mode name="sp_vector2.input_type{comb}.output_type{comb}">
            <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect2.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect2.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect2.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect2.az"/>

                <direct name="resulta_out" input="fp_mac_vect2.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect2.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect2.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect2.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect2.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect2.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect2.output_clk"/>


            </interconnect> 
        </mode>

        <mode name="sp_vector2.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="32"/>
                <input name="clr" num_pins="2"/>
                <clock name="ax_clk" num_pins="1"/>
                <clock name="ay_clk" num_pins="1"/>
                <clock name="az_clk" num_pins="1"/>
                <clock name="output_clk" num_pins="1"/>
                <input name="ax" num_pins="32"/>
                <input name="ay" num_pins="32"/>
                <input name="az" num_pins="32"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="32"/>
                <output name="resulta" num_pins="32"/>
                <output name="adder_inexact" num_pins="1"/>
                <output name="adder_invalid" num_pins="1"/>
                <output name="adder_overflow" num_pins="1"/>
                <output name="adder_underflow" num_pins="1"/>
                <output name="mult_inexact" num_pins="1"/>
                <output name="mult_invalid" num_pins="1"/>
                <output name="mult_overflow" num_pins="1"/>
                <output name="mult_underflow" num_pins="1"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="DSP.chainout[31:0]"/>
                <direct name="dft_out" input="fp_mac_vect2.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[31:0]" output="fp_mac_vect2.ax"/>
                <direct name="ay_in" input="DSP.datain[63:32]" output="fp_mac_vect2.ay"/>
                <direct name="az_in" input="DSP.datain[95:64]" output="fp_mac_vect2.az"/>

                <direct name="resulta_out" input="fp_mac_vect2.resulta" output="DSP.result[31:0]"/>
                <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="DSP.result[32]" />
                <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="DSP.result[33]" />
                <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="DSP.result[34]" />
                <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="DSP.result[35]" />
                <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="DSP.result[36]" />
                <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="DSP.result[37]" />
                <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="DSP.result[38]" />
                <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="DSP.result[39]" />

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="fp_mac_vect2.clr"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="fp_mac_vect2.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="fp_mac_vect2.ax_clk"/>
                <complete name="clk_in2" input="DSP.clk" output="fp_mac_vect2.ay_clk"/>
                <complete name="clk_in3" input="DSP.clk" output="fp_mac_vect2.az_clk"/>
                <complete name="clk_in4" input="DSP.clk" output="fp_mac_vect2.output_clk"/>

            </interconnect> 
        </mode>

    </pb_type>

  </complexblocklist>
  <switchblocklist>
    <!-- Stratix 10 uses a uni-directional routing architecture with a Driver Input Mux (DIM) size of 12 (i.e.
           each wire can be driven by one of 12 block/outputs or wires) for the L4s.
           
           In the Stratix IV architecture the long wires (L16 here) are accessible only from the short wires, 
           and are not connected to the block pins (i.e. connection blocks). Furthermore, they only connect 
           to switch blocks every 4 LABs (to avoid expensive deep via stacks).
           We approximate the L16 DIM size as 40:1 (in reality it is a pair of 20:1 (?) muxes with a 2:1 swap mux
           in front, which has nearly the same connectivity as a full 40:1).

           L4 wires
           ================
           At a channel width of 300 there are 260 L4/L4prime wires. At an effective Fc_out of 0.075 
           and 40 LAB outputs this yeilds:

                40 * 2 = 80 outputs per channel  [2 LABs per-channel]

                80 * 0.075 = 6 outputs drive each L4 wire [output connection block]

           This leaves:

                12 - 6 = 6 inputs to the DIMs from other routing wires [switch block]

           Since L4s connect at every switch block, there are:

                260 L16 wires per channel + direction which can drive wires at a particular switchblock
                (via switchpoints 0, 1, 2, 3)

           And for each direction (260 wires) only:

               260 / 4 = 65 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there are 32 L4s starting, and 32 L4s ending; + 1 wire for the 65th)

           Which we allocate as follows:

                L4
                =====
                straight-through connection: 2 (from L4 or L16)
                clock-wise turn            : 2 (from L4 or L16)
                counter-clock-wise turn    : 2 (from L4 or L16)

           L16 wires
           =========
           At a channel width of 300 there are 40 L16 wires (20 in each direction), which do not connect to the input/output connection blocks.
           This leaves 40 inputs to the DIM to select from routing wires (long wires use larger DIMs to improve reachability,
           the area cost is relatively small since they are so rare).

           Since L16s only connect at every 4th switch block there are:

                40 / 4 = 10 L16 wires per channel (5 in each direction) which can drive wires at a particular switchblock
                (via switchpoints 0, 4, 8, 12)

           And for each direction (20 wires) only:

               40 / 16 = 2.25 => 2 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there is one L16 starting, and one L16 ending)
           
           We assign the 40 DIM inputs as follows:

                L16
                =====
                straight-through connection:  3 (from L16)
                straight-through connection: 11 (from L4)
                clock-wise turn            :  3 (from L16)
                clock-wise turn            : 10 (from L4)
                counter clock-wise turn    :  3 (from L16)
                counter clock-wise turn    : 10 (from L4)

           Switch pattern
           ==============
           This switch block is based on the Wilton switch block (see Page 103 of Steve Wilton's PhD Thesis 
           "Architecture and Algorithms for Field-Programmable Gate Arrays with Embedded Memory", 1997):

                left-to-top: W - t
                top-to-right: t + 1
                right-to-bottom: 2*W - 2 - t
                bottom-to-left: t + 1
                left-to-right: t
                top-to-bottom: t

           Since Wilton assumed bidirection routing (while we use unidirectional routing),
           we mirror the clock-wise turns to match the conter-clock-wise specification.
    -->
    <!-- Short H wires have DIM of size 12
         Fan-in distribution: 
         5 of the inputs come from logic block outputs - This is modelled by setting fc_out to the right value
         1 input coming from a long wire - It is assumed that for half of the wires the input is coming from long H wires
              and for the other half it's coming from long V wires. This is implemented by making two groups of wire connections 
              with num_conn set to 0.5 * to. Since there is not a way to spe
         2 stitches - one from wire of the same type one from other short wires
         4 inputs from short V wires of different type
    -->  
    <!-- Short V wires have DIM of size 15
         Fan-in distribution: 
         6 of the inputs come from logic block outputs - This is modelled by setting fc_out to the right value
         1 input coming from a long wire - It is assumed that for half of the wires the input is coming from long H wires
              and for the other half it's coming from long V wires. This is implemented by making two groups of wire connections 
              with num_conn set to 0.5 * to. Since there is not a way to spe
         1 stitch from wire of the same type 
         7 inputs from short H wires of different types
    -->  
    <!-- Long wires have DIM of size 50
         The wires share four 12:1 muxes - since this cannot be modelled with the current switch box syntax
         it is approximated that each wire has 50 separate inputs. 
         Fan-in distribution: 
         2 stitches - one optimal and one suboptimal
         10 long wires for turns - 5 from each side 
         38 short wires - only short H wires can drive long wires   
    -->  

    <!-- Describing SB connections from vertical sides to horizontal sides in counter clockwise direction -->
    <switchblock name="wilton_turn_counter_clockwise_v2h_core" type="unidir">
      <switchblock_location type="CORE"/>
      <switchfuncs>
        <func type="tr" formula="t+1"/>
        <!-- top to right -->
        <func type="lr" formula="t"/>
        <!-- left to right -->
        <func type="br" formula="2*W-2-t"/>
        <!-- bottom to right -->
      </switchfuncs>
        
      <!--  L2 drivers -->
      <!-- The input coming from the long wires -->
      <wireconn num_conns="3*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="10*to" from_type="L4" from_switchpoint="0" to_type="L16" to_switchpoint="0"/>
      <!-- L4 drivers 

               Driving from L16 (few) to L4 (many) preferr driving from end-point of L16, although since there are many they will
               all be multiply connected.
               
               Driving from L4 (many) to L4 (many) shuffle the switchpoints so the L4's are driven from a variety of switchpoints.
               Since the actual number L4s starting/ending are equal, using 'fixed' from_order would mean only switchpoint 0 -> 0
               connections. A 'shuffled' order will mix-up the from switchpoints for more diversity.
               -->
      <wireconn num_conns="2*to" from_order="shuffled">
        <from type="L16" switchpoint="0,12,8,4"/>
        <from type="L4" switchpoint="0,1,2,3"/>
        <to type="L4" switchpoint="0"/>
      </wireconn>
    </switchblock>

  </switchblocklist>
</architecture>