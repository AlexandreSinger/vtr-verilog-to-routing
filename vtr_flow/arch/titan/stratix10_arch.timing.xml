  <models>
    <!-- LAB Primitives -->
    <model name="fourteennm_lcell_comb">
      <input_ports>
        <port name="dataa" combinational_sink_ports="combout sumout cout"/>
        <port name="datab" combinational_sink_ports="combout sumout cout"/>
        <port name="datac" combinational_sink_ports="combout sumout cout"/>
        <port name="datad" combinational_sink_ports="combout sumout cout"/>
        <port name="datae" combinational_sink_ports="combout"/>
        <port name="dataf" combinational_sink_ports="combout"/>
        <port name="datag" combinational_sink_ports="combout"/>
        <port name="datah" combinational_sink_ports="combout"/>
        <port name="cin" combinational_sink_ports="sumout cout"/>
      </input_ports>
      <output_ports>
        <port name="combout"/>
        <port name="sumout"/>
        <port name="cout"/>
      </output_ports>
    </model>
    <model name="fourteennm_ff">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="ena" clock="clk"/>
        <port name="clrn" clock="clk"/>
        <port name="sclr" clock="clk"/>
        <port name="d" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="q" clock="clk"/>
      </output_ports>
    </model>
    <model name="fourteennm_mlab_cell">
      <input_ports>
        <port name="clk0" is_clock="1"/>
        <port name="ena0" clock="clk0"/>
        <port name="clr" clock="clk0"/>
        <port name="portaaddr" clock="clk0"/>
        <port name="portabyteenamasks" clock="clk0"/>
        <port name="portadatain" clock="clk0"/>
        <port name="portbaddr" clock="clk0"/>
      </input_ports>
      <output_ports>
        <port name="portbdataout" clock="clk0"/>
      </output_ports>
    </model>
  </models>
  <tiles>
    <tile name="LAB">
      <sub_tile name="LAB">
        <equivalent_sites>
          <site pb_type="LAB" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="data_in" num_pins="80" equivalent="full"/>
        <input name="control_in" num_pins="5" equivalent="full"/>
        <input name="cin" num_pins="1" equivalent="none"/>
        <!-- Stratix 10 does have instance equivalence only for the data_out port
             where ALM outputs can be swapped to reach the most suitable pin location
             for routers. However, it may require significant changes to packing results
             which is not supported yet.
             Therefore, we assume full equivalence here, so that ALM outputs can be swapped
             through a local routing architecture without changing packing results.
             Please note that this may cause optimistic routing results, being
             better in routability than what actual hardware can support
          -->
        <output name="data_out" num_pins="40" equivalent="full"/>
        <output name="cout" num_pins="1" equivalent="none"/>
        <clock name="clk" num_pins="2"/>
        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375">
          <!-- Based on mux size info Startix 10 has approximately the following effective Fc values:
                   Fc_in: 0.055
                   Fc_out: 0.075

               However, we allow half the pins to connect to the left side, the other half to the right side
               and all pins to connect to the top side of the LAB (3-sided architecture).

               As a result we divide the effective Fc values by 2 (since each pin can connect to two sides)
               to keep roughly the same number of switches, yielding:

                    Fc_in: 0.0275
                    Fc_out: 0.0375
               -->
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
          <!-- Stratix 10 is a 3 sided architecture, the LABs can connect to routing on their
               left, top, and right.  To model this we spread the various ports around the three sides.

               The exceptions to the above are the LAB chain ports, which propogate downward between blocks.

               We model that half the pins can connect to each vertical channel (left/right),
               and all can connect to the horizontal channel (top). This models the fact that
               each block pin can connect to some Vertical and some Horizontal wires in Stratix IV.
               Note that Fc_in/Fc_out have been scaled to account for this.
             -->
          <loc side="left">  LAB.data_in[0:39]  LAB.control_in[0:3] LAB.data_out[0:19]  LAB.clk</loc>
          <loc side="right"> LAB.data_in[40:79] LAB.control_in[4:6] LAB.data_out[20:39]</loc>
          <loc side="top">   LAB.data_in        LAB.control_in      LAB.data_out        LAB.clk    LAB.cin LAB.sharein</loc>
          <loc side="bottom">LAB.cout</loc>
        </pinlocations>
      </sub_tile>
    </tile>
  </tiles>
  <complexblocklist>

    <pb_type name="PLL" num_pb="1">
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="2"/>

      <pb_type blif_model=".subckt fourteennm_iopll" name="iopll" num_pb="1">
        <input name="clkena" num_pins="2"/>
        <input name="cnt_sel" num_pins="4"/> <!-- counter selector for dynamic phase shift -->
        <!--<input name="dprio_address" num_pins="9"/>  --><!--  Avalon-MM Interface - address of the databus for dynamic partial reconfiguration -->
        <!--<input name="dprio_clk" num_pins="1"/> --> <!--  Avalon-MM Interface - clock port for dynamic partial reconfiguration -->
        <!--<input name="read" num_pins="1"/>  --><!--  Avalon-MM Interface - indicate a read operation during dynamic partial reconfiguration -->
        <!--<input name="write" num_pins="1"/>  --><!--  Avalon-MM Interface - indicate a write operation during dynamic partial reconfiguration -->
        <!--<input name="writedata" num_pins="8"/> --> <!--  Avalon-MM Interface - data to be written to the given address during dynamic partial reconfiguration -->
        <input name="core_refclk" num_pins="1"/> <!-- use core clock as an input reference clock -->
        <!--<input name="csr_clk" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface - clock signal-->
        <!--<input name="csr_en" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface - enable signal-->
        <!--<input name="csr_in" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface -->
        <!--<<input name="dprio_rst_n" num_pins="1"/>>--> <!--  Avalon-MM Interface - reset port for dynamic partial reconfiguration -->
        <input name="dps_rst_n" num_pins="1"/> <!--  dynamic phase shift reset -->
        <input name="extswitch" num_pins="1"/> <!--  controlling clock switchover -->
        <input name="fbclk_in" num_pins="1"/> <!--  feedback clock used for external feedback compensation -->
        <input name="fblvds_in" num_pins="1"/> <!--  feedback clock used for LVDS compensation -->
        <input name="refclk" num_pins="4"/> <!--  reference clock source driving the IO PLL -->
        <input name="mdio_dis" num_pins="1"/>
        <input name="rst_n" num_pins="1"/>
        <input name="num_phase_shifts" num_-pins="3"/> <!--  number of phase shifts per dynamic phase shift operation -->
        <input name="pfden" num_pins="1"/> <!--  enabling dynamic phase shift operation -->
        <!--<input name="pipeline_global_en_n" num_pins="1"/>-->
        <!--  <input name="pma_csr_test_dis" num_pins="1"/> --> <!-- disable PMA CSR test  -->
        <input name="pll_cascade_in" num_pins="1"/> <!-- cascade input from IO PLL in the same IO column  -->
        <input name="scan_mode_n" num_pins="1"/> <!-- dynamic phase shift clock -->
        <input name="scan_shift_n" num_pins="1"/>
        <!-- <input name="uc_cal_addr" num_pins="20"/>
        <input name="uc_cal_clk" num_pins="1"/>
        <input name="uc_cal_read" num_pins="1"/>
        <input name="uc_cal_write" num_pins="1"/>
        <input name="uc_cal_writedata" num_pins="8"/>  -->
        <input name="up_dn" num_pins="1"/> <!-- direction of phase shift -->
        <input name="user_mode" num_pins="1"/> <!-- enable user mode  -->
        <input name="zdb_in" num_pins="1"/> <!-- zero delay buffer compensation feedback -->

        <output name="block_select" num_pins="1"/>
        <output name="clk0_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clk1_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clksel" num_pins="1"/>
        <output name="cal_ok" num_pins="1"/> <!-- indicates the calibration status -->
        <output name="core_avl_busy" num_pins="1"/>
        <output name="core_cal_done" num_pins="1"/>
        <!--<output name="readdata" num_pins="8"/> --> <!-- Avalon-MM Interface - data read from the given address during dynamic partial reconfiguration -->
        <!--<output name="csr_out" num_pins="1"/> --> <!--Avalon-MM control-and-status register (CSR) agent interface !-->
        <output name="extclk_output" num_pins="2"/> <!-- external clock output port -->
        <output name="extclk_dft" num_pins="2"/>
        <output name="fblvds_out" num_pins="1"/>
        <output name="lf_reset" num_pins="1"/> <!-- loop filter reset -->
        <output name="loaden" num_pins="2"/> <!-- signal to the LVDS receiver -->
        <output name="lock" num_pins="1"/> <!-- indicate wether the PLL is locked - signal to the core logic -->
        <output name="lock2io12lane0" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 0 -->
        <output name="lock2io12lane1" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 1 -->
        <output name="lock2io12lane2" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 2 -->
        <output name="lock2io12lane3" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 3 -->
        <output name="lock2iohmc" num_pins="1"/> <!-- indicate wether the PLL is locked - going to Hybrid Memory Cube (HMC)-->
        <!--<output name="lvds_clk" num_pins="2"/> --> <!-- the output clk feeding the LVDS SERDES block -->
        <output name="phase_done" num_pins="1"/> <!-- indicates completion of dynamic phase shift operation -->
        <output name="pll_cascade_out" num_pins="1"/> <!-- the output from the source PLL feeding the downstream PLL in cascade mode -->
        <output name="pll_pd" num_pins="1"/> <!-- indicating power down - going to the exteral PLLs  -->
        <output name="outclk" num_pins="9"/> <!-- PLL output clocks -->
        <output name="dll_output" num_pins="1"/> <!-- going to the External Memory Interface DLL -->
        <output name="fbclk_out" num_pins="1"/> <!-- output of the M counter -->
        <output name="uc_cal_readdata" num_pins="8"/>
        <output name="vcop_en" num_pins="1"/>
        <output name="vcoph" num_pins="8"/> <!-- VCO output clocks -->
        <output name="iopll_out_sig1" num_pins="1"/>
        <output name="iopll_out_sig2" num_pins="1"/>
      </pb_type>

      <complete input="PLL.core_in" name="core_to_pll" output="iopll.clkena iopll.cnt_sel iopll.core_refclk iopll.dps_rst_n iopll.extswitch iopll.fbclk_in iopll.fblvds_in
          iopll.mdio_dis iopll.rst_n iopll.num_phase_shifts iopll.pfden iopll.pll_cascade_in iopll.scan_mode_n iopll.scan_shift_n iopll.up_dn iopll.user_mode iopll.zdb_in"/>

      <complete input="PLL.clk" name="pll_clock" output="iopll.refclk"/>

      <complete input="iopll.block_select iopll.clk0_bad iopll.clk1_bad iopll.clksel iopll.cal_ok iopll.core_avl_busy iopll.core_cal_done iopll.extclk_output
          iopll.extclk_dft iopll.fblvds_out iopll.lf_reset iopll.loaden iopll.lock iopll.lock2io12lane0 iopll.lock2io12lane1 iopll.lock2io12lane2 iopll.lock2io12lane2 iopll.lock2io12lane3
          iopll.lock2iohmc iopll.phase_done iopll.pll_cascade_out iopll.pll_pd iopll.outclk iopll.dll_output iopll.fbclk_out iopll.uc_cal_readdata iopll.vcop_en iopll.vcoph iopll.iopll_out_sig1 iopll.iopll_out_sig2" name="pll_to_core" output="PLL.core_out"/>
    </pb_type>

    <pb_type name="LAB">
      <input name="data_in" num_pins="80" equivalent="full"/>
      <input name="control_in" num_pins="5" equivalent="none"/>
      <input name="cin" num_pins="1" equivalent="none"/>
      <output name="data_out" num_pins="40" equivalent="full"/>
      <output name="cout" num_pins="1" equivalent="none"/>
      <clock name="clk" num_pins="1"/>
      <mode name="LAB">
        <pb_type name="alm" num_pb="10">
          <input name="data_in" num_pins="8"/>
          <input name="control" num_pins="5"/>
          <input name="cin" num_pins="1"/>
          <output name="data_out" num_pins="4"/>
          <output name="cout" num_pins="1"/>
          <clock name="clock" num_pins="1"/>
          <mode name="alm">
            <pb_type name="comb_block" num_pb="1">
              <input name="lin" num_pins="8"/>
              <input name="cin" num_pins="1"/>
              <output name="combout" num_pins="2"/>
              <output name="sumout" num_pins="2"/>
              <output name="cout" num_pins="1"/>
              <mode name="comb_block">
                <pb_type name="lut" num_pb="2">
                  <input name="lin" num_pins="8"/>
                  <input name="cin" num_pins="1"/>
                  <output name="combout" num_pins="1"/>
                  <output name="sumout" num_pins="1"/>
                  <output name="cout" num_pins="1"/>
                  <mode name="fourteennm_lcell">
                    <pb_type blif_model=".subckt fourteennm_lcell_comb" name="lcell_comb" num_pb="1">
                      <input name="dataa" num_pins="1"/>
                      <input name="datab" num_pins="1"/>
                      <input name="datac" num_pins="1"/>
                      <input name="datad" num_pins="1"/>
                      <input name="datae" num_pins="1"/>
                      <input name="dataf" num_pins="1"/>
                      <input name="datag" num_pins="1"/>
                      <input name="datah" num_pins="1"/>
                      <input name="cin" num_pins="1"/>
                      <output name="combout" num_pins="1"/>
                      <output name="sumout" num_pins="1"/>
                      <output name="cout" num_pins="1"/>
                    </pb_type>
                    <interconnect>
                      <!-- LUT inputs -->
                      <direct input="lut.lin[0]" name="in_comp1" output="lcell_comb.dataa"/>
                      <direct input="lut.lin[1]" name="in_comp2" output="lcell_comb.datab"/>
                      <direct input="lut.lin[2]" name="in_comp3" output="lcell_comb.datac"/>
                      <direct input="lut.lin[3]" name="in_comp4" output="lcell_comb.datad"/>
                      <direct input="lut.lin[4]" name="in_comp5" output="lcell_comb.datae"/>
                      <direct input="lut.lin[5]" name="in_comp6" output="lcell_comb.dataf"/>
                      <direct input="lut.lin[6]" name="in_comp7" output="lcell_comb.datag"/>
                      <direct input="lut.lin[7]" name="in_comp8" output="lcell_comb.datah"/>
                      <!-- LUT outputs -->
                      <direct input="lcell_comb.combout" name="out_comp1" output="lut.combout"/>
                      <direct input="lcell_comb.sumout" name="out_comp2" output="lut.sumout"/>
                      <!-- LUT carry chain -->
                      <direct input="lut.cin" name="lut_cin" output="lcell_comb.cin">
                        <pack_pattern name="LAB_carry_chain" in_port="lut.cin" out_port="lcell_comb.cin"/>
                      </direct>
                      <direct input="lcell_comb.cout" name="out_comp3" output="lut.cout">
                        <pack_pattern name="LAB_carry_chain" in_port="lcell_comb.cout" out_port="lut.cout"/>
                      </direct>
                    </interconnect>
                  </mode>
                  <mode name="names_lut">
                    <pb_type blif_model=".names" class="lut" name="lut6" num_pb="1">
                      <input name="in" num_pins="6" port_class="lut_in"/>
                      <output name="out" num_pins="1" port_class="lut_out"/>
                    </pb_type>


                    <interconnect>
                      <complete input="lut.lin" name="l_complete1" output="lut6.in[5:0]"/>
                      <complete input="lut6.out" name="l_complete2" output="lut.sumout lut.combout"/>
                    </interconnect>
                  </mode>
                </pb_type>

                <interconnect>
                  <!-- Inputs to the LUTs -->
                  <complete input="comb_block.lin" name="in_lut0" output="lut[0].lin"/>
                  <complete input="comb_block.lin" name="in_lut1" output="lut[1].lin"/>
                  <!-- Combinational Block Carry Chain -->
                  <direct input="comb_block.cin" name="comb_block_cin" output="lut[0].cin">
                    <pack_pattern name="LAB_carry_chain" in_port="comb_block.cin" out_port="lut[0].cin"/>
                  </direct>
                  <direct input="lut[0].cout" name="lut_to_lut_carry" output="lut[1].cin">
                    <pack_pattern name="LAB_carry_chain" in_port="lut[0].cout" out_port="lut[1].cin"/>
                  </direct>
                  <direct input="lut[1].cout" name="alm_cout" output="comb_block.cout">
                    <pack_pattern name="LAB_carry_chain" in_port="lut[1].cout" out_port="comb_block.cout"/>
                  </direct>
                  <!-- Outputs to the Combinational Block -->
                  <direct input="lut[0].combout" name="lut0_comb" output=" comb_block.combout[0]"/>
                  <direct input="lut[1].combout" name="lut1_comb" output=" comb_block.combout[1]"/>
                  <direct input="lut[0].sumout" name="lut0_sum" output=" comb_block.sumout[0]"/>
                  <direct input="lut[1].sumout" name="lut1_sum" output=" comb_block.sumout[1]"/>

                </interconnect>              
              </mode>
            </pb_type>
            <pb_type name="dff" num_pb="4">
              <input name="clrn" num_pins="1"/>
              <input name="sclr" num_pins="1"/>
              <input name="ena" num_pins="1"/>
              <input name="d" num_pins="1"/>
              <output name="q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="stratix10_ff">
                <pb_type blif_model=".subckt fourteennm_ff" name="fourteennm_ff" num_pb="1">
                  <input name="clrn" num_pins="1"/>
                  <input name="sclr" num_pins="1"/>
                  <input name="ena" num_pins="1"/>
                  <input name="d" num_pins="1"/>
                  <output name="q" num_pins="1"/>
                  <clock name="clk" num_pins="1"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.clrn" name="fourteennm_ff_clrn" output="fourteennm_ff.clrn"/>
                  <direct input="dff.sclr" name="fourteennm_ff_sclr" output="fourteennm_ff.sclr"/>
                  <direct input="dff.ena" name="fourteennm_ff_ena" output="fourteennm_ff.ena"/>
                  <direct input="dff.d" name="fourteennm_ff_d" output="fourteennm_ff.d"/>
                  <direct input="fourteennm_ff.q" name="fourteennm_ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="fourteennm_ff_clk" output="fourteennm_ff.clk"/>
                </interconnect>
              </mode>
               <mode name="latch">
                <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.d" name="ff_d" output="ff.D"/>
                  <direct input="ff.Q" name="ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="ff_clk" output="ff.clk"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <!-- Inputs to LUTs -->
              <direct input="alm.data_in[2:7]" name="in_lut_2_7" output="comb_block.lin[2:7]"/>
              <mux input="alm.data_in[0] comb_block.sumout[0] dff[0].q" name="in_lut_0" output="comb_block.lin[0]"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1] dff[2].q" name="in_lut_1" output="comb_block.lin[1]"/>

              <!-- Inputs to FFs -->
              <mux input="alm.data_in[0] comb_block.sumout[0]" name="in_dff_0" output="dff[0].d"/>
              <direct input="comb_block.combout[0]" name="in_dff_1" output="dff[1].d"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1]" name="in_dff_2" output="dff[2].d"/>
              <direct input="comb_block.combout[1]" name="in_dff_3" output="dff[3].d"/>

              <!-- ALM Outputs-->
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out0" output="alm.data_out[0]"/>
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out1" output="alm.data_out[1]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out2" output="alm.data_out[2]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out3" output="alm.data_out[3]"/>

              <!-- FF Clocks -->
              <direct input="alm.clock" name="clock_dff0" output="dff[0].clk"/>
              <direct input="alm.clock" name="clock_dff1" output="dff[1].clk"/>

              <!-- ALM Carry Chain -->
              <direct input="alm.cin" name="alm_cin" output="comb_block.cin">
                <pack_pattern name="LAB_carry_chain" in_port="alm.cin" out_port="comb_block.cin"/>
              </direct>

              <direct input="comb_block.cout" name="alm_cout" output="alm.cout">
                <pack_pattern name="LAB_carry_chain" in_port="comb_block.cout" out_port="alm.cout"/>
              </direct>

              <!-- FF Control Signals -->

              <!--
                Here is how the alm control signals correspond to the lab wide control signals listed in Stratix 10 LAB user guide:

                synclr0 -> alm.control[0]
                labclkena0 -> alm.control[1]
                labclkena1 -> alm.control[2]
                synclr1 -> alm.control[3]
                labclr1 -> alm.control[4]
              -->
              <direct input="alm.control[4]" name="control_1_dff0" output="dff[0].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff0" output="dff[0].ena"/>
              <direct input="alm.control[3]" name="control_3_dff0" output="dff[0].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff1" output="dff[1].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff1" output="dff[1].ena"/>
              <direct input="alm.control[3]" name="control_3_dff1" output="dff[1].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff2" output="dff[2].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff2" output="dff[2].ena"/>
              <direct input="alm.control[0]" name="control_3_dff2" output="dff[2].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff3" output="dff[3].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff3" output="dff[3].ena"/>
              <direct input="alm.control[0]" name="control_3_dff3" output="dff[3].sclr"/>
            </interconnect>
          </mode>
        </pb_type>
        <interconnect>
          <!--LAB-ALM Interconnect-->
          <!-- LAB Input: Global Routing to ALM inputs -->
          <complete input="LAB.data_in" name="LAB_datain" output="alm[9:0].data_in"/>

          <!-- ALM feedback: The ALM outputs feedback to the ALM inputs  -->
          <complete input="alm[9:0].data_out[0] alm[9:0].data_out[3]" name="LAB_alm_feedback" output="alm[9:0].data_in"/>

          <!-- ALM Outputs: directly drive global routing -->
          <complete input="alm[9:0].data_out[1] alm[9:0].data_out[2]" name="LAB_dataout" output="LAB.data_out"/>

          <!-- ALM Control Inputs -->
           <complete input="LAB.control_in" name="LAB_control" output="alm[9:0].control"/>

          <!-- LAB Clocks -->
          <direct input="LAB.clk" name="LAB_clock" output="alm[0].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[1].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[2].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[3].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[4].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[5].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[6].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[7].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[8].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[9].clock"/>

          <!--LAB carry chain-->
          <direct input="LAB.cin" name="LAB_cin" output="alm[0].cin">
            <pack_pattern name="LAB_carry_chain" in_port="LAB.cin" out_port="alm[0].cin"/>
          </direct>
          <direct input="alm[0].cout" name="alm0_alm1_carry" output="alm[1].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[0].cout" out_port="alm[1].cin"/>
          </direct>
          <direct input="alm[1].cout" name="alm1_alm2_carry" output="alm[2].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[1].cout" out_port="alm[2].cin"/>
          </direct>
          <direct input="alm[2].cout" name="alm2_alm3_carry" output="alm[3].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[2].cout" out_port="alm[3].cin"/>
          </direct>
          <direct input="alm[3].cout" name="alm3_alm4_carry" output="alm[4].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[3].cout" out_port="alm[4].cin"/>
          </direct>
          <direct input="alm[4].cout" name="alm4_alm5_carry" output="alm[5].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[4].cout" out_port="alm[5].cin"/>
          </direct>
          <direct input="alm[5].cout" name="alm5_alm6_carry" output="alm[6].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[5].cout" out_port="alm[6].cin"/>
          </direct>
          <direct input="alm[6].cout" name="alm6_alm7_carry" output="alm[7].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[6].cout" out_port="alm[7].cin"/>
          </direct>
          <direct input="alm[7].cout" name="alm7_alm8_carry" output="alm[8].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[7].cout" out_port="alm[8].cin"/>
          </direct>
          <direct input="alm[8].cout" name="alm8_alm9_carry" output="alm[9].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[8].cout" out_port="alm[9].cin"/>
          </direct>
          <direct input="alm[9].cout" name="LAB_cout" output="LAB.cout">
            <pack_pattern name="LAB_carry_chain" in_port="alm[9].cout" out_port="LAB.cout"/>
          </direct>

        </interconnect>
      </mode>
      <mode name="MLAB">

        <pb_type name="MLAB" num_pb="1">
          <clock name="clk0" num_pins="1"/>
          <input name="ena0" num_pins="1"/>
          <input name="clr" num_pins="1"/>
          <input name="portaaddr" num_pins="5"/>
          <input name="portabyteenamasks" num_pins="20"/>
          <input name="portadatain" num_pins="20"/>
          <input name="portbaddr" num_pins="5"/>
          <output name="portbdataout" num_pins="20"/>
          <mode name="mlab_cell">
          <pb_type blif_model=".subckt fourteennm_mlab_cell" name="mlab_cell" num_pb="10">
            <input name="ena0" num_pins="1"/>
            <clock name="clk0" num_pins="1"/>
            <input name="clr" num_pins="1"/>
            <input name="portaaddr" num_pins="5"/>
            <input name="portabyteenamasks" num_pins="2"/>
            <input name="portadatain" num_pins="2"/>
            <input name="portbaddr" num_pins="5"/>
            <output name="portbdataout" num_pins="2"/>
                  <T_setup value="66e-12" port="mlab_cell.ena0" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="mlab_cell.portbdataout" clock="clk0"/>

          </pb_type>
          <interconnect>
              <!-- Enable Input: From MLAB block to MLAB cells enable input -->
              <direct input="MLAB.ena0" name="ena0" output="mlab_cell[0].ena0"/>
              <direct input="MLAB.ena0" name="ena1" output="mlab_cell[1].ena0"/>
              <direct input="MLAB.ena0" name="ena2" output="mlab_cell[2].ena0"/>
              <direct input="MLAB.ena0" name="ena3" output="mlab_cell[3].ena0"/>
              <direct input="MLAB.ena0" name="ena4" output="mlab_cell[4].ena0"/>
              <direct input="MLAB.ena0" name="ena5" output="mlab_cell[5].ena0"/>
              <direct input="MLAB.ena0" name="ena6" output="mlab_cell[6].ena0"/>
              <direct input="MLAB.ena0" name="ena7" output="mlab_cell[7].ena0"/>
              <direct input="MLAB.ena0" name="ena8" output="mlab_cell[8].ena0"/>
              <direct input="MLAB.ena0" name="ena9" output="mlab_cell[9].ena0"/>

              <!-- Clear Input: From MLAB block to MLAB cells clear input -->
              <direct input="MLAB.clr" name="clr0" output="mlab_cell[0].clr"/>
              <direct input="MLAB.clr" name="clr1" output="mlab_cell[1].clr"/>
              <direct input="MLAB.clr" name="clr2" output="mlab_cell[2].clr"/>
              <direct input="MLAB.clr" name="clr3" output="mlab_cell[3].clr"/>
              <direct input="MLAB.clr" name="clr4" output="mlab_cell[4].clr"/>
              <direct input="MLAB.clr" name="clr5" output="mlab_cell[5].clr"/>
              <direct input="MLAB.clr" name="clr6" output="mlab_cell[6].clr"/>
              <direct input="MLAB.clr" name="clr7" output="mlab_cell[7].clr"/>
              <direct input="MLAB.clr" name="clr8" output="mlab_cell[8].clr"/>
              <direct input="MLAB.clr" name="clr9" output="mlab_cell[9].clr"/>

              <!-- Write Address: Input write address to the MLAB cells -->
              <direct input="MLAB.portaaddr" name="portaaddr0" output="mlab_cell[0].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr1" output="mlab_cell[1].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr2" output="mlab_cell[2].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr3" output="mlab_cell[3].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr4" output="mlab_cell[4].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr5" output="mlab_cell[5].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr6" output="mlab_cell[6].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr7" output="mlab_cell[7].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr8" output="mlab_cell[8].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr9" output="mlab_cell[9].portaaddr"/>

              <!-- Byte Enable Mask: Input byte enable mask to the MLAB cells -->
              <direct input="MLAB.portabyteenamasks[1:0]" name="portabytenamasks0" output="mlab_cell[0].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[3:2]" name="portabytenamasks1" output="mlab_cell[1].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[5:4]" name="portabytenamasks2" output="mlab_cell[2].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[7:6]" name="portabytenamasks3" output="mlab_cell[3].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[9:8]" name="portabytenamasks4" output="mlab_cell[4].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[11:10]" name="portabytenamasks5" output="mlab_cell[5].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[13:12]" name="portabytenamasks6" output="mlab_cell[6].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[15:14]" name="portabytenamasks7" output="mlab_cell[7].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[17:16]" name="portabytenamasks8" output="mlab_cell[8].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[19:18]" name="portabytenamasks9" output="mlab_cell[9].portabyteenamasks"/>

              <!-- Write Data: Input data to the MLAB cells -->
              <direct input="MLAB.portadatain[1:0]" name="portadatain0" output="mlab_cell[0].portadatain"/>
              <direct input="MLAB.portadatain[3:2]" name="portadatain1" output="mlab_cell[1].portadatain"/>
              <direct input="MLAB.portadatain[5:4]" name="portadatain2" output="mlab_cell[2].portadatain"/>
              <direct input="MLAB.portadatain[7:6]" name="portadatain3" output="mlab_cell[3].portadatain"/>
              <direct input="MLAB.portadatain[9:8]" name="portadatain4" output="mlab_cell[4].portadatain"/>
              <direct input="MLAB.portadatain[11:10]" name="portadatain5" output="mlab_cell[5].portadatain"/>
              <direct input="MLAB.portadatain[13:12]" name="portadatain6" output="mlab_cell[6].portadatain"/>
              <direct input="MLAB.portadatain[15:14]" name="portadatain7" output="mlab_cell[7].portadatain"/>
              <direct input="MLAB.portadatain[17:16]" name="portadatain8" output="mlab_cell[8].portadatain"/>
              <direct input="MLAB.portadatain[19:18]" name="portadatain9" output="mlab_cell[9].portadatain"/>

              <!-- Read Address: Input read address to the MLAB cells -->
              <direct input="MLAB.portbaddr" name="portbaddr0" output="mlab_cell[0].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr1" output="mlab_cell[1].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr2" output="mlab_cell[2].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr3" output="mlab_cell[3].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr4" output="mlab_cell[4].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr5" output="mlab_cell[5].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr6" output="mlab_cell[6].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr7" output="mlab_cell[7].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr8" output="mlab_cell[8].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr9" output="mlab_cell[9].portbaddr"/>

              <!-- Read data: Output data from MLAB cells to the MLAB output -->
              <direct input="mlab_cell[0].portbdataout" name="portbdataout0" output="MLAB.portbdataout[1:0]"/>
              <direct input="mlab_cell[1].portbdataout" name="portbdataout1" output="MLAB.portbdataout[3:2]"/>
              <direct input="mlab_cell[2].portbdataout" name="portbdataout2" output="MLAB.portbdataout[5:4]"/>
              <direct input="mlab_cell[3].portbdataout" name="portbdataout3" output="MLAB.portbdataout[7:6]"/>
              <direct input="mlab_cell[4].portbdataout" name="portbdataout4" output="MLAB.portbdataout[9:8]"/>
              <direct input="mlab_cell[5].portbdataout" name="portbdataout5" output="MLAB.portbdataout[11:10]"/>
              <direct input="mlab_cell[6].portbdataout" name="portbdataout6" output="MLAB.portbdataout[13:12]"/>
              <direct input="mlab_cell[7].portbdataout" name="portbdataout7" output="MLAB.portbdataout[15:14]"/>
              <direct input="mlab_cell[8].portbdataout" name="portbdataout8" output="MLAB.portbdataout[17:16]"/>
              <direct input="mlab_cell[9].portbdataout" name="portbdataout9" output="MLAB.portbdataout[19:18]"/>

              <!-- MLAB cell clocks -->
              <direct input="MLAB.clk0" name="clk0" output="mlab_cell[0].clk0"/>
              <direct input="MLAB.clk0" name="clk1" output="mlab_cell[1].clk0"/>
              <direct input="MLAB.clk0" name="clk2" output="mlab_cell[2].clk0"/>
              <direct input="MLAB.clk0" name="clk3" output="mlab_cell[3].clk0"/>
              <direct input="MLAB.clk0" name="clk4" output="mlab_cell[4].clk0"/>
              <direct input="MLAB.clk0" name="clk5" output="mlab_cell[5].clk0"/>
              <direct input="MLAB.clk0" name="clk6" output="mlab_cell[6].clk0"/>
              <direct input="MLAB.clk0" name="clk7" output="mlab_cell[7].clk0"/>
              <direct input="MLAB.clk0" name="clk8" output="mlab_cell[8].clk0"/>
              <direct input="MLAB.clk0" name="clk9" output="mlab_cell[9].clk0"/>
            </interconnect>
        </mode>
        </pb_type>
        <interconnect>
          <complete input="LAB.clk" name="mlab_clk" output="MLAB.clk0"/>
          <complete input="LAB.data_in" name="mlab_in1" output="MLAB.ena0"/>
          <complete input="LAB.data_in" name="mlab_in2" output="MLAB.clr"/>
          <complete input="LAB.data_in" name="mlab_in3" output="MLAB.portaaddr"/>
          <complete input="LAB.data_in" name="mlab_in4" output="MLAB.portabyteenamasks"/>
          <complete input="LAB.data_in" name="mlab_in5" output="MLAB.portadatain"/>
          <complete input="LAB.data_in" name="mlab_in6" output="MLAB.portbaddr"/>
          <complete input="MLAB.portbdataout" name="mlab_out" output="LAB.data_out"/>
        </interconnect>
      </mode>
    </pb_type>

  </complexblocklist>
