<architecture>
  <models>

    <!-- LAB Primitives -->
    <model name="fourteennm_lcell_comb">
      <input_ports>
        <port name="dataa" combinational_sink_ports="combout sumout cout"/>
        <port name="datab" combinational_sink_ports="combout sumout cout"/>
        <port name="datac" combinational_sink_ports="combout sumout cout"/>
        <port name="datad" combinational_sink_ports="combout sumout cout"/>
        <port name="datae" combinational_sink_ports="combout"/>
        <port name="dataf" combinational_sink_ports="combout"/>
        <port name="datag" combinational_sink_ports="combout"/>
        <port name="datah" combinational_sink_ports="combout"/>
        <port name="cin" combinational_sink_ports="sumout cout"/>
      </input_ports>
      <output_ports>
        <port name="combout"/>
        <port name="sumout"/>
        <port name="cout"/>
      </output_ports>
    </model>

    <model name="fourteennm_ff">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="ena" clock="clk"/>
        <port name="clrn" clock="clk"/>
        <port name="sclr" clock="clk"/>
        <port name="d" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="q" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mlab_cell">
      <input_ports>
        <port name="clk0" is_clock="1"/>
        <port name="ena0" clock="clk0"/>
        <port name="clr" clock="clk0"/>
        <port name="portaaddr" clock="clk0"/>
        <port name="portabyteenamasks" clock="clk0"/>
        <port name="portadatain" clock="clk0"/>
        <port name="portbaddr" clock="clk0"/>
      </input_ports>
      <output_ports>
        <port name="portbdataout" clock="clk0"/>
      </output_ports>
    </model>

    <!-- OCT Primitives -->
    <model name="fourteennm_termination">
      <input_ports>
        <port name="rzqin" clock="clkusr"/> 
        <port name="enserusr" clock="clkusr"/> 
        <port name="nclrusr" clock="clkusr"/>
        <port name="clkenusr" clock="clkusr"/>
        <port name="clkusr" is_clock="1"/>
        <port name="ser_data_dq_from_core" clock="clkusr"/>
        <port name="ser_data_ca_from_core" clock="clkusr"/>
        <port name="test_clkusr_en_n" clock="clkusr"/>
        <port name="oct_scanin" clock="clkusr"/>
      </input_ports>
      <output_ports>
        <port name="clkusr_dft_out" clock="clkusr"/>
        <port name="oct_scanout" clock="clkusr"/>
        <port name="compout_rdn" clock="clkusr"/>
        <port name="compout_rup" clock="clkusr"/>
        <port name="serdataout" clock="clkusr"/>
        <port name="ser_data_dq_to_core" clock="clkusr"/>
        <port name="ser_data_ca_to_core" clock="clkusr"/>
      </output_ports>
    </model>

    <model name="fourteennm_termination_logic">
      <input_ports>
        <port name="s2pload" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="serdata" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_shift_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
      </input_ports>
      <output_ports>
        <port name="scan_out" />
        <port name="seriesterminationcontrol" />
        <port name="parallelterminationcontrol" />
      </output_ports>
    </model>

    <!-- PLL Primitive -->
    <model name="fourteennm_iopll">
      <input_ports>
        <port name="clken" clock="core_refclk"/>
        <port name="cnt_sel" clock="core_refclk"/> 
        <port name="core_refclk" is_clock="1"/> 
        <port name="dps_rst_n" clock="core_refclk"/> 
        <port name="extswitch" clock="core_refclk"/> 
        <port name="fbclk_in" clock="core_refclk"/> 
        <port name="fblvds_in" clock="core_refclk"/> 
        <port name="refclk" clock="core_refclk"/> 
        <port name="mdio_dis" clock="core_refclk"/>
        <port name="rst_n" clock="core_refclk"/>
        <port name="num_phase_shifts" clock="core_refclk"/> 
        <port name="pfden" clock="core_refclk"/> 
        <port name="pll_cascade_in" clock="core_refclk"/> 
        <port name="scan_mode_n" clock="core_refclk"/> 
        <port name="scan_shift_n" clock="core_refclk"/>
        <port name="csr_clk" clock="core_refclk"/>
        <port name="csr_en" clock="core_refclk"/>
        <port name="phase_en" clock="core_refclk"/>
        <port name="csr_in" clock="core_refclk"/>
        <port name="uc_cal_addr" clock="core_refclk"/>
        <port name="uc_cal_clk" clock="core_refclk"/>
        <port name="uc_cal_read" clock="core_refclk"/>
        <port name="uc_cal_write" clock="core_refclk"/>
        <port name="uc_cal_writedata" clock="core_refclk"/>  
        <port name="up_dn" clock="core_refclk"/> 
        <port name="user_mode" clock="core_refclk"/> 
        <port name="zdb_in" clock="core_refclk"/> 
        <port name="dprio_address" clock="core_refclk"/>                                 
        <port name="dprio_clk" clock="core_refclk"/>                                 
        <port name="read" clock="core_refclk"/>   
        <port name="write" clock="core_refclk"/> 
        <port name="writedata" clock="core_refclk"/> 
        <port name="dprio_rst_n" clock="core_refclk"/>                                 
        <port name="pipeline_global_en_n" clock="core_refclk"/>
        <port name="pma_csr_test_dis" clock="core_refclk"/>
      </input_ports>
      <output_ports>
        <port name="block_select" clock="core_refclk"/>
        <port name="clk0_bad" clock="core_refclk"/> 
        <port name="clk1_bad" clock="core_refclk"/> 
        <port name="clksel" clock="core_refclk"/>
        <port name="cal_ok" clock="core_refclk"/> 
        <port name="core_avl_busy" clock="core_refclk"/>
        <port name="core_cal_done" clock="core_refclk"/>
        <port name="extclk_output" clock="core_refclk"/> 
        <port name="extclk_dft" clock="core_refclk"/>
        <port name="fblvds_out" clock="core_refclk"/>
        <port name="lf_reset" clock="core_refclk"/> 
        <port name="loaden" clock="core_refclk"/> 
        <port name="lock" clock="core_refclk"/> 
        <port name="lock2io12lane0" clock="core_refclk"/> 
        <port name="lock2io12lane1" clock="core_refclk"/> 
        <port name="lock2io12lane2" clock="core_refclk"/> 
        <port name="lock2io12lane3" clock="core_refclk"/> 
        <port name="lock2iohmc" clock="core_refclk"/> 
        <port name="phase_done" clock="core_refclk"/> 
        <port name="pll_cascade_out" clock="core_refclk"/> 
        <port name="pll_pd" clock="core_refclk"/> 
        <port name="outclk" clock="core_refclk"/> 
        <port name="dll_output" clock="core_refclk"/> 
        <port name="fbclk_out" clock="core_refclk"/> 
        <port name="uc_cal_readdata" clock="core_refclk"/>
        <port name="vcop_en" clock="core_refclk"/>
        <port name="vcoph" clock="core_refclk"/> 
        <port name="iopll_out_sig1" clock="core_refclk"/>
        <port name="iopll_out_sig2" clock="core_refclk"/>
        <port name="readdata" clock="core_refclk"/>
        <port name="lvds_clk" clock="core_refclk"/>
        <port name="csr_out" clock="core_refclk"/>
      </output_ports>
    </model>

    <!-- Clock divider Primitive -->
    <model name="fourteennm_clk_divider">
      <input_ports>
        <port name="inclk" is_clock="1"/> 
      </input_ports>
      <output_ports>
        <port name="clock_div1" clock="inclk"/>
        <port name="clock_div2" clock="inclk"/> 
        <port name="clock_div4" clock="inclk"/> 
      </output_ports>
    </model>

    <!-- Clock gate Primitive -->
    <model name="fourteennm_clk_gate">
      <input_ports>
        <port name="inclk" is_clock="1"/> 
        <port name="enable" clock="inclk"/> 
      </input_ports>
      <output_ports>
        <port name="outclk" clock="inclk"/>
      </output_ports>
    </model>
    <!-- IO Primitives -->
    <model name="fourteennm_io_obuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar"/> 
        <port name="oe" combinational_sink_ports="o obar"/> 
        <port name="dynamicterminationcontrol" combinational_sink_ports="o obar"/> 
        <port name="seriesterminationcontrol" combinational_sink_ports="o obar"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o obar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
      </output_ports>
    </model>

    <model name="fourteennm_io_ibuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o"/>
        <port name="ibar" combinational_sink_ports="o"/>
        <port name="dynamicterminationcontrol" combinational_sink_ports="o"/>
        <port name="seriesterminationcontrol" combinational_sink_ports="o"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o"/>
      </input_ports>
      <output_ports>
        <port name="o" />
      </output_ports>
    </model>

    <model name="fourteennm_pseudo_diff_out">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="ibar" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oein" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oebin"  combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcbarin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
        <port name="oeout" />
        <port name="oebout" />
        <port name="dtc" />
        <port name="dtcbar" />
      </output_ports>
    </model>

    <model name="fourteennm_ddio_out">
      <input_ports>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <port name="clk" is_clock="1"/>
        <port name="clkhi" clock="clk"/>
        <port name="clklo" clock="clk"/>
        <port name="muxsel" clock="clk"/>
        <port name="datainlo" clock="clk"/>
        <port name="datainhi" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="dataout" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_ddio_in">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="clkn" clock="clk"/>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <port name="datain" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="regoutlo" clock="clk"/>
        <port name="regouthi" clock="clk"/>
      </output_ports>
    </model>

    <!-- DSP Primitives -->

    <!-- independent multiplier mode -->
    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1" />
        <port name="negate_clk" is_clock="1"/>
        <port name="clr" clock="ay_scan_in_clk"/>
        <port name="sub" clock="sub_clk" combinational_sink_ports="resulta"/>
        <port name="negate" clock="negate_clk" combinational_sink_ports="resulta"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resultb"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resultb scanout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resultb"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resultb"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta resultb scanout"/>
        <port name="ena" clock="ay_scan_in_clk"/>
        <port name="dfxlfsrena" clock="ay_scan_in_clk"/>
        <port name="dfxmisrena" clock="ay_scan_in_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" />
        <port name="resultb" />
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub" combinational_sink_ports="resulta"/>
        <port name="negate" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta scanout"/>
        <port name="az" combinational_sink_ports="resulta"/>
        <port name="coefsela" combinational_sink_ports="resulta"/>
        <port name="bx" combinational_sink_ports="resultb"/>
        <port name="by" combinational_sink_ports="resultb scanout"/>
        <port name="bz" combinational_sink_ports="resultb"/>
        <port name="coefselb" combinational_sink_ports="resultb"/>
        <port name="scanin" combinational_sink_ports="resulta resultb scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" clock="output_clk"/>
        <port name="resultb" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub" combinational_sink_ports="resulta"/>
        <port name="negate" combinational_sink_ports="resulta"/>
        <port name="clr" combinational_sink_ports="resulta resultb"/>
        <port name="ax" combinational_sink_ports="resulta dftout"/>
        <port name="ay" combinational_sink_ports="resulta scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta dftout"/>
        <port name="bx" combinational_sink_ports="resultb dftout"/>
        <port name="by" combinational_sink_ports="resultb scanout dftout"/>
        <port name="bz" combinational_sink_ports="resultb dftout"/>
        <port name="coefselb" combinational_sink_ports="resultb dftout"/>
        <port name="scanin" combinational_sink_ports="resulta resultb scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta resultb dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta resultb dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta resultb dftout"/>
      </input_ports>
      <output_ports>
        <port name="resulta"/>
        <port name="resultb"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports>    
    </model>

    <model name="fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="clr" clock="ay_scan_in_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub" clock="sub_clk" combinational_sink_ports="resulta"/>
        <port name="negate" clock="negate_clk" combinational_sink_ports="resulta"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resultb"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resultb"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resultb"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resultb"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta resultb"/>
        <port name="ena" clock="ay_scan_in_clk"/>
        <port name="dfxlfsrena" clock="ay_scan_in_clk"/>
        <port name="dfxmisrena" clock="ay_scan_in_clk"/>
      </input_ports>
      <output_ports>
        <port name="resulta" clock="output_clk"/>
        <port name="resultb" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>    
    </model>

    <!-- multiplier adder sum mode -->
    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="by_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout dftout"/>
        <port name="clr" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ax" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout dftout"/>
        <port name="bx" combinational_sink_ports="resulta chainout dftout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="bz" combinational_sink_ports="resulta chainout dftout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="sub" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout dftout"/>
      </input_ports>
      <output_ports>
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports>
      <output_ports>
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!--  18x19 multiplication summed with 36-bit input -->

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{comb}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{comb}">
      <input_ports> 
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout dftout"/>
        <port name="bx" combinational_sink_ports="resulta chainout dftout"/>
        <port name="by" combinational_sink_ports="resulta chainout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout dftout"/>
        <port name="sub" combinational_sink_ports="resulta chainout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- systolic fir mode -->  
    <model name="fourteennm_mac.opmode{m18x18_systolic}.input_type{comb}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="output_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="bx" combinational_sink_ports="resulta chainout"/>
        <port name="by" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="output_clk"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_systolic}.input_type{reg}.output_type{reg}">
      <input_ports> 
        <port name="accumulate" clock="accumulate_clk"/>
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="by_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="bx_clk" is_clock="1"/>
        <port name="by_clk" is_clock="1"/>
        <port name="bz_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="coef_sel_b_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="bx" clock="bx_clk" combinational_sink_ports="resulta chainout"/>
        <port name="by" clock="by_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="bz" clock="bz_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefselb" clock="coef_sel_b_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" clock="sub_clk"/>
        <port name="ena" clock="by_clk"/>
        <port name="dfxlfsrena" clock="by_clk"/>
        <port name="dfxmisrena" clock="by_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="by_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- 27x27 independent multiplier -->
    <model name="fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{comb}">
      <input_ports>       
        <port name="accumulate" clock="accumulate_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1" />
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="sub" clock="sub_clk" combinational_sink_ports="resulta"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk" combinational_sink_ports="resulta chainout"/>
        <port name="negate" clock="negate_clk" combinational_sink_ports="resulta chainout"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>     
    <model name="fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{reg}">
      <input_ports>       
        <port name="accumulate" clock="output_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout"/>
        <port name="negate" combinational_sink_ports="resulta chainout"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout"/>
        <port name="sub" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" />
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>
    <model name="fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{comb}">
      <input_ports>       
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="chainin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="clr" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ax" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="loadconst" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="negate" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="sub" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout scanout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout scanout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports> 
    </model>
    <model name="fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{reg}">
      <input_ports>       
        <port name="accumulate" clock="accumulate_clk" />
        <port name="chainin" combinational_sink_ports="resulta chainout"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="loadconst_clk" is_clock="1"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainout_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta chainout"/>
        <port name="loadconst" clock="loadconst_clk" combinational_sink_ports="resulta chainout"/>
        <port name="negate" clock="negate_clk" combinational_sink_ports="resulta chainout"/>
        <port name="sub" clock="sub_clk" combinational_sink_ports="resulta chainout"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta chainout scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="chainout_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- single 18x18 multiplier mode -->
    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{comb}">
      <input_ports>       
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{reg}">
      <input_ports>       
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta scanout"/>
        <port name="az" combinational_sink_ports="resulta"/>
        <port name="coefsela" combinational_sink_ports="resulta"/>
        <port name="scanin" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="output_clk"/>
        <port name="sub" clock="output_clk"/>
        <port name="negate" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta" clock="output_clk"/>
        <port name="scanout"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{comb}">
      <input_ports>       
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta scanout dftout"/>
        <port name="ay" combinational_sink_ports="resulta scanout dftout"/>
        <port name="az" combinational_sink_ports="resulta scanout dftout"/>
        <port name="coefsela" combinational_sink_ports="resulta scanout dftout"/>
        <port name="scanin" combinational_sink_ports="resulta scanout dftout"/>
        <port name="ena" combinational_sink_ports="resulta scanout dftout"/>
        <port name="sub" combinational_sink_ports="resulta scanout dftout"/>
        <port name="negate" combinational_sink_ports="resulta scanout dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta scanout dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta scanout dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta"/>
        <port name="scanout"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{reg}">
      <input_ports>       
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_scan_in_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="sub_clk" is_clock="1"/>
        <port name="negate_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="coef_sel_a_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta"/>
        <port name="ay" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta"/>
        <port name="coefsela" clock="coef_sel_a_clk" combinational_sink_ports="resulta"/>
        <port name="scanin" clock="ay_scan_in_clk" combinational_sink_ports="resulta scanout"/>
        <port name="ena" clock="ax_clk"/>
        <port name="sub" clock="sub_clk"/>
        <port name="negate" clock="negate_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="resulta" clock="output_clk"/>
        <port name="scanout" clock="ay_scan_in_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- fp multiplication mode -->
    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{comb}">
      <input_ports>  
        <port name="chainin"  combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ay_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{reg}">
      <input_ports>  
        <port name="chainin" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{comb}">
      <input_ports>  
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports> 
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{reg}">
      <input_ports>  
        <port name="chainin"  combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports> 
    </model>

    <!-- fp multiply accumulate mode -->


    <model name="fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="accumulate" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin" clock="accumulate_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="accumulate"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ay_clk"/>
        <port name="accumulate_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ay_clk"/>
        <port name="dfxlfsrena" clock="ay_clk"/>
        <port name="dfxmisrena" clock="ay_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp multiply add mode-->
    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp adder or subtract mode -->
    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{comb}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" />
        <port name="resulta" />
        <port name="adder_inexact" />
        <port name="adder_invalid" />
        <port name="adder_overflow" />
        <port name="adder_underflow" />
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{reg}">
      <input_ports>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{comb}">
      <input_ports>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="ay" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="ena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow dftout"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{reg}">
      <input_ports>
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- vector one mode -->

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{comb}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{reg}">
      <input_ports>        
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{comb}">
      <input_ports>  
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>      
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta chainout"/>
        <port name="ax" combinational_sink_ports="resulta chainout"/>
        <port name="ay" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{reg}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta chainout"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <!-- fp vector two mode -->

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{comb}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="ax_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{reg}">
      <input_ports>        
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="output_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="output_clk"/>
        <port name="dfxlfsrena" clock="output_clk"/>
        <port name="dfxmisrena" clock="output_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{comb}">
      <input_ports>        
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="chainin" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" combinational_sink_ports="resulta"/>
        <port name="ax" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxlfsrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="dfxmisrena" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout"/>
        <port name="resulta"/>
        <port name="adder_inexact"/>
        <port name="adder_invalid"/>
        <port name="adder_overflow"/>
        <port name="adder_underflow"/>
        <port name="mult_inexact"/>
        <port name="mult_invalid"/>
        <port name="mult_overflow"/>
        <port name="mult_underflow"/>
        <port name="dftout"/>
      </output_ports>
    </model>

    <model name="fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{reg}">
      <input_ports>        
        <port name="chainin"  combinational_sink_ports="resulta chainout adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="clr" clock="ax_clk"/>
        <port name="ax_clk" is_clock="1"/>
        <port name="ay_clk" is_clock="1"/>
        <port name="az_clk" is_clock="1"/>
        <port name="output_clk" is_clock="1"/>
        <port name="ax" clock="ax_clk" combinational_sink_ports="resulta adder_inexact adder_invalid adder_overflow adder_underflow"/>
        <port name="ay" clock="ay_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="az" clock="az_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="ena" clock="ax_clk" combinational_sink_ports="resulta chainout mult_inexact mult_invalid mult_overflow mult_underflow"/>
        <port name="dfxlfsrena" clock="ax_clk"/>
        <port name="dfxmisrena" clock="ax_clk"/>
      </input_ports> 
      <output_ports> 
        <port name="chainout" clock="output_clk"/>
        <port name="resulta" clock="output_clk"/>
        <port name="adder_inexact" clock="output_clk"/>
        <port name="adder_invalid" clock="output_clk"/>
        <port name="adder_overflow" clock="output_clk"/>
        <port name="adder_underflow" clock="output_clk"/>
        <port name="mult_inexact" clock="output_clk"/>
        <port name="mult_invalid" clock="output_clk"/>
        <port name="mult_overflow" clock="output_clk"/>
        <port name="mult_underflow" clock="output_clk"/>
        <port name="dftout" clock="output_clk"/>
      </output_ports>
    </model>

  </models>
  <tiles>
    <tile height="2" name="iolane">
      <sub_tile name="iolane" >
        <equivalent_sites>
          <site pb_type="iolane" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="55" equivalent="none"/>
        <output name="core_out" num_pins="24" equivalent="none"/>
        <clock name="clk" num_pins="1"/>
        <!-- 
          Stratix 10 is a 3 sided architecture, the iolanes can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
          The pins located on the left and right side of the block are uniformly distributed across
          the legnths of 4   
        -->
        <pinlocations pattern="custom">
          <loc side="top">   iolane.core_in  iolane.core_out iolane.clk</loc>
          <loc side="left">  iolane.core_in  iolane.core_out  iolane.clk</loc>
          <loc side="right">  iolane.core_in  iolane.core_out  iolane.clk</loc>
       </pinlocations>
        
        <!-- 
          iolane input muxes have 4 V wires and 6 H wires as input.

          Based on calculations performed for LABs (commented in LAB tile definition):

          The distribution of 6 inputs among different short wire types and fc_in value would be as follows:
          6 * (40/352) ~ 1 input from H2 wires | fc_in(H2) = 1/40 = 0.025
          6 * (112/352) ~ 2 inputs from H4 wires | fc_in(H4) = 2/112 = 0.018 
          6 * (200/352) ~ 3 inputs from H10 wires | fc_in(H10) = 3/200 = 0.015
  
          The distribution of 4 inputs among different short wire types and fc_in value would be as follows:
          4 * (24/160) ~ 1 input from V2 wires | fc_in(V2) = 1/24 = 0.042
          4 * (72/160) ~ 2 inputs from V3 wires | fc_in(V3) = 2/72 = 0.028
          4 * (64/160) ~ 1 input from V4 wires | fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          For every short H wire, 5 inputs come from adjacent blocks outputs. 
          Assuming there are 24 pins on the top side of the iolane block: fc_out(H wires) = 5/24 = 0.21

          For every short V wire, 6 inputs come block outputs. Assuming 3 inputs come from the block
          located on either side of the channel, with 6 pins coming from a unit length on the left and right
          side of the iolane block we have fc_out(V wires) = (3/6) = 0.5
        -->

        <!-- 
          The final fc value is the weighted average of all the calculated fc values. The weights
          are the segments' frequencies.  
          fc_in = (0.025 * 40 + 0.018 * 112 + 0.015 * 200 + 0.042 * 24 + 0.028 * 72 + 0.047 * 64) / 512 = 0.023
          fc_out = ()
        -->

        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.21" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.21" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.21" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.5" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.5" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.5" segment_name="V4"/>
        </fc>

      </sub_tile>
    </tile>

    <tile name="LAB">
      <sub_tile name="LAB">
        <equivalent_sites>
          <site pb_type="LAB" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="data_in" num_pins="60" equivalent="full"/>
        <input name="control_in" num_pins="5" equivalent="full"/>
        <input name="cin" num_pins="1" equivalent="none"/>
        <!-- Stratix 10 does have instance equivalence only for the data_out port
             where ALM outputs can be swapped to reach the most suitable pin location
             for routers. However, it may require significant changes to packing results
             which is not supported yet.
             Therefore, we assume full equivalence here, so that ALM outputs can be swapped
             through a local routing architecture without changing packing results.
             Please note that this may cause optimistic routing results, being
             better in routability than what actual hardware can support
        -->
        <output name="data_out" num_pins="40" equivalent="full"/>
        <output name="cout" num_pins="1" equivalent="none"/>
        <clock name="clk" num_pins="2"/>

        <pinlocations pattern="custom">
          <!-- 
            Stratix 10 is a 3 sided architecture, the LABs can connect to routing on their
            left, top, and right. 
            We model that all the pins can connect to each vertical channel (left/right),
            and the top horizontal channel.
            The exceptions to the above are the LAB chain ports, which propogate downward between blocks.   
          -->
          <loc side="left">  LAB.data_in LAB.control_in LAB.data_out LAB.clk</loc>
          <loc side="right"> LAB.data_in LAB.control_in LAB.data_out LAB.clk</loc>
          <loc side="top">   LAB.data_in LAB.control_in LAB.data_out LAB.clk LAB.cin</loc>
          <loc side="bottom">LAB.cout</loc>
        </pinlocations>

        <!-- 
          LAB input muxes have 4 V wires and 6 H wires as input. It's assumed that distribution of inputs among different wires types 
          is proportional to their frequency.

          For every horizontal channel there are 352 short wires overall (H2:40, H4:112, H10:200). The distribution of 6 inputs among
          different short wire types would be as follows:
          6 * (40/352) ~ 1 input from H2 wires 
          6 * (112/352) ~ 2 inputs from H4 wires 
          6 * (200/352) ~ 3 inputs from H10 wires 
  
          For every vertical channel there are 160 short wires overall (V2:24, V3:72, V4:64). The distribution of 4 inputs among
          different short wire types would be as follows:
          4 * (24/160) ~ 1 input from V2 wires 
          4 * (72/160) ~ 2 inputs from V3 wires 
          4 * (64/160) ~ 1 input from V4 wires 

          For an adjacent horizontal channel:
          1 out of 40 H2 wires is fed into a LIM meaning fc_in(H2) = 1/40 = 0.025
          2 out of 112 H4 wires are fed into a LIM meaning fc_in(H4) = 2/112 = 0.018
          3 out of 200 H10 wires are fed into a LIM meaning fc_in(H10) = 3/200 = 0.015

          For an adjacent vertical channel:
          1 out of 24 V2 wires is fed into a LIM meaning fc_in(V2) = 1/24 = 0.042
          2 out of 72 V3 wires are fed into a LIM meaning fc_in(V3) = 2/72 = 0.028
          1 out of 64 V4 wires are fed into a LIM meaning fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          For every short H wire, 5 inputs come from adjacent blocks outputs. 
          Assuming there are 40 output pins on the top side of the logic block: fc_out(H wires) = 5/40 = 0.125

          For every short V wire, 6 inputs come block outputs. Assuming 3 inputs come from the block
          located on either side of the channel, with 40 output pins coming from the left and right
          side of the logic block we have fc_out(V wires) = (3/40) = 0.075 
        -->
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.18" segment_name="H4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.15" segment_name="H10"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.42" segment_name="V2"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.28" segment_name="V3"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.47" segment_name="V4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
    </tile>

    <tile name="LABMLAB">
      <sub_tile name="LABMLAB">
        <equivalent_sites>
          <site pb_type="LABMLAB" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="data_in" num_pins="60" equivalent="full"/>
        <input name="control_in" num_pins="5" equivalent="full"/>
        <input name="cin" num_pins="1" equivalent="none"/>
        <!-- Stratix 10 does have instance equivalence only for the data_out port
             where ALM outputs can be swapped to reach the most suitable pin location
             for routers. However, it may require significant changes to packing results
             which is not supported yet.
             Therefore, we assume full equivalence here, so that ALM outputs can be swapped
             through a local routing architecture without changing packing results.
             Please note that this may cause optimistic routing results, being
             better in routability than what actual hardware can support
        -->
        <output name="data_out" num_pins="40" equivalent="full"/>
        <output name="cout" num_pins="1" equivalent="none"/>
        <clock name="clk" num_pins="2"/>

        <pinlocations pattern="custom">
          <!-- 
            Stratix 10 is a 3 sided architecture, the LABMLABs can connect to routing on their
            left, top, and right. 
            We model that all the pins can connect to each vertical channel (left/right),
            and the top horizontal channel.
            The exceptions to the above are the LABMLAB chain ports, which propogate downward between blocks.   
          -->
          <loc side="left">  LABMLAB.data_in LABMLAB.control_in LABMLAB.data_out LABMLAB.clk</loc>
          <loc side="right"> LABMLAB.data_in LABMLAB.control_in LABMLAB.data_out LABMLAB.clk</loc>
          <loc side="top">   LABMLAB.data_in LABMLAB.control_in LABMLAB.data_out LABMLAB.clk LABMLAB.cin</loc>
          <loc side="bottom">LABMLAB.cout</loc>
        </pinlocations>

        <!-- 
          LABMLAB input muxes have 4 V wires and 6 H wires as input. It's assumed that distribution of inputs among different wires types 
          is proportional to their frequency.

          For every horizontal channel there are 352 short wires overall (H2:40, H4:112, H10:200). The distribution of 6 inputs among
          different short wire types would be as follows:
          6 * (40/352) ~ 1 input from H2 wires 
          6 * (112/352) ~ 2 inputs from H4 wires 
          6 * (200/352) ~ 3 inputs from H10 wires 
  
          For every vertical channel there are 160 short wires overall (V2:24, V3:72, V4:64). The distribution of 4 inputs among
          different short wire types would be as follows:
          4 * (24/160) ~ 1 input from V2 wires 
          4 * (72/160) ~ 2 inputs from V3 wires 
          4 * (64/160) ~ 1 input from V4 wires 

          For an adjacent horizontal channel:
          1 out of 40 H2 wires is fed into a LIM meaning fc_in(H2) = 1/40 = 0.025
          2 out of 112 H4 wires are fed into a LIM meaning fc_in(H4) = 2/112 = 0.018
          3 out of 200 H10 wires are fed into a LIM meaning fc_in(H10) = 3/200 = 0.015

          For an adjacent vertical channel:
          1 out of 24 V2 wires is fed into a LIM meaning fc_in(V2) = 1/24 = 0.042
          2 out of 72 V3 wires are fed into a LIM meaning fc_in(V3) = 2/72 = 0.028
          1 out of 64 V4 wires are fed into a LIM meaning fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          For every short H wire, 5 inputs come from adjacent blocks outputs. 
          Assuming there are 40 output pins on the top side of the logic block: fc_out(H wires) = 5/40 = 0.125

          For every short V wire, 6 inputs come block outputs. Assuming 3 inputs come from the block
          located on either side of the channel, with 40 output pins coming from the left and right
          side of the logic block we have fc_out(V wires) = (3/40) = 0.075 
        -->
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.18" segment_name="H4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.15" segment_name="H10"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.42" segment_name="V2"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.28" segment_name="V3"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="data_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="control_in" fc_type="frac" fc_val="0.47" segment_name="V4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
    </tile>

    <tile height="12" name="PLL_OCT_CLK_CTRL">
      <!-- 
          PLL input muxes have 4 V wires and 6 H wires as input.

          Based on calculations performed for LABs (commented in LAB tile definition):

          The distribution of 6 inputs among different short wire types and fc_in value would be as follows:
          6 * (40/352) ~ 1 input from H2 wires | fc_in(H2) = 1/40 = 0.025
          6 * (112/352) ~ 2 inputs from H4 wires | fc_in(H4) = 2/112 = 0.018 
          6 * (200/352) ~ 3 inputs from H10 wires | fc_in(H10) = 3/200 = 0.015
  
          The distribution of 4 inputs among different short wire types and fc_in value would be as follows:
          4 * (24/160) ~ 1 input from V2 wires | fc_in(V2) = 1/24 = 0.042
          4 * (72/160) ~ 2 inputs from V3 wires | fc_in(V3) = 2/72 = 0.028
          4 * (64/160) ~ 1 input from V4 wires | fc_in(V4) = 3/64 = 0.047 
      -->

      <!-- 
          For every short H wire, 5 inputs come from adjacent blocks outputs. 
          Assuming there are 40 output pins (36 from PLL subtile, 3 from clock_div subtile, 1 from clock_gate subtile)
          on the top side of the current tile: fc_out(H wires) = 5/40 = 0.125

          For every short V wire, 6 inputs come block outputs. Assuming 3 inputs come from the block
          located on either side of the channel, with 42 pins coming from the left and right
          side of the  urrent tile we have fc_out(V wires) = (3/40) = 0.075
      -->

      <sub_tile name="PLL">
        <equivalent_sites>
          <site pb_type="PLL" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="40"/>
        <output name="core_out" num_pins="36"/>
        <clock name="clk" num_pins="2"/>
        <!-- 
          Stratix 10 is a 3 sided architecture, the iolanes can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
        -->
        <pinlocations pattern="custom">
          <loc side="left">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="right">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="top">PLL.core_in PLL.core_out PLL.clk </loc>
        </pinlocations>

        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
      <sub_tile name="clock_div">
        <equivalent_sites>
          <site pb_type="clock_div" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="inclk" num_pins="1"/>
        <output name="clock_div_out" num_pins="3"/>
        <!-- 
          Stratix 10 is a 3 sided architecture, the iolanes can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
          The pins located on the left and right side of the block are uniformly distributed across
          the legnths of 4   
        -->
        <pinlocations pattern="custom">
          <loc side="left">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="right">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="top">clock_div.inclk clock_div.clock_div_out </loc>
          <loc side="bottom">clock_div.inclk clock_div.clock_div_out </loc>
        </pinlocations>

        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="clock_div_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="clock_div_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="clock_div_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="clock_div_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="clock_div_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
      <sub_tile name="clock_gate">
        <equivalent_sites>
          <site pb_type="clock_gate" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="inclk" num_pins="1"/>
        <input name="enable" num_pins="1"/>
        <output name="outclk" num_pins="1"/>
        <!-- 
          Stratix 10 is a 3 sided architecture, the iolanes can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
          The pins located on the left and right side of the block are uniformly distributed across
          the legnths of 4   
        -->
        <pinlocations pattern="custom">
          <loc side="left">clock_gate.inclk clock_gate.enable clock_gate.outclk</loc>
          <loc side="right">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
          <loc side="top">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
          <loc side="bottom">clock_gate.inclk clock_gate.enable clock_gate.outclk </loc>
        </pinlocations>
        
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="enable" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="outclk" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="enable" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="outclk" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="enable" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="outclk" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="enable" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="outclk" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="inclk" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="enable" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="outclk" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
      <sub_tile name="OCT">
        <equivalent_sites>
          <site pb_type="OCT" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="10"/>
        <output name="core_out" num_pins="36"/>
        <clock name="clk" num_pins="1"/>
        <!-- 
          Stratix 10 is a 3 sided architecture, the iolanes can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
          The pins located on the left and right side of the block are uniformly distributed across
          the legnths of 4   
        -->
        <pinlocations pattern="custom">
          <loc side="left">OCT.core_in OCT.core_out OCT.clk </loc>
          <loc side="right">OCT.core_in OCT.core_out OCT.clk </loc>
          <loc side="top">OCT.core_in OCT.core_out OCT.clk </loc>
        </pinlocations>

        <!-- 
          OCT input muxes have 4 V wires and 6 H wires as input.

          Based on calculations performed for LABs (commented in LAB tile definition):

          The distribution of 6 inputs among different short wire types and fc_in value would be as follows:
          6 * (40/352) ~ 1 input from H2 wires | fc_in(H2) = 1/40 = 0.025
          6 * (112/352) ~ 2 inputs from H4 wires | fc_in(H4) = 2/112 = 0.018 
          6 * (200/352) ~ 3 inputs from H10 wires | fc_in(H10) = 3/200 = 0.015
  
          The distribution of 4 inputs among different short wire types and fc_in value would be as follows:
          4 * (24/160) ~ 1 input from V2 wires | fc_in(V2) = 1/24 = 0.042
          4 * (72/160) ~ 2 inputs from V3 wires | fc_in(V3) = 2/72 = 0.028
          4 * (64/160) ~ 1 input from V4 wires | fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          For every short H wire, 5 inputs come from adjacent blocks outputs. 
          Assuming there are 36 pins on the top side of the OCT block: fc_out(H wires) = 5/36 = 0.14

          For every short V wire, 6 inputs come block outputs. Assuming 3 inputs come from the block
          located on either side of the channel, with 36 pins coming from the left and right
          side of the OCT block we have fc_out(V wires) = (3/36) = 0.083
        -->
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.14" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.14" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.14" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.083" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.083" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="core_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="core_out" fc_type="frac" fc_val="0.083" segment_name="V4"/>
        </fc>
      </sub_tile>
    </tile>

    <tile name="DSP">
      <sub_tile name="DSP">
        <equivalent_sites>
          <site pb_type="DSP" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="dspin" num_pins="240" />
        <input name="chainin" num_pins="64" />
        <input name="scanin" num_pins="27" />
        <clock name="clk" num_pins="3" />
        <output name="result" num_pins="74" />
        <output name="chainout" num_pins="64" />
        <output name="scanout" num_pins="27" />
        <output name="dftout" num_pins="1" />

        <!-- 
          Stratix 10 is a 3 sided architecture, the DSPs can connect to routing on their
          left, top, and right. 
          We model that all the pins can connect to each vertical channel (left/right),
          and the top horizontal channel.
          The exceptions to the above are the DSP chain and scan ports, which propogate downward between blocks.   
        -->
        <pinlocations pattern="custom">
          <loc side="left">DSP.dspin DSP.clk DSP.result DSP.dftout</loc>
          <loc side="right">DSP.dspin DSP.clk DSP.result DSP.dftout</loc>
          <loc side="top">DSP.dspin DSP.chainin DSP.scanin DSP.clk DSP.result DSP.dftout</loc>
          <loc side="bottom">DSP.chainout DSP.scanout</loc>
        </pinlocations>
        <!-- 
          DSP input muxes have 4 V wires and 6 H wires as input.

          Based on calculations performed for LABs (commented in LAB tile definition):

          The distribution of 6 inputs among different short wire types and fc_in value would be as follows:
          6 * (40/352) ~ 1 input from H2 wires | fc_in(H2) = 1/40 = 0.025
          6 * (112/352) ~ 2 inputs from H4 wires | fc_in(H4) = 2/112 = 0.018 
          6 * (200/352) ~ 3 inputs from H10 wires | fc_in(H10) = 3/200 = 0.015
  
          The distribution of 4 inputs among different short wire types and fc_in value would be as follows:
          4 * (24/160) ~ 1 input from V2 wires | fc_in(V2) = 1/24 = 0.042
          4 * (72/160) ~ 2 inputs from V3 wires | fc_in(V3) = 2/72 = 0.028
          4 * (64/160) ~ 1 input from V4 wires | fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          qqqqqq
          Since a DSP has more output pins compared to a LAB, if the fc_out value were to be calculated the same way, 
          the fc_out value would be significantly smaller, affecting block's connectivity. In Stratix 10 architecture, 
          certain solutions are applied to ensure enough connectivity for DSP blocks. In our modelling, fc_out value is set 
          to the same value as that of logic blocks. This approximation will lead to bigger mus sizes for wire segments adjacent to the DSP blocks 
          but it will ensure there is enough connectivty to route the DSP primitives
        -->
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="chainin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="chainout" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanout" fc_type="frac" fc_val="0"/>
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="dspin" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="dftout" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <fc_override port_name="result" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="dspin" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="dftout" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <fc_override port_name="result" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="dspin" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="dftout" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <fc_override port_name="result" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="dspin" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="dftout" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <fc_override port_name="result" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="dspin" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="dftout" fc_type="frac" fc_val="0.75" segment_name="V4"/>
          <fc_override port_name="result" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
    </tile>

    <tile name="M20K">
      <sub_tile name="M20K">
        <equivalent_sites>
          <site pb_type="M20K" pin_mapping="direct" />
        </equivalent_sites>
        <input name="data_addr_control_in" num_pins="120" />
        <output name="data_out" num_pins="40" />
        <output name="control_out" num_pins="2" />
        <clock name="clk_in" num_pins="2" />

        <pinlocations pattern="custom">
          <loc side="left">  M20K.data_addr_control_in  M20K.control_out M20K.data_out  M20K.clk_in </loc>
          <loc side="right">  M20K.data_addr_control_in  M20K.control_out M20K.data_out  M20K.clk_in </loc>
          <loc side="top">  M20K.data_addr_control_in  M20K.control_out M20K.data_out  M20K.clk_in </loc>
        </pinlocations>

        <!-- 
          RAM input muxes have 4 V wires and 6 H wires as input.

          Based on calculations performed for LABs (commented in LAB tile definition):

          The distribution of 6 inputs among different short wire types and fc_in value would be as follows:
          6 * (40/352) ~ 1 input from H2 wires | fc_in(H2) = 1/40 = 0.025
          6 * (112/352) ~ 2 inputs from H4 wires | fc_in(H4) = 2/112 = 0.018 
          6 * (200/352) ~ 3 inputs from H10 wires | fc_in(H10) = 3/200 = 0.015
  
          The distribution of 4 inputs among different short wire types and fc_in value would be as follows:
          4 * (24/160) ~ 1 input from V2 wires | fc_in(V2) = 1/24 = 0.042
          4 * (72/160) ~ 2 inputs from V3 wires | fc_in(V3) = 2/72 = 0.028
          4 * (64/160) ~ 1 input from V4 wires | fc_in(V4) = 3/64 = 0.047 
        -->

        <!-- 
          It's assumed that RAM block has the same fc_out value as LAB. 
        -->
        <!-- Specifying the default fc values for H2 wires and overriding these values for the remaining segments-->
        <fc in_type="frac" in_val="0.025" out_type="frac" out_val="0.125" >
          <!-- Specifying fc values for H4 wires -->
          <fc_override port_name="data_addr_control_in" fc_type="frac" fc_val="0.018" segment_name="H4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <fc_override port_name="control_out" fc_type="frac" fc_val="0.125" segment_name="H4"/>
          <!-- Specifying fc values for H10 wires -->
          <fc_override port_name="data_addr_control_in" fc_type="frac" fc_val="0.015" segment_name="H10"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <fc_override port_name="control_out" fc_type="frac" fc_val="0.125" segment_name="H10"/>
          <!-- Specifying fc values for V2 wires -->
          <fc_override port_name="data_addr_control_in" fc_type="frac" fc_val="0.042" segment_name="V2"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <fc_override port_name="control_out" fc_type="frac" fc_val="0.75" segment_name="V2"/>
          <!-- Specifying fc values for V3 wires -->
          <fc_override port_name="data_addr_control_in" fc_type="frac" fc_val="0.028" segment_name="V3"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <fc_override port_name="control_out" fc_type="frac" fc_val="0.75" segment_name="V3"/>
          <!-- Specifying fc values for V4 wires -->
          <fc_override port_name="data_addr_control_in" fc_type="frac" fc_val="0.047" segment_name="V4"/>
          <fc_override port_name="data_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
          <fc_override port_name="control_out" fc_type="frac" fc_val="0.75" segment_name="V4"/>
        </fc>
      </sub_tile>
    </tile>
  </tiles>
  <layout>
    <auto_layout aspect_ratio="1.35">
      <perimeter type="EMPTY" priority="5000"/>

      <!-- In Stratix 10 devices, IO pins are located in two columns each with a 20% margin from the side borders -->

      <!--Column of 'IO' declared with 'EMPTY' blocks of length 1 wherever an IO block of length 4 does not fit. Vertical offset by 1 for perimeter.-->
      <col type="EMPTY" startx="W/5" priority="1000"/>
      <col type="iolane" startx="W/5" priority="1001"/>
      <!-- Left column -->
      <col type="EMPTY" startx="4*W/5" priority="1000"/>
      <col type="iolane" startx="4*W/5" priority="1001"/>
      <!-- Right column -->



      <!-- Stratix 10 devices support up to 24 PLLs and OCTs located 
            in the same columns as IOs occuring after every 6 consecutive IO blocks-->
      <!-- It's been assumed that PLL and OCT each take half their actual length. A more accurate alternative that can be implemented in the future is to define them as subtime belonging to the same tile -->
      <col type="PLL_OCT_CLK_CTRL" startx="W/5" starty="1" incry="36" priority="1997"/>
      <col type="PLL_OCT_CLK_CTRL" startx="4*W/5" starty="1" incry="36" priority="1997"/>

      <!--Fill with 'LAB'-->
      <fill type="LAB" priority="10"/>
      <!--One quarter of the LAB blocks can also be used as MLABs-->
      <!--One out of every for logic columns is of the type LABMLAB-->
      <col type="LABMLAB" startx="3" starty="0" repeatx="4" priority="11"/>

      <!--Column of 'DSP'. Vertical offset by 1 for perimeter.-->
      <col type="DSP" startx="20" starty="2" repeatx="20" priority="150"/>
      <!--Column of 'M20K'. Vertical offset by 1 for perimeter.-->
      <col type="M20K" startx="5" starty="2" repeatx="10" priority="50"/>

    </auto_layout>
    <fixed_layout height="434" name="1SG250HH1F55E1VG" width="284">
      <perimeter type="EMPTY" priority="5000"/>

      <!-- In Stratix 10 devices, IO pins are located in two columns each with a 20% margin from the side borders -->

      <!--Column of 'IO' declared with 'EMPTY' blocks of length 1 wherever an IO block of length 4 does not fit. Vertical offset by 1 for perimeter.-->
      <col type="EMPTY" startx="W/5" priority="1000"/>
      <col type="iolane" startx="W/5" priority="1001"/>
      <!-- Left column -->
      <col type="EMPTY" startx="4*W/5" priority="1000"/>
      <col type="iolane" startx="4*W/5" priority="1001"/>
      <!-- Right column -->

      <!-- Stratix 10 devices support up to 24 PLLs and OCTs located 
            in the same columns as IOs occuring after every 6 consecutive IO blocks-->
      <col type="PLL_OCT_CLK_CTRL" startx="W/5" starty="13" incry="36" priority="1997"/>
      <col type="PLL_OCT_CLK_CTRL" startx="4*W/5" starty="13" incry="36" priority="1997"/>

      <!--Fill with 'LAB'-->
      <fill type="LAB" priority="10"/>
      <!--One quarter of the LAB blocks can also be used as MLABs-->
      <!--One out of every for logic columns is of the type LABMLAB-->
      <col type="LABMLAB" startx="3" starty="0" repeatx="4" priority="11"/>

      <!--Column of 'DSP'-->
      <col type="DSP" startx="38" starty="0" repeatx="18" priority="150"/>
      <!--Column of 'M20K'-->
      <col type="M20K" startx="14" starty="0" repeatx="9" priority="50"/>
      <!--One out of every three M20K columns have 12 mini columns of 7 empty tiles spaced out evenly across the whole column-->
      <col type="EMPTY" startx="14" starty="30" repeatx="27" incry="36" priority="5001"/>
      <col type="EMPTY" startx="14" starty="31" repeatx="27" incry="36" priority="5002"/>
      <col type="EMPTY" startx="14" starty="32" repeatx="27" incry="36" priority="5003"/>
      <col type="EMPTY" startx="14" starty="33" repeatx="27" incry="36" priority="5004"/>
      <col type="EMPTY" startx="14" starty="34" repeatx="27" incry="36" priority="5005"/>
      <col type="EMPTY" startx="14" starty="35" repeatx="27" incry="36" priority="5006"/>
      <col type="EMPTY" startx="14" starty="36" repeatx="27" incry="36" priority="5007"/>
      
      <!-- There is one column of empty tiles in the middle of the device -->
      <col type="EMPTY" startx="164" priority="5008"/>
      <!-- There are two empty rectangles near the top left corner of the device -->
      <region type="EMPTY" priority="5009" startx="62" endx="133" starty="397" endy="433"/>
      <region type="EMPTY" priority="5010" startx="62" endx="65" starty="325" endy="433"/>
    </fixed_layout>
  </layout>
  <device>
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>
    <!-- KEM: Oct 15, 2013
          Place no timing delay on the input pin of complex blocks.
          We model this directly inside the block, rather than in the
          global routing delay. This matches the behaviour of
          Quartus II. -->
    <area grid_logic_tile_area="0.0"/>
    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="0.480000"/>
    </chan_width_distr>
    <switch_block type="custom"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>
  <switchlist>
    <!-- AA: July 19, 2020
         We define three types of drivers, one for each of the segment types (see comment in <segmentlist> section)
         In the model for Stratix 10 we put all the delay on switch and connection blocks in the form of Tdel; Meaning that we assume the resistance and capticance of the switches are set to 0. 
         Stratix 10 is modelled here to have 3 different segment wire types per horizational/vertical channel.           
       -->

    <!-- AA: The mux_tran_size and buf_size parameters for switches are kept the same as ones in Startix IV since modelling area in Stratix 10 is of little intrest and difficult.-->
    <switch type="mux" name="seg_h2_driver" R="0" Cin="0" Cout="0" Tdel="89e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h4_driver" R="0" Cin="0" Cout="0" Tdel="133e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h10_driver" R="0" Cin="0" Cout="0" Tdel="203e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_h24_driver" R="0" Cin="0" Cout="0" Tdel="188e-12" mux_trans_size="2.630740" buf_size="27.647901"/>

    <switch type="mux" name="seg_v2_driver" R="0" Cin="0" Cout="0" Tdel="95e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v3_driver" R="0" Cin="0" Cout="0" Tdel="194e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v4_driver" R="0" Cin="0" Cout="0" Tdel="146e-12" mux_trans_size="2.630740" buf_size="27.647901"/>
    <switch type="mux" name="seg_v16_driver" R="0" Cin="0" Cout="0" Tdel="213e-12" mux_trans_size="2.630740" buf_size="27.647901"/>

    <!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer-->
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="0e0" mux_trans_size="1.222260" buf_size="auto"/>
  </switchlist>
  <segmentlist>
    <!-- AA: July 19, 2021

           Wire distribution:
             In stratix 10 there are eight types of wires: R2,R4,R10,R20,C2,C3,C4,C12
             R wires are row wires running horizontally accross the chip
             C wires are column wires running vertically accross the chip

             The wire counts for Stratix IV channels are:
                R2 : 152
                C2 : 160
                R4 : 152
                C3 : 160
                R10: 210
                C4 : 160
                R24:  48
                C16:  32
                Total horizontal tracks: 562
                Total vertical tracks: 512

                6.5% of vertical & 8.5% of horizontal wires are long. (7.5% in average)

                92.5% of horizontal wires &  93.5% of veritcal wires are intermediate wires. 

                We will divide the wires into L2, L4, and L20 wires keeping in mind that VPR doesn't support non-uniform horizontal and vertical channels: 

                 The combination of R2,C2, and C3 wires gives the channel width for L2 wires:
                 
                 (152+160+160)/2=236 

                 The combination of R4,C4,and R10 wires gives the channel width for L4:

                 (210+152+152)/3=257
                
                 The average of C16 and R24 wires gives the channel width for L20 wires: 

                 (32+48)/2=40

                 The average channel width for the horizontal and vertical channels is: (562+512)/2=537 ~540 

                 The difference between the target channel width and total of wires thus far will be added to L4 wires since the total of R4,C4, and R10 
                 wires is larger than R2,C2, and C3 wires:  

                 540-257-236-40=6 -> 6 additional L4 wires 

                 Finally we have: 
                
                 L2:236
                 L4:264
                 L20:40

                 We get the following ratios with this distribution: 
                
                 7.4% are long wires.  
                 92.6% are short wires. 

                 which is reasonable.

              Thus to model the routing we have the following: 
                - A channel width of 540 wires (provided on the command line)
                - 7.4% of wires are L20 wires
                - 42.4% of wires are L4 wires
                - 50.2% of wires are L2 wires

           NOTE: In Startix10 we do not model metal data since all the delay is put on the driving muxes. 
        
           Wire delays:

             The average delays of the actual wires using Quartus PrimePro came to be the following: 

              C2: 95 ps     R2: 89  ps
              C3: 194 ps    R4: 133 ps
              C4: 146 ps    R10: 203  ps
              C16: 213 ps   R24: 188  ps


             Averaging accross wires of the same type we attempt to make the wires total delays correlate to the following values:
              L2: 92 ps
              L4: 140 ps
              L20: 201 ps  

          NOTE: We don't model minimum capacitances for Stratix10. 
    -->
    <segment name="H2" axis="x" freq="40" length="2" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h2_driver"/>
      <sb type="pattern">1 1 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment name="H4" axis="x" freq="112" length="4" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h4_driver"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>

    <segment name="H10" axis="x" freq="200" length="10" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h10_driver"/>
      <sb type="pattern">1 0 1 0 1 0 1 0 1 0 1</sb>
      <cb type="pattern">1 1 1 1 1 1 1 1 1 1</cb>
    </segment>

    <segment name="H24" axis="x" freq="48" length="24" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_h24_driver"/>
      <sb type="pattern">1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1</sb>
      <cb type="pattern">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</cb>
    </segment>
    
    <segment name="V2" axis="y" freq="24" length="2" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v2_driver"/>
      <sb type="pattern">1 1 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment name="V3" axis="y" freq="72" length="3" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v3_driver"/>
      <sb type="pattern">1 1 1 1</sb>
      <cb type="pattern">1 1 1</cb>
    </segment>

    <segment name="V4" axis="y" freq="64" length="4" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v4_driver"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>

    <segment name="V16" axis="y" freq="32" length="16" type="unidir" Rmetal="0" Cmetal="0">
      <mux name="seg_v16_driver"/>
      <sb type="pattern">1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</sb>
      <cb type="pattern">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</cb>
    </segment>
  </segmentlist>
  <directlist>


    <!-- chainout propogates downward between DSP blocks-->
    <direct name="DSP_chainout" from_pin="DSP.chainout" from_side="bottom" to_pin="DSP.chainin" to_side="top" x_offset="0" y_offset="-1" z_offset="0"/>
   <!-- scanout propogates downward between DSP blocks-->
    <direct name="DSP_scannout" from_pin="DSP.scanout" from_side="bottom" to_pin="DSP.scanin" to_side="top" x_offset="0" y_offset="-1" z_offset="0"/>

    <!--Carry chain propogates downward between LAB and LABMLAB blocks-->
    <direct name="LAB_carry_chain1" from_pin="LAB.cout" from_side="bottom" to_pin="LAB.cin" to_side="top" x_offset="0" y_offset="-1" z_offset="0"/>
    <direct name="LAB_carry_chain2" from_pin="LABMLAB.cout" from_side="bottom" to_pin="LABMLAB.cin" to_side="top" x_offset="0" y_offset="-1" z_offset="0"/>


    <!-- ############### Directlinks to LABs ############### -->
    <!-- 
        LAB lines are LAB's local interconnect driving the logic elements input muxes
        LAB lines consist of 60 LAB input muxes (LIMs). A LIM is a 12:1 mux with the following distribution of inputs:
        4 V wires, 6 or 7 H wires, 1 or 2 sneaks from the LAB itself or the adjacent block

        For simplicity, it's assumed that all the LIMs have 6 H wires inputs, while half of them have 1 and the other half
        have 2 sneaks. This will lead to a LIM size of 11 for half of the LAB lines and a LIM size of 12 for the other half
    -->
    <!-- 
        50 self-sneaks coming from the LAB output; starting from LIM #11 every fourth LIM is missing a self-sneak.
        (11, 15, 19, ..., 47) are the LIM numbers that don't have a self-sneak
        One in every four LAB outputs (10 overall) have two fan-outs to the LAB input while the remaining 
        30 outputs have a single self-sneak fan-out adding up to 50 self-sneaks overall 
    -->
    <!-- two fan-outs from data_out[0:0] -->
    <direct name="LAB_self_sneak0" from_pin="LAB.data_out[0:0]" from_side="right" to_pin="LAB.data_in[0:0]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak1" from_pin="LAB.data_out[0:0]" from_side="right" to_pin="LAB.data_in[1:1]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak2" from_pin="LAB.data_out[3:1]" from_side="right" to_pin="LAB.data_in[4:2]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[4:4] -->
    <direct name="LAB_self_sneak3" from_pin="LAB.data_out[4:4]" from_side="right" to_pin="LAB.data_in[5:5]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak4" from_pin="LAB.data_out[4:4]" from_side="right" to_pin="LAB.data_in[6:6]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak5" from_pin="LAB.data_out[7:5]" from_side="right" to_pin="LAB.data_in[9:7]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[8:8] -->
    <direct name="LAB_self_sneak6" from_pin="LAB.data_out[8:8]" from_side="right" to_pin="LAB.data_in[10:10]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[11:11] -->
    <direct name="LAB_self_sneak7" from_pin="LAB.data_out[8:8]" from_side="right" to_pin="LAB.data_in[12:12]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak8" from_pin="LAB.data_out[10:9]" from_side="right" to_pin="LAB.data_in[14:13]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[15:15] -->
    <direct name="LAB_self_sneak9" from_pin="LAB.data_out[11:11]" from_side="right" to_pin="LAB.data_in[16:16]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[12:12] -->
    <direct name="LAB_self_sneak10" from_pin="LAB.data_out[12:12]" from_side="right" to_pin="LAB.data_in[17:17]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak11" from_pin="LAB.data_out[12:12]" from_side="right" to_pin="LAB.data_in[18:18]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[19:19] -->
    <direct name="LAB_self_sneak12" from_pin="LAB.data_out[15:13]" from_side="right" to_pin="LAB.data_in[22:20]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[16:16] -->
    <!-- skipping data_in[23:23] -->
    <direct name="LAB_self_sneak13" from_pin="LAB.data_out[16:16]" from_side="right" to_pin="LAB.data_in[24:24]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak14" from_pin="LAB.data_out[16:16]" from_side="right" to_pin="LAB.data_in[25:25]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak15" from_pin="LAB.data_out[17:17]" from_side="right" to_pin="LAB.data_in[26:26]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[27:27] -->
    <direct name="LAB_self_sneak16" from_pin="LAB.data_out[19:18]" from_side="right" to_pin="LAB.data_in[29:28]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[20:20] -->
    <direct name="LAB_self_sneak17" from_pin="LAB.data_out[20:20]" from_side="right" to_pin="LAB.data_in[30:30]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[31:31] -->
    <direct name="LAB_self_sneak18" from_pin="LAB.data_out[20:20]" from_side="right" to_pin="LAB.data_in[32:32]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak19" from_pin="LAB.data_out[22:21]" from_side="right" to_pin="LAB.data_in[34:33]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[35:35] -->
    <direct name="LAB_self_sneak20" from_pin="LAB.data_out[23:23]" from_side="right" to_pin="LAB.data_in[36:36]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[24:24] -->
    <direct name="LAB_self_sneak21" from_pin="LAB.data_out[24:24]" from_side="right" to_pin="LAB.data_in[37:37]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak22" from_pin="LAB.data_out[24:24]" from_side="right" to_pin="LAB.data_in[38:38]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[39:39] -->
    <direct name="LAB_self_sneak23" from_pin="LAB.data_out[27:25]" from_side="right" to_pin="LAB.data_in[42:40]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[28:28] -->
    <!-- skipping data_in[43:43] -->
    <direct name="LAB_self_sneak24" from_pin="LAB.data_out[28:28]" from_side="right" to_pin="LAB.data_in[44:44]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak25" from_pin="LAB.data_out[28:28]" from_side="right" to_pin="LAB.data_in[45:45]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak26" from_pin="LAB.data_out[29:29]" from_side="right" to_pin="LAB.data_in[46:46]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- skipping data_in[47:47] -->
    <direct name="LAB_self_sneak27" from_pin="LAB.data_out[31:30]" from_side="right" to_pin="LAB.data_in[49:48]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[32:32] -->
    <direct name="LAB_self_sneak28" from_pin="LAB.data_out[32:32]" from_side="right" to_pin="LAB.data_in[50:50]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak29" from_pin="LAB.data_out[32:32]" from_side="right" to_pin="LAB.data_in[51:51]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak30" from_pin="LAB.data_out[35:33]" from_side="right" to_pin="LAB.data_in[54:52]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <!-- two fan-outs from data_out[36:36] -->
    <direct name="LAB_self_sneak31" from_pin="LAB.data_out[36:36]" from_side="right" to_pin="LAB.data_in[55:55]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak32" from_pin="LAB.data_out[36:36]" from_side="right" to_pin="LAB.data_in[56:56]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>
    <direct name="LAB_self_sneak33" from_pin="LAB.data_out[39:37]" from_side="right" to_pin="LAB.data_in[59:57]" to_side="left" x_offset="0" y_offset="0" z_offset="0"/>

    <!-- 
      It's assumed that for the case where the adjacent block is an IO periphal other than iolane 
      there are no incoming direct connections to the adjacent LAB  
    -->

    <!-- 
      Since there is a full crossbar from the LAB lines to the ALM inputs 
      the selection of LAB lines that are driven by outputs of the adjecent blocks won't affect routability to different ALMs.
      
      However, if a partial crossbar is implemented within the LAB then the selection of LAB lines should be 
      such that the directlinks are uniformly accessible from every ALM input. These directlinks can come from LABs, DSPs, M20Ks and iolanes

      The above point also applies to DSP lines and iolane lines as they are fed into a full crossbar as well
    -->

    <!--
      When there is a full crossbar from the output of ALMs to output of the LAB, it won't matter which set of 20
      pins get selected for direct connection to the adjacent block. This is the case as of Nov 4, 2022. 
      Nonetheless, the selection of output pins for directlink to neighboring blocks is based on the assumption that 
      there is a directlink (instead of a crossbar) from ALM outputs to the LAB output to support future changes to 
      the full crossbar. Each ALM has four outputs  where the first and second as well as the third and the fourth output 
      are driven by the same set of signals. To avoid redundant links, the set of even/odd pins are selected for directlink 
      to the left/right neighboring blocks. 
    -->

    <!-- 20 direct connections coming from the odd pin numbers of the adjacent LAB located to the left of the LAB-->
    <direct name="LAB_side_sneak_LAB_1" from_pin="LAB.data_out[1:1]" from_side="right" to_pin="LAB.data_in[11:11]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_3" from_pin="LAB.data_out[3:3]" from_side="right" to_pin="LAB.data_in[13:13]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_5" from_pin="LAB.data_out[5:5]" from_side="right" to_pin="LAB.data_in[15:15]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_7" from_pin="LAB.data_out[7:7]" from_side="right" to_pin="LAB.data_in[17:17]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_9" from_pin="LAB.data_out[9:9]" from_side="right" to_pin="LAB.data_in[19:19]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_11" from_pin="LAB.data_out[11:11]" from_side="right" to_pin="LAB.data_in[21:21]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_13" from_pin="LAB.data_out[13:13]" from_side="right" to_pin="LAB.data_in[23:23]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_15" from_pin="LAB.data_out[15:15]" from_side="right" to_pin="LAB.data_in[25:25]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_17" from_pin="LAB.data_out[17:17]" from_side="right" to_pin="LAB.data_in[27:27]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_19" from_pin="LAB.data_out[19:19]" from_side="right" to_pin="LAB.data_in[29:29]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_21" from_pin="LAB.data_out[21:21]" from_side="right" to_pin="LAB.data_in[31:31]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_23" from_pin="LAB.data_out[23:23]" from_side="right" to_pin="LAB.data_in[33:33]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_25" from_pin="LAB.data_out[25:25]" from_side="right" to_pin="LAB.data_in[35:35]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_27" from_pin="LAB.data_out[27:27]" from_side="right" to_pin="LAB.data_in[37:37]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_29" from_pin="LAB.data_out[29:29]" from_side="right" to_pin="LAB.data_in[39:39]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_31" from_pin="LAB.data_out[31:31]" from_side="right" to_pin="LAB.data_in[41:41]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_33" from_pin="LAB.data_out[33:33]" from_side="right" to_pin="LAB.data_in[43:43]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_35" from_pin="LAB.data_out[35:35]" from_side="right" to_pin="LAB.data_in[45:45]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_37" from_pin="LAB.data_out[37:37]" from_side="right" to_pin="LAB.data_in[47:47]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_39" from_pin="LAB.data_out[39:39]" from_side="right" to_pin="LAB.data_in[49:49]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>

    <!-- 20 direct connections coming from the even pin numbers of the adjacent LAB located to the right of the LAB-->
    <direct name="LAB_side_sneak_LAB_0" from_pin="LAB.data_out[0:0]" from_side="left" to_pin="LAB.data_in[12:12]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_2" from_pin="LAB.data_out[2:2]" from_side="left" to_pin="LAB.data_in[14:14]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_4" from_pin="LAB.data_out[4:4]" from_side="left" to_pin="LAB.data_in[16:16]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_6" from_pin="LAB.data_out[6:6]" from_side="left" to_pin="LAB.data_in[18:18]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_8" from_pin="LAB.data_out[8:8]" from_side="left" to_pin="LAB.data_in[20:20]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_10" from_pin="LAB.data_out[10:10]" from_side="left" to_pin="LAB.data_in[22:22]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_12" from_pin="LAB.data_out[12:12]" from_side="left" to_pin="LAB.data_in[24:24]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_14" from_pin="LAB.data_out[14:14]" from_side="left" to_pin="LAB.data_in[26:26]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_16" from_pin="LAB.data_out[16:16]" from_side="left" to_pin="LAB.data_in[28:28]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_18" from_pin="LAB.data_out[18:18]" from_side="left" to_pin="LAB.data_in[30:30]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_20" from_pin="LAB.data_out[20:20]" from_side="left" to_pin="LAB.data_in[32:32]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_22" from_pin="LAB.data_out[22:22]" from_side="left" to_pin="LAB.data_in[34:34]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_24" from_pin="LAB.data_out[24:24]" from_side="left" to_pin="LAB.data_in[36:36]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_26" from_pin="LAB.data_out[26:26]" from_side="left" to_pin="LAB.data_in[38:38]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_28" from_pin="LAB.data_out[28:28]" from_side="left" to_pin="LAB.data_in[40:40]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_30" from_pin="LAB.data_out[30:30]" from_side="left" to_pin="LAB.data_in[42:42]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_32" from_pin="LAB.data_out[32:32]" from_side="left" to_pin="LAB.data_in[44:44]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_34" from_pin="LAB.data_out[34:34]" from_side="left" to_pin="LAB.data_in[46:46]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_36" from_pin="LAB.data_out[36:36]" from_side="left" to_pin="LAB.data_in[48:48]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_LAB_38" from_pin="LAB.data_out[38:38]" from_side="left" to_pin="LAB.data_in[50:50]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
 


    <!-- 20 direct connections coming from the the adjacent memory block located to the left of the LAB-->
    <direct name="Mem_side_sneak_LAB0" from_pin="M20K.data_out[19:0]" from_side="right" to_pin="LAB.data_in[30:11]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 20 direct connections coming from the the adjacent memory block located to the right of the LAB-->
    <direct name="Mem_side_sneak_LAB1" from_pin="M20K.data_out[39:20]" from_side="left" to_pin="LAB.data_in[50:31]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>

    <!-- 30 direct connections coming from the the adjacent DSP located to the left of the LAB-->
    <direct name="DSP_side_sneak_LAB0" from_pin="DSP.result[29:0]" from_side="right" to_pin="LAB.data_in[29:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 30 direct connections coming from the the adjacent DSP located to the right of the LAB-->
    <direct name="DSP_side_sneak_LAB1" from_pin="DSP.result[59:30]" from_side="left" to_pin="LAB.data_in[59:30]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
  
    <!-- 24 direct connections coming from the the adjacent iolane located to the left of the LAB-->
    <!-- all the LAB lines that don't have self-sneaks have an input coming from adjacent block - plus some of the LAB lines that have a self-sneak-->
    <direct name="iolane_side_sneak_LAB_0" from_pin="iolane.core_out[23:0]" from_side="right" to_pin="LAB.data_in[34:11]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>

    <!-- 24 direct connections coming from the the adjacent iolane located to the right of the LAB-->
    <!-- all the LAB lines that don't have self-sneaks have an input coming from adjacent block - plus some of the LAB lines that have a self-sneak-->
    <direct name="iolane_side_sneak_LAB_1" from_pin="iolane.core_out[23:0]" from_side="left" to_pin="LAB.data_in[58:35]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
 
    <!-- ############### Directlinks to DSPs ############### -->

    <!-- 20 direct connections coming from the odd pin numbers of the adjacent LAB located to the left of the DSP-->
    <direct name="LAB_side_sneak_DSP_1" from_pin="LAB.data_out[1:1]" from_side="right" to_pin="DSP.dspin[1:1]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_3" from_pin="LAB.data_out[3:3]" from_side="right" to_pin="DSP.dspin[3:3]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_5" from_pin="LAB.data_out[5:5]" from_side="right" to_pin="DSP.dspin[5:5]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_7" from_pin="LAB.data_out[7:7]" from_side="right" to_pin="DSP.dspin[7:7]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_9" from_pin="LAB.data_out[9:9]" from_side="right" to_pin="DSP.dspin[9:9]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_11" from_pin="LAB.data_out[11:11]" from_side="right" to_pin="DSP.dspin[11:11]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_13" from_pin="LAB.data_out[13:13]" from_side="right" to_pin="DSP.dspin[13:13]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_15" from_pin="LAB.data_out[15:15]" from_side="right" to_pin="DSP.dspin[15:15]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_17" from_pin="LAB.data_out[17:17]" from_side="right" to_pin="DSP.dspin[17:17]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_19" from_pin="LAB.data_out[19:19]" from_side="right" to_pin="DSP.dspin[19:19]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_21" from_pin="LAB.data_out[21:21]" from_side="right" to_pin="DSP.dspin[21:21]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_23" from_pin="LAB.data_out[23:23]" from_side="right" to_pin="DSP.dspin[23:23]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_25" from_pin="LAB.data_out[25:25]" from_side="right" to_pin="DSP.dspin[25:25]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_27" from_pin="LAB.data_out[27:27]" from_side="right" to_pin="DSP.dspin[27:27]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_29" from_pin="LAB.data_out[29:29]" from_side="right" to_pin="DSP.dspin[29:29]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_31" from_pin="LAB.data_out[31:31]" from_side="right" to_pin="DSP.dspin[31:31]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_33" from_pin="LAB.data_out[33:33]" from_side="right" to_pin="DSP.dspin[33:33]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_35" from_pin="LAB.data_out[35:35]" from_side="right" to_pin="DSP.dspin[35:35]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_37" from_pin="LAB.data_out[37:37]" from_side="right" to_pin="DSP.dspin[37:37]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_39" from_pin="LAB.data_out[39:39]" from_side="right" to_pin="DSP.dspin[39:39]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>

    <!-- 20 direct connections coming from the even pin numbers of the adjacent LAB located to the right of the DSP-->
    <direct name="LAB_side_sneak_DSP_0" from_pin="LAB.data_out[0:0]" from_side="left" to_pin="DSP.dspin[0:0]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_2" from_pin="LAB.data_out[2:2]" from_side="left" to_pin="DSP.dspin[2:2]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_4" from_pin="LAB.data_out[4:4]" from_side="left" to_pin="DSP.dspin[4:4]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_6" from_pin="LAB.data_out[6:6]" from_side="left" to_pin="DSP.dspin[6:6]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_8" from_pin="LAB.data_out[8:8]" from_side="left" to_pin="DSP.dspin[8:8]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_10" from_pin="LAB.data_out[10:10]" from_side="left" to_pin="DSP.dspin[10:10]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_12" from_pin="LAB.data_out[12:12]" from_side="left" to_pin="DSP.dspin[12:12]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_14" from_pin="LAB.data_out[14:14]" from_side="left" to_pin="DSP.dspin[14:14]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_16" from_pin="LAB.data_out[16:16]" from_side="left" to_pin="DSP.dspin[16:16]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_18" from_pin="LAB.data_out[18:18]" from_side="left" to_pin="DSP.dspin[18:18]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_20" from_pin="LAB.data_out[20:20]" from_side="left" to_pin="DSP.dspin[20:20]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_22" from_pin="LAB.data_out[22:22]" from_side="left" to_pin="DSP.dspin[22:22]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_24" from_pin="LAB.data_out[24:24]" from_side="left" to_pin="DSP.dspin[24:24]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_26" from_pin="LAB.data_out[26:26]" from_side="left" to_pin="DSP.dspin[26:26]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_28" from_pin="LAB.data_out[28:28]" from_side="left" to_pin="DSP.dspin[28:28]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_30" from_pin="LAB.data_out[30:30]" from_side="left" to_pin="DSP.dspin[30:30]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_32" from_pin="LAB.data_out[32:32]" from_side="left" to_pin="DSP.dspin[32:32]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_34" from_pin="LAB.data_out[34:34]" from_side="left" to_pin="DSP.dspin[34:34]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_36" from_pin="LAB.data_out[36:36]" from_side="left" to_pin="DSP.dspin[36:36]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_DSP_38" from_pin="LAB.data_out[38:38]" from_side="left" to_pin="DSP.dspin[38:38]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
 
    <!-- 40 direct connections coming from the the adjacent memory block located to the left of the DSP-->
    <direct name="Mem_side_sneak_DSP0" from_pin="M20K.data_out[39:0]" from_side="right" to_pin="DSP.dspin[153:114]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 40 direct connections coming from the the adjacent memory block located to the right of the DSP-->
    <direct name="Mem_side_sneak_DSP1" from_pin="M20K.data_out[39:0]" from_side="left" to_pin="DSP.dspin[79:40]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>

    <!-- 74 direct connections coming from the the adjacent DSP located to the left of the DSP-->
    <direct name="DSP_side_sneak_DSP0" from_pin="DSP.result[73:0]" from_side="right" to_pin="DSP.dspin[187:114]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 74 direct connections coming from the the adjacent DSP located to the right of the DSP-->
    <direct name="DSP_side_sneak_DSP1" from_pin="DSP.result[73:0]" from_side="left" to_pin="DSP.dspin[113:40]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>

    <!-- 24 direct connections coming from the the adjacent iolane located to the left of the DSP-->
    <direct name="iolane_side_sneak_LAB0" from_pin="iolane.core_out[23:0]" from_side="right" to_pin="DSP.dspin[137:114]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 24 direct connections coming from the the adjacent iolane located to the right of the DSP-->
    <direct name="iolane_side_sneak_LAB1" from_pin="iolane.core_out[23:0]" from_side="left" to_pin="DSP.dspin[63:40]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>


    <!-- ############### Directlinks to RAMs ############### -->
    <!-- To the extent possible, the directlinks are spread evenly across the 120 RAM lines -->
    <!-- 
      since a partial crossbar is implemented for memory blocks 
      the directlinks are created such that almost the same number of directlinks
      are fed into every group of memory lines that constitute a pattern 
    -->

    <!-- 20 direct connections coming from the odd pin numbers of the adjacent LAB located to the left of the RAM-->
    <direct name="LAB_side_sneak_Mem_1" from_pin="LAB.data_out[1:1]" from_side="right" to_pin="M20K.data_addr_control_in[0:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_3" from_pin="LAB.data_out[3:3]" from_side="right" to_pin="M20K.data_addr_control_in[18:18]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_5" from_pin="LAB.data_out[5:5]" from_side="right" to_pin="M20K.data_addr_control_in[36:36]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_7" from_pin="LAB.data_out[7:7]" from_side="right" to_pin="M20K.data_addr_control_in[54:54]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_9" from_pin="LAB.data_out[9:9]" from_side="right" to_pin="M20K.data_addr_control_in[72:72]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_11" from_pin="LAB.data_out[11:11]" from_side="right" to_pin="M20K.data_addr_control_in[90:90]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_13" from_pin="LAB.data_out[13:13]" from_side="right" to_pin="M20K.data_addr_control_in[108:108]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_15" from_pin="LAB.data_out[15:15]" from_side="right" to_pin="M20K.data_addr_control_in[1:1]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_17" from_pin="LAB.data_out[17:17]" from_side="right" to_pin="M20K.data_addr_control_in[19:19]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_19" from_pin="LAB.data_out[19:19]" from_side="right" to_pin="M20K.data_addr_control_in[37:37]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_21" from_pin="LAB.data_out[21:21]" from_side="right" to_pin="M20K.data_addr_control_in[55:55]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_23" from_pin="LAB.data_out[23:23]" from_side="right" to_pin="M20K.data_addr_control_in[73:73]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_25" from_pin="LAB.data_out[25:25]" from_side="right" to_pin="M20K.data_addr_control_in[91:91]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_27" from_pin="LAB.data_out[27:27]" from_side="right" to_pin="M20K.data_addr_control_in[109:109]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_29" from_pin="LAB.data_out[29:29]" from_side="right" to_pin="M20K.data_addr_control_in[2:2]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_31" from_pin="LAB.data_out[31:31]" from_side="right" to_pin="M20K.data_addr_control_in[20:20]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_33" from_pin="LAB.data_out[33:33]" from_side="right" to_pin="M20K.data_addr_control_in[38:38]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_35" from_pin="LAB.data_out[35:35]" from_side="right" to_pin="M20K.data_addr_control_in[56:56]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_37" from_pin="LAB.data_out[37:37]" from_side="right" to_pin="M20K.data_addr_control_in[74:74]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_39" from_pin="LAB.data_out[39:39]" from_side="right" to_pin="M20K.data_addr_control_in[92:92]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 20 direct connections coming from the even pin numbers of the adjacent LAB located to the right of the RAM-->
    <direct name="LAB_side_sneak_Mem_0" from_pin="LAB.data_out[0:0]" from_side="left" to_pin="M20K.data_addr_control_in[17:17]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_2" from_pin="LAB.data_out[2:2]" from_side="left" to_pin="M20K.data_addr_control_in[35:35]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_4" from_pin="LAB.data_out[4:4]" from_side="left" to_pin="M20K.data_addr_control_in[53:53]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_6" from_pin="LAB.data_out[6:6]" from_side="left" to_pin="M20K.data_addr_control_in[71:71]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_8" from_pin="LAB.data_out[8:8]" from_side="left" to_pin="M20K.data_addr_control_in[89:89]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_10" from_pin="LAB.data_out[10:10]" from_side="left" to_pin="M20K.data_addr_control_in[107:107]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_12" from_pin="LAB.data_out[12:12]" from_side="left" to_pin="M20K.data_addr_control_in[119:119]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_14" from_pin="LAB.data_out[14:14]" from_side="left" to_pin="M20K.data_addr_control_in[16:16]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_16" from_pin="LAB.data_out[16:16]" from_side="left" to_pin="M20K.data_addr_control_in[34:34]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_18" from_pin="LAB.data_out[18:18]" from_side="left" to_pin="M20K.data_addr_control_in[52:52]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_20" from_pin="LAB.data_out[20:20]" from_side="left" to_pin="M20K.data_addr_control_in[70:70]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_22" from_pin="LAB.data_out[22:22]" from_side="left" to_pin="M20K.data_addr_control_in[88:88]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_24" from_pin="LAB.data_out[24:24]" from_side="left" to_pin="M20K.data_addr_control_in[106:106]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_26" from_pin="LAB.data_out[26:26]" from_side="left" to_pin="M20K.data_addr_control_in[118:118]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_28" from_pin="LAB.data_out[28:28]" from_side="left" to_pin="M20K.data_addr_control_in[15:15]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_30" from_pin="LAB.data_out[30:30]" from_side="left" to_pin="M20K.data_addr_control_in[33:33]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_32" from_pin="LAB.data_out[32:32]" from_side="left" to_pin="M20K.data_addr_control_in[51:51]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_34" from_pin="LAB.data_out[34:34]" from_side="left" to_pin="M20K.data_addr_control_in[69:69]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_36" from_pin="LAB.data_out[36:36]" from_side="left" to_pin="M20K.data_addr_control_in[87:87]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_Mem_38" from_pin="LAB.data_out[38:38]" from_side="left" to_pin="M20K.data_addr_control_in[105:105]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
 
    <!-- 40 direct connections coming from the the adjacent memory block located to the left of the M20K-->
    <direct name="Mem_side_sneak_Mem0" from_pin="M20K.data_out[6:0]" from_side="right" to_pin="M20K.data_addr_control_in[6:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem1" from_pin="M20K.data_out[13:7]" from_side="right" to_pin="M20K.data_addr_control_in[24:18]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem2" from_pin="M20K.data_out[20:14]" from_side="right" to_pin="M20K.data_addr_control_in[42:36]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem3" from_pin="M20K.data_out[27:21]" from_side="right" to_pin="M20K.data_addr_control_in[60:54]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem4" from_pin="M20K.data_out[34:28]" from_side="right" to_pin="M20K.data_addr_control_in[78:72]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem5" from_pin="M20K.data_out[39:34]" from_side="right" to_pin="M20K.data_addr_control_in[95:90]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 40 direct connections coming from the the adjacent memory block located to the right of the M20K-->
    <direct name="Mem_side_sneak_Mem6" from_pin="M20K.data_out[6:0]" from_side="left" to_pin="M20K.data_addr_control_in[17:11]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem7" from_pin="M20K.data_out[13:7]" from_side="left" to_pin="M20K.data_addr_control_in[35:29]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem8" from_pin="M20K.data_out[20:14]" from_side="left" to_pin="M20K.data_addr_control_in[53:47]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem9" from_pin="M20K.data_out[27:21]" from_side="left" to_pin="M20K.data_addr_control_in[71:65]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem10" from_pin="M20K.data_out[34:28]" from_side="left" to_pin="M20K.data_addr_control_in[89:83]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="Mem_side_sneak_Mem11" from_pin="M20K.data_out[39:34]" from_side="left" to_pin="M20K.data_addr_control_in[119:114]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>


    <!-- 74 direct connections coming from the the adjacent DSP located to the left of the M20K-->
    <direct name="DSP_side_sneak_Mem0" from_pin="DSP.result[11:0]" from_side="right" to_pin="M20K.data_addr_control_in[11:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem1" from_pin="DSP.result[23:12]" from_side="right" to_pin="M20K.data_addr_control_in[29:18]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem2" from_pin="DSP.result[35:24]" from_side="right" to_pin="M20K.data_addr_control_in[47:36]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem3" from_pin="DSP.result[47:36]" from_side="right" to_pin="M20K.data_addr_control_in[65:54]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem4" from_pin="DSP.result[59:48]" from_side="right" to_pin="M20K.data_addr_control_in[83:72]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem5" from_pin="DSP.result[73:60]" from_side="right" to_pin="M20K.data_addr_control_in[103:90]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 74 direct connections coming from the the adjacent DSP located to the left of the M20K-->
    <direct name="DSP_side_sneak_Mem6" from_pin="DSP.result[11:0]" from_side="left" to_pin="M20K.data_addr_control_in[17:6]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem7" from_pin="DSP.result[23:12]" from_side="left" to_pin="M20K.data_addr_control_in[35:24]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem8" from_pin="DSP.result[35:24]" from_side="left" to_pin="M20K.data_addr_control_in[53:42]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem9" from_pin="DSP.result[47:36]" from_side="left" to_pin="M20K.data_addr_control_in[71:60]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem10" from_pin="DSP.result[59:48]" from_side="left" to_pin="M20K.data_addr_control_in[89:78]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="DSP_side_sneak_Mem11" from_pin="DSP.result[73:60]" from_side="left" to_pin="M20K.data_addr_control_in[119:106]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
      
    <!-- 24 direct connections coming from the the adjacent iolane located to the left of the M20K-->
    <direct name="iolane_side_sneak_Mem0" from_pin="iolane.core_out[3:0]" from_side="right" to_pin="M20K.data_addr_control_in[3:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem1" from_pin="iolane.core_out[7:4]" from_side="right" to_pin="M20K.data_addr_control_in[21:18]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem2" from_pin="iolane.core_out[11:8]" from_side="right" to_pin="M20K.data_addr_control_in[39:36]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem3" from_pin="iolane.core_out[15:12]" from_side="right" to_pin="M20K.data_addr_control_in[57:54]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem4" from_pin="iolane.core_out[19:16]" from_side="right" to_pin="M20K.data_addr_control_in[75:72]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem5" from_pin="iolane.core_out[23:20]" from_side="right" to_pin="M20K.data_addr_control_in[93:90]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 24 direct connections coming from the the adjacent iolane located to the left of the M20K-->
    <direct name="iolane_side_sneak_Mem6" from_pin="iolane.core_out[3:0]" from_side="left" to_pin="M20K.data_addr_control_in[17:14]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem7" from_pin="iolane.core_out[7:4]" from_side="left" to_pin="M20K.data_addr_control_in[35:32]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem8" from_pin="iolane.core_out[11:8]" from_side="left" to_pin="M20K.data_addr_control_in[53:50]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem9" from_pin="iolane.core_out[15:12]" from_side="left" to_pin="M20K.data_addr_control_in[71:68]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem10" from_pin="iolane.core_out[19:16]" from_side="left" to_pin="M20K.data_addr_control_in[89:86]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="iolane_side_sneak_Mem11" from_pin="iolane.core_out[23:20]" from_side="left" to_pin="M20K.data_addr_control_in[119:116]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
        

    <!-- ############### Directlinks to iolanes ############### -->

    <!-- 20 direct connections coming from the odd pin numbers of the adjacent LAB located to the left of the DSP-->
    <direct name="LAB_side_sneak_iolane_1" from_pin="LAB.data_out[1:1]" from_side="right" to_pin="iolane.core_in[1:1]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_3" from_pin="LAB.data_out[3:3]" from_side="right" to_pin="iolane.core_in[3:3]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_5" from_pin="LAB.data_out[5:5]" from_side="right" to_pin="iolane.core_in[5:5]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_7" from_pin="LAB.data_out[7:7]" from_side="right" to_pin="iolane.core_in[7:7]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_9" from_pin="LAB.data_out[9:9]" from_side="right" to_pin="iolane.core_in[9:9]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_11" from_pin="LAB.data_out[11:11]" from_side="right" to_pin="iolane.core_in[11:11]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_13" from_pin="LAB.data_out[13:13]" from_side="right" to_pin="iolane.core_in[13:13]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_15" from_pin="LAB.data_out[15:15]" from_side="right" to_pin="iolane.core_in[15:15]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_17" from_pin="LAB.data_out[17:17]" from_side="right" to_pin="iolane.core_in[17:17]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_19" from_pin="LAB.data_out[19:19]" from_side="right" to_pin="iolane.core_in[19:19]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_21" from_pin="LAB.data_out[21:21]" from_side="right" to_pin="iolane.core_in[21:21]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_23" from_pin="LAB.data_out[23:23]" from_side="right" to_pin="iolane.core_in[23:23]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_25" from_pin="LAB.data_out[25:25]" from_side="right" to_pin="iolane.core_in[25:25]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_27" from_pin="LAB.data_out[27:27]" from_side="right" to_pin="iolane.core_in[27:27]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_29" from_pin="LAB.data_out[29:29]" from_side="right" to_pin="iolane.core_in[29:29]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_31" from_pin="LAB.data_out[31:31]" from_side="right" to_pin="iolane.core_in[31:31]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_33" from_pin="LAB.data_out[33:33]" from_side="right" to_pin="iolane.core_in[33:33]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_35" from_pin="LAB.data_out[35:35]" from_side="right" to_pin="iolane.core_in[35:35]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_37" from_pin="LAB.data_out[37:37]" from_side="right" to_pin="iolane.core_in[37:37]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_39" from_pin="LAB.data_out[39:39]" from_side="right" to_pin="iolane.core_in[39:39]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>

    <!-- 20 direct connections coming from the even pin numbers of the adjacent LAB located to the right of the DSP-->
    <direct name="LAB_side_sneak_iolane_0" from_pin="LAB.data_out[0:0]" from_side="left" to_pin="iolane.core_in[0:0]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_2" from_pin="LAB.data_out[2:2]" from_side="left" to_pin="iolane.core_in[2:2]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_4" from_pin="LAB.data_out[4:4]" from_side="left" to_pin="iolane.core_in[4:4]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_6" from_pin="LAB.data_out[6:6]" from_side="left" to_pin="iolane.core_in[6:6]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_8" from_pin="LAB.data_out[8:8]" from_side="left" to_pin="iolane.core_in[8:8]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_10" from_pin="LAB.data_out[10:10]" from_side="left" to_pin="iolane.core_in[10:10]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_12" from_pin="LAB.data_out[12:12]" from_side="left" to_pin="iolane.core_in[12:12]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_14" from_pin="LAB.data_out[14:14]" from_side="left" to_pin="iolane.core_in[14:14]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_16" from_pin="LAB.data_out[16:16]" from_side="left" to_pin="iolane.core_in[16:16]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_18" from_pin="LAB.data_out[18:18]" from_side="left" to_pin="iolane.core_in[18:18]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_20" from_pin="LAB.data_out[20:20]" from_side="left" to_pin="iolane.core_in[20:20]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_22" from_pin="LAB.data_out[22:22]" from_side="left" to_pin="iolane.core_in[22:22]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_24" from_pin="LAB.data_out[24:24]" from_side="left" to_pin="iolane.core_in[24:24]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_26" from_pin="LAB.data_out[26:26]" from_side="left" to_pin="iolane.core_in[26:26]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_28" from_pin="LAB.data_out[28:28]" from_side="left" to_pin="iolane.core_in[28:28]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_30" from_pin="LAB.data_out[30:30]" from_side="left" to_pin="iolane.core_in[30:30]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_32" from_pin="LAB.data_out[32:32]" from_side="left" to_pin="iolane.core_in[32:32]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_34" from_pin="LAB.data_out[34:34]" from_side="left" to_pin="iolane.core_in[34:34]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_36" from_pin="LAB.data_out[36:36]" from_side="left" to_pin="iolane.core_in[36:36]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>
    <direct name="LAB_side_sneak_iolane_38" from_pin="LAB.data_out[38:38]" from_side="left" to_pin="iolane.core_in[38:38]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>

    <!-- 40 direct connections coming from the the adjacent memory block located to the left of the iolane-->
    <direct name="Mem_side_sneak_iolane0" from_pin="M20K.data_out[39:0]" from_side="right" to_pin="iolane.core_in[39:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 40 direct connections coming from the the adjacent memory block located to the right of the iolane-->
    <direct name="Mem_side_sneak_iolane1" from_pin="M20K.data_out[39:0]" from_side="left" to_pin="iolane.core_in[39:0]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>

    <!-- 55 direct connections coming from the the adjacent DSP located to the left of the iolane-->
    <direct name="DSP_side_sneak_iolane0" from_pin="DSP.result[54:0]" from_side="right" to_pin="iolane.core_in[54:0]" to_side="left" x_offset="1" y_offset="0" z_offset="0"/>
    <!-- 55 direct connections coming from the the adjacent DSP located to the right of the iolane-->
    <direct name="DSP_side_sneak_iolane1" from_pin="DSP.result[54:0]" from_side="left" to_pin="iolane.core_in[54:0]" to_side="right" x_offset="-1" y_offset="0" z_offset="0"/>



  </directlist>
  <complexblocklist>

    <pb_type name="PLL">
      <input name="core_in" num_pins="40"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="2"/>

      <pb_type blif_model=".subckt fourteennm_iopll" name="iopll" num_pb="1">
        <input name="clken" num_pins="2"/>
        <input name="cnt_sel" num_pins="4"/> <!-- counter selector for dynamic phase shift -->
        <input name="dprio_address" num_pins="9"/>  <!--  Avalon-MM Interface - address of the databus for dynamic partial reconfiguration -->
        <input name="dprio_clk" num_pins="1"/>  <!--  Avalon-MM Interface - clock port for dynamic partial reconfiguration -->
        <input name="read" num_pins="1"/>  <!--  Avalon-MM Interface - indicate a read operation during dynamic partial reconfiguration -->
        <input name="write" num_pins="1"/>  <!--  Avalon-MM Interface - indicate a write operation during dynamic partial reconfiguration -->
        <input name="writedata" num_pins="8"/>  <!--  Avalon-MM Interface - data to be written to the given address during dynamic partial reconfiguration -->
        <clock name="core_refclk" num_pins="1"/> <!-- use core clock as an input reference clock -->
        <input name="csr_clk" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface - clock signal-->
        <input name="csr_en" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface - enable signal-->
        <input name="phase_en" num_pins="1"/> 
        <input name="csr_in" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface -->
        <input name="dprio_rst_n" num_pins="1"/> <!--  Avalon-MM Interface - reset port for dynamic partial reconfiguration -->
        <input name="dps_rst_n" num_pins="1"/> <!--  dynamic phase shift reset -->
        <input name="extswitch" num_pins="1"/> <!--  controlling clock switchover -->
        <input name="fbclk_in" num_pins="1"/> <!--  feedback clock used for external feedback compensation -->
        <input name="fblvds_in" num_pins="1"/> <!--  feedback clock used for LVDS compensation -->
        <input name="refclk" num_pins="4"/> <!--  reference clock source driving the IO PLL -->
        <input name="mdio_dis" num_pins="1"/>
        <input name="rst_n" num_pins="1"/>
        <input name="num_phase_shifts" num_pins="3"/> <!--  number of phase shifts per dynamic phase shift operation -->
        <input name="pfden" num_pins="1"/> <!--  enabling dynamic phase shift operation -->
        <input name="pipeline_global_en_n" num_pins="1"/>
        <input name="pma_csr_test_dis" num_pins="1"/>  <!-- disable PMA CSR test  -->
        <input name="pll_cascade_in" num_pins="1"/> <!-- cascade input from IO PLL in the same IO column  -->
        <input name="scan_mode_n" num_pins="1"/> <!-- dynamic phase shift clock -->
        <input name="scan_shift_n" num_pins="1"/>
        <input name="uc_cal_addr" num_pins="20"/>
        <input name="uc_cal_clk" num_pins="1"/>
        <input name="uc_cal_read" num_pins="1"/>
        <input name="uc_cal_write" num_pins="1"/>
        <input name="uc_cal_writedata" num_pins="8"/>  
        <input name="up_dn" num_pins="1"/> <!-- direction of phase shift -->
        <input name="user_mode" num_pins="1"/> <!-- enable user mode  -->
        <input name="zdb_in" num_pins="1"/> <!-- zero delay buffer compensation feedback -->

        <output name="block_select" num_pins="1"/>
        <output name="clk0_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clk1_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clksel" num_pins="1"/>
        <output name="cal_ok" num_pins="1"/> <!-- indicates the calibration status -->
        <output name="core_avl_busy" num_pins="1"/>
        <output name="core_cal_done" num_pins="1"/>
        <output name="readdata" num_pins="8"/> <!-- Avalon-MM Interface - data read from the given address during dynamic partial reconfiguration -->
        <output name="csr_out" num_pins="1"/> <!--Avalon-MM control-and-status register (CSR) agent interface !-->
        <output name="extclk_output" num_pins="2"/> <!-- external clock output port -->
        <output name="extclk_dft" num_pins="2"/>
        <output name="fblvds_out" num_pins="1"/>
        <output name="lf_reset" num_pins="1"/> <!-- loop filter reset -->
        <output name="loaden" num_pins="2"/> <!-- signal to the LVDS receiver -->
        <output name="lock" num_pins="1"/> <!-- indicate wether the PLL is locked - signal to the core logic -->
        <output name="lock2io12lane0" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 0 -->
        <output name="lock2io12lane1" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 1 -->
        <output name="lock2io12lane2" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 2 -->
        <output name="lock2io12lane3" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 3 -->
        <output name="lock2iohmc" num_pins="1"/> <!-- indicate wether the PLL is locked - going to Hybrid Memory Cube (HMC)-->
        <output name="lvds_clk" num_pins="2"/> <!-- the output clk feeding the LVDS SERDES block -->
        <output name="phase_done" num_pins="1"/> <!-- indicates completion of dynamic phase shift operation -->
        <output name="pll_cascade_out" num_pins="1"/> <!-- the output from the source PLL feeding the downstream PLL in cascade mode -->
        <output name="pll_pd" num_pins="1"/> <!-- indicating power down - going to the exteral PLLs  -->
        <output name="outclk" num_pins="9"/> <!-- PLL output clocks -->
        <output name="dll_output" num_pins="1"/> <!-- going to the External Memory Interface DLL -->
        <output name="fbclk_out" num_pins="1"/> <!-- output of the M counter -->
        <output name="uc_cal_readdata" num_pins="8"/>
        <output name="vcop_en" num_pins="1"/>
        <output name="vcoph" num_pins="8"/> <!-- VCO output clocks -->
        <output name="iopll_out_sig1" num_pins="1"/>
        <output name="iopll_out_sig2" num_pins="1"/>
      </pb_type>
       <interconnect>
       
        <complete input="PLL.core_in" name="core_to_pll" output="iopll.refclk iopll.clken iopll.cnt_sel iopll.dprio_address iopll.dprio_clk iopll.read iopll.write iopll.writedata iopll.csr_clk iopll.csr_en iopll.csr_in iopll.dprio_rst_n iopll.dps_rst_n iopll.extswitch iopll.fbclk_in iopll.fblvds_in iopll.mdio_dis iopll.rst_n  iopll.phase_en iopll.num_phase_shifts iopll.pfden iopll.pipeline_global_en_n iopll.pma_csr_test_dis iopll.pll_cascade_in iopll.scan_mode_n iopll.scan_shift_n iopll.uc_cal_addr iopll.uc_cal_clk iopll.uc_cal_read  iopll.uc_cal_write iopll.uc_cal_writedata iopll.up_dn iopll.user_mode iopll.zdb_in"/>

        <complete input="PLL.clk" name="pll_clock" output="iopll.core_refclk"/>

        <complete input="iopll.readdata iopll.lvds_clk iopll.csr_out iopll.block_select iopll.clk0_bad iopll.clk1_bad iopll.clksel iopll.cal_ok iopll.core_avl_busy iopll.core_cal_done iopll.extclk_output iopll.extclk_dft iopll.fblvds_out iopll.lf_reset iopll.loaden iopll.lock iopll.lock2io12lane0 iopll.lock2io12lane1 iopll.lock2io12lane2 iopll.lock2io12lane3 iopll.lock2iohmc iopll.phase_done iopll.pll_cascade_out iopll.pll_pd iopll.outclk iopll.dll_output iopll.fbclk_out iopll.uc_cal_readdata iopll.vcop_en iopll.vcoph iopll.iopll_out_sig1 iopll.iopll_out_sig2" name="pll_to_core" output="PLL.core_out"/>
      </interconnect>
    </pb_type>

    <pb_type name="clock_gate">
      <input name="inclk" num_pins="1"/>
      <input name="enable" num_pins="1"/>
      <output name="outclk" num_pins="1"/>

      <pb_type blif_model=".subckt fourteennm_clk_gate" name="clk_gate" num_pb="1">
        <clock name="inclk" num_pins="1"/>
        <input name="enable" num_pins="1"/>
        <output name="outclk" num_pins="1"/> 
      </pb_type>
       <interconnect>    
        <direct input="clock_gate.inclk" name="core_to_clk_gate" output="clk_gate.inclk"/>
        <direct input="clock_gate.enable" name="core_to_clk_gate2" output="clk_gate.enable"/>
        <direct input="clk_gate.outclk" name="clk_gate_to_core" output="clock_gate.outclk"/>
      </interconnect>
    </pb_type>

    <pb_type name="clock_div">
      <input name="inclk" num_pins="1"/>
      <output name="clock_div_out" num_pins="3"/>

      <pb_type blif_model=".subckt fourteennm_clk_divider" name="clk_div" num_pb="1">
        <clock name="inclk" num_pins="1"/>
        <output name="clock_div1" num_pins="1"/> 
        <output name="clock_div2" num_pins="1"/>
        <output name="clock_div4" num_pins="1"/>
      </pb_type>
       <interconnect>    
        <complete input="clock_div.inclk" name="core_to_clk_div" output="clk_div.inclk"/>
        <complete input="clk_div.clock_div1 clk_div.clock_div2 clk_div.clock_div4" name="clk_div_to_core" output="clock_div.clock_div_out"/>
      </interconnect>
    </pb_type>


    <pb_type name="LAB">
      <input name="data_in" num_pins="60" equivalent="full"/>
      <input name="control_in" num_pins="5" equivalent="full"/>
      <input name="cin" num_pins="1" equivalent="none"/>
      <output name="data_out" num_pins="40" equivalent="full"/>
      <output name="cout" num_pins="1" equivalent="none"/>
      <clock name="clk" num_pins="2"/>
      <mode name="LAB">
        <pb_type name="alm" num_pb="10">
          <input name="data_in" num_pins="10"/>
          <input name="control" num_pins="5"/>
          <input name="cin" num_pins="1"/>
          <output name="data_out" num_pins="4"/>
          <output name="cout" num_pins="1"/>
          <clock name="clock" num_pins="1"/>
          <mode name="alm">
            <pb_type name="comb_block" num_pb="1">
              <input name="lin" num_pins="8"/>
              <input name="cin" num_pins="1"/>
              <output name="combout" num_pins="2"/>
              <output name="sumout" num_pins="2"/>
              <output name="cout" num_pins="1"/>
              <mode name="comb_block">
                  <pb_type name="lut" num_pb="2">
                    <input name="lin" num_pins="8"/>
                    <input name="cin" num_pins="1"/>
                    <output name="combout" num_pins="1"/>
                    <output name="sumout" num_pins="1"/>
                    <output name="cout" num_pins="1"/>
                    <mode name="fourteennm_lcell">
                      <pb_type blif_model=".subckt fourteennm_lcell_comb" name="lcell_comb" num_pb="1">
                        <input name="dataa" num_pins="1"/>
                        <input name="datab" num_pins="1"/>
                        <input name="datac" num_pins="1"/>
                        <input name="datad" num_pins="1"/>
                        <input name="datae" num_pins="1"/>
                        <input name="dataf" num_pins="1"/>
                        <input name="datag" num_pins="1"/>
                        <input name="datah" num_pins="1"/>
                        <input name="cin" num_pins="1"/>
                        <output name="combout" num_pins="1"/>
                        <output name="sumout" num_pins="1"/>
                        <output name="cout" num_pins="1"/>


                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.combout"/>
                        <delay_constant max="197e-12" min="197e-12" in_port="lcell_comb.datab" out_port="lcell_comb.combout"/>
                        <delay_constant max="78e-12" min="78e-12" in_port="lcell_comb.datac" out_port="lcell_comb.combout"/>
                        <delay_constant max="60e-12" min="60e-12" in_port="lcell_comb.datad" out_port="lcell_comb.combout"/>
                        <delay_constant max="34e-12" min="34e-12" in_port="lcell_comb.datae" out_port="lcell_comb.combout"/>
                        <delay_constant max="4e-12" min="4e-12" in_port="lcell_comb.dataf" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datag" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datah" out_port="lcell_comb.combout"/>

                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.sumout"/>
                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.datab" out_port="lcell_comb.sumout"/>
                        <delay_constant max="122e-12" min="122e-12" in_port="lcell_comb.datac" out_port="lcell_comb.sumout"/>
                        <delay_constant max="103e-12" min="103e-12" in_port="lcell_comb.datad" out_port="lcell_comb.sumout"/>
                        <delay_constant max="67e-12" min="67e-12" in_port="lcell_comb.cin" out_port="lcell_comb.sumout"/>

                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.cout"/>
                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.datab" out_port="lcell_comb.cout"/>
                        <delay_constant max="205e-12" min="205e-12" in_port="lcell_comb.datac" out_port="lcell_comb.cout"/>
                        <delay_constant max="249e-12" min="249e-12" in_port="lcell_comb.datad" out_port="lcell_comb.cout"/>
                        <delay_constant max="40e-12" min="40e-12" in_port="lcell_comb.cin" out_port="lcell_comb.cout"/>
 
                      </pb_type>
                      <interconnect>
                        <!-- LUT inputs -->
                        <direct input="lut.lin[0]" name="in_comp1" output="lcell_comb.dataa"/>
                        <direct input="lut.lin[1]" name="in_comp2" output="lcell_comb.datab"/>
                        <direct input="lut.lin[2]" name="in_comp3" output="lcell_comb.datac"/>
                        <direct input="lut.lin[3]" name="in_comp4" output="lcell_comb.datad"/>
                        <direct input="lut.lin[4]" name="in_comp5" output="lcell_comb.datae"/>
                        <direct input="lut.lin[5]" name="in_comp6" output="lcell_comb.dataf"/>
                        <direct input="lut.lin[6]" name="in_comp7" output="lcell_comb.datag"/>
                        <direct input="lut.lin[7]" name="in_comp8" output="lcell_comb.datah"/>
                        <!-- LUT outputs -->
                        <direct input="lcell_comb.combout" name="out_comp1" output="lut.combout">
                          <!-- <pack_pattern name="LUT_FF" in_port="lcell_comb.combout" out_port="lut.combout"/> -->
                        </direct>
                        <direct input="lcell_comb.sumout" name="out_comp2" output="lut.sumout">
                          <!-- <pack_pattern name="LUT_FF" in_port="lcell_comb.sumout" out_port="lut.sumout"/> -->
                        </direct>
                        <!-- LUT carry chain -->
                        <direct input="lut.cin" name="lut_cin" output="lcell_comb.cin">
                          <pack_pattern name="LAB_carry_chain" in_port="lut.cin" out_port="lcell_comb.cin"/>
                        </direct>
                        <direct input="lcell_comb.cout" name="out_comp3" output="lut.cout">
                          <pack_pattern name="LAB_carry_chain" in_port="lcell_comb.cout" out_port="lut.cout"/>
                        </direct>
                      </interconnect>
                    </mode>
                    <mode name="names_lut">
                      <pb_type blif_model=".names" class="lut" name="lut6" num_pb="1">
                        <input name="in" num_pins="6" port_class="lut_in"/>
                        <output name="out" num_pins="1" port_class="lut_out"/>

                        <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                      </delay_matrix>
                      <delay_matrix type="min" in_port="lut6.in" out_port="lut6.out">
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                      </delay_matrix>
                      </pb_type>


                      <interconnect>
                        <complete input="lut.lin" name="l_complete1" output="lut6.in[5:0]"/>
                        <complete input="lut6.out" name="l_complete2" output="lut.sumout lut.combout"/>
                      </interconnect>
                    </mode>
                  </pb_type>
                  <interconnect>
                    <!-- Inputs to the LUTs -->
                    <complete input="comb_block.lin" name="in_lut0" output="lut[0].lin"/>
                    <complete input="comb_block.lin" name="in_lut1" output="lut[1].lin"/>
                    <!-- Combinational Block Carry Chain -->
                    <direct input="comb_block.cin" name="comb_block_cin" output="lut[0].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="comb_block.cin" out_port="lut[0].cin"/>
                    </direct>
                    <direct input="lut[0].cout" name="lut_to_lut_carry" output="lut[1].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[0].cout" out_port="lut[1].cin"/>
                    </direct>
                    <direct input="lut[1].cout" name="alm_cout" output="comb_block.cout">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[1].cout" out_port="comb_block.cout"/>
                    </direct>
                    <!-- Outputs to the Combinational Block -->
                    <direct input="lut[0].combout" name="lut0_comb" output="comb_block.combout[0]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[0].combout" out_port="comb_block.combout[0]"/> -->
                    </direct>
                    <direct input="lut[1].combout" name="lut1_comb" output=" comb_block.combout[1]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[1].combout" out_port="comb_block.combout[1]"/> -->
                    </direct>
                    <direct input="lut[0].sumout" name="lut0_sum" output=" comb_block.sumout[0]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[0].sumout" out_port="comb_block.sumout[0]"/> -->
                    </direct>
                    <direct input="lut[1].sumout" name="lut1_sum" output=" comb_block.sumout[1]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[1].sumout" out_port="comb_block.sumout[1]"/> -->
                    </direct>
                  </interconnect>
              </mode>
              
            </pb_type>
            <pb_type name="dff" num_pb="2">
              <input name="clrn" num_pins="1"/>
              <input name="sclr" num_pins="1"/>
              <input name="ena" num_pins="1"/>
              <input name="d" num_pins="1"/>
              <output name="q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="stratix10_ff">
                <pb_type blif_model=".subckt fourteennm_ff" name="fourteennm_ff" num_pb="1">
                  <input name="clrn" num_pins="1"/>
                  <input name="sclr" num_pins="1"/>
                  <input name="ena" num_pins="1"/>
                  <input name="d" num_pins="1"/>
                  <output name="q" num_pins="1"/>
                  <clock name="clk" num_pins="1"/>
                  <T_setup value="89e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_hold value="162e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_clock_to_Q max="283e-12" min="283e-12" port="fourteennm_ff.q" clock="clk"/>

                </pb_type>
                <interconnect>
                  <direct input="dff.clrn" name="fourteennm_ff_clrn" output="fourteennm_ff.clrn"/>
                  <direct input="dff.sclr" name="fourteennm_ff_sclr" output="fourteennm_ff.sclr"/>
                  <direct input="dff.ena" name="fourteennm_ff_ena" output="fourteennm_ff.ena"/>
                  <direct input="dff.d" name="fourteennm_ff_d" output="fourteennm_ff.d">
                    <!-- <pack_pattern name="LUT_FF" in_port="dff.d" out_port="fourteennm_ff.d"/> -->
                  </direct>
                  <direct input="fourteennm_ff.q" name="fourteennm_ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="fourteennm_ff_clk" output="fourteennm_ff.clk"/>
                </interconnect>
              </mode>
              <mode name="latch">
                <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="ff.D" clock="clk"/>
                  <T_hold value="37e-12" port="ff.D" clock="clk"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="ff.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.d" name="ff_d" output="ff.D"/>
                  <direct input="ff.Q" name="ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="ff_clk" output="ff.clk"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <!-- Inputs to LUTs -->
              <direct input="alm.data_in[2:7]" name="in_lut_2_7" output="comb_block.lin[2:7]"/>
              <mux input="alm.data_in[0] comb_block.sumout[0] dff[0].q" name="in_lut_0" output="comb_block.lin[0]"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1] dff[1].q" name="in_lut_1" output="comb_block.lin[1]"/>

              <!-- Inputs to FFs -->
              <complete input="alm.data_in[9:8]" name="in_dff" output="dff[1:0].d"/>
              <mux input="comb_block.sumout[0]" name="in_dff_0" output="dff[0].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.sumout[0]" out_port="dff[0].d"/> -->
              </mux>
              <direct input="comb_block.combout[0]" name="in_dff_1" output="dff[0].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.combout[0]" out_port="dff[0].d"/> -->
              </direct>
              <mux input=" comb_block.combout[0] comb_block.sumout[1]" name="in_dff_2" output="dff[1].d">
                
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.sumout[1]" out_port="dff[1].d"/> -->
              </mux>
              <direct input="comb_block.combout[1]" name="in_dff_3" output="dff[1].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.combout[1]" out_port="dff[1].d"/> -->
              </direct>

              <!-- ALM Outputs-->
              <mux input="dff[0].q alm.data_in[0] comb_block.combout[0] comb_block.sumout[0]" name="alm_out0" output="alm.data_out[0]"/>
              <mux input="dff[0].q alm.data_in[0] comb_block.combout[0] comb_block.sumout[0]" name="alm_out1" output="alm.data_out[1]"/>
              <mux input="dff[1].q alm.data_in[1] comb_block.combout[0] comb_block.combout[1] comb_block.sumout[1]" name="alm_out2" output="alm.data_out[2]"/>
              <mux input="dff[1].q alm.data_in[1] comb_block.combout[0] comb_block.combout[1] comb_block.sumout[1]" name="alm_out3" output="alm.data_out[3]"/>

              <!-- FF Clocks -->
              <direct input="alm.clock" name="clock_dff0" output="dff[0].clk"/>
              <direct input="alm.clock" name="clock_dff1" output="dff[1].clk"/>
              <!-- ALM Carry Chain -->
              <direct input="alm.cin" name="alm_cin" output="comb_block.cin">
                <pack_pattern name="LAB_carry_chain" in_port="alm.cin" out_port="comb_block.cin"/>
              </direct>

              <direct input="comb_block.cout" name="alm_cout" output="alm.cout">
                <pack_pattern name="LAB_carry_chain" in_port="comb_block.cout" out_port="alm.cout"/>
              </direct>

              <direct input="alm.control[4]" name="control_1_dff0" output="dff[0].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff0" output="dff[0].ena"/>
              <direct input="alm.control[3]" name="control_3_dff0" output="dff[0].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff3" output="dff[1].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff3" output="dff[1].ena"/>
              <direct input="alm.control[0]" name="control_3_dff3" output="dff[1].sclr"/>
            </interconnect>
          </mode>
        </pb_type>
        <interconnect>
          <!--LAB-ALM Interconnect-->
          <!-- LAB Input: Global Routing to ALM inputs -->
          <complete input="LAB.data_in" name="LAB_datain" output="alm[9:0].data_in">
            <delay_constant max="145e-12" min="145e-12" in_port="LAB.data_in" out_port="alm[9:0].data_in"/>
          </complete>
          <!-- ALM Outputs: directly drive global routing -->
          <complete input="alm[9:0].data_out" name="LAB_dataout" output="LAB.data_out">
            <delay_constant max="56e-12" min="56e-12" in_port="alm[9:0].data_out" out_port="LAB.data_out"/>
          </complete>   
          <!-- ALM Control Inputs -->
          <complete input="LAB.control_in" name="LAB_control" output="alm[9:0].control">
            <delay_constant max="145e-12" min="145e-12" in_port="LAB.control_in" out_port="alm[9:0].control"/>
          </complete>  
          <!-- LAB Clocks -->
          <complete input="LAB.clk" name="LAB_clock" output="alm[9:0].clock"/>
          <!-- LAB Carry Chain mid-point entry/exit points, this allows the chain to jump early to
               the next LAB, if the full chain would overuse the number of LAB inputs -->
          <!--<complete input="alm[4].cout" name="alm4_midpoint_exit_carry" output="LAB.data_out"/>-->
          <!--<complete input="LAB.data_in" name="alm5_midpoint_entry_carry" output="alm[5].cin"/>-->
          <!--LAB carry chain-->
          <direct input="LAB.cin" name="LAB_cin" output="alm[0].cin">
            <pack_pattern name="LAB_carry_chain" in_port="LAB.cin" out_port="alm[0].cin"/>
          </direct>
          <direct input="alm[0].cout" name="alm0_alm1_carry" output="alm[1].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[0].cout" out_port="alm[1].cin"/>
          </direct>
          <direct input="alm[1].cout" name="alm1_alm2_carry" output="alm[2].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[1].cout" out_port="alm[2].cin"/>
          </direct>
          <direct input="alm[2].cout" name="alm2_alm3_carry" output="alm[3].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[2].cout" out_port="alm[3].cin"/>
          </direct>
          <direct input="alm[3].cout" name="alm3_alm4_carry" output="alm[4].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[3].cout" out_port="alm[4].cin"/>
          </direct>
          <direct input="alm[4].cout" name="alm4_alm5_carry" output="alm[5].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[4].cout" out_port="alm[5].cin"/>
          </direct>
          <direct input="alm[5].cout" name="alm5_alm6_carry" output="alm[6].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[5].cout" out_port="alm[6].cin"/>
          </direct>
          <direct input="alm[6].cout" name="alm6_alm7_carry" output="alm[7].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[6].cout" out_port="alm[7].cin"/>
          </direct>
          <direct input="alm[7].cout" name="alm7_alm8_carry" output="alm[8].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[7].cout" out_port="alm[8].cin"/>
          </direct>
          <direct input="alm[8].cout" name="alm8_alm9_carry" output="alm[9].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[8].cout" out_port="alm[9].cin"/>
          </direct>
          <direct input="alm[9].cout" name="LAB_cout" output="LAB.cout">
            <pack_pattern name="LAB_carry_chain" in_port="alm[9].cout" out_port="LAB.cout"/>
          </direct>


        </interconnect>
      </mode>
    </pb_type>

    <pb_type name="LABMLAB">
      <input name="data_in" num_pins="60" equivalent="full"/>
      <input name="control_in" num_pins="5" equivalent="full"/>
      <input name="cin" num_pins="1" equivalent="none"/>
      <output name="data_out" num_pins="40" equivalent="full"/>
      <output name="cout" num_pins="1" equivalent="none"/>
      <clock name="clk" num_pins="2"/>
      <mode name="LAB">
        <pb_type name="alm" num_pb="10">
          <input name="data_in" num_pins="10"/>
          <input name="control" num_pins="5"/>
          <input name="cin" num_pins="1"/>
          <output name="data_out" num_pins="4"/>
          <output name="cout" num_pins="1"/>
          <clock name="clock" num_pins="1"/>
          <mode name="alm">
            <pb_type name="comb_block" num_pb="1">
              <input name="lin" num_pins="8"/>
              <input name="cin" num_pins="1"/>
              <output name="combout" num_pins="2"/>
              <output name="sumout" num_pins="2"/>
              <output name="cout" num_pins="1"/>
              <mode name="comb_block">
                  <pb_type name="lut" num_pb="2">
                    <input name="lin" num_pins="8"/>
                    <input name="cin" num_pins="1"/>
                    <output name="combout" num_pins="1"/>
                    <output name="sumout" num_pins="1"/>
                    <output name="cout" num_pins="1"/>
                    <mode name="fourteennm_lcell">
                      <pb_type blif_model=".subckt fourteennm_lcell_comb" name="lcell_comb" num_pb="1">
                        <input name="dataa" num_pins="1"/>
                        <input name="datab" num_pins="1"/>
                        <input name="datac" num_pins="1"/>
                        <input name="datad" num_pins="1"/>
                        <input name="datae" num_pins="1"/>
                        <input name="dataf" num_pins="1"/>
                        <input name="datag" num_pins="1"/>
                        <input name="datah" num_pins="1"/>
                        <input name="cin" num_pins="1"/>
                        <output name="combout" num_pins="1"/>
                        <output name="sumout" num_pins="1"/>
                        <output name="cout" num_pins="1"/>


                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.combout"/>
                        <delay_constant max="197e-12" min="197e-12" in_port="lcell_comb.datab" out_port="lcell_comb.combout"/>
                        <delay_constant max="78e-12" min="78e-12" in_port="lcell_comb.datac" out_port="lcell_comb.combout"/>
                        <delay_constant max="60e-12" min="60e-12" in_port="lcell_comb.datad" out_port="lcell_comb.combout"/>
                        <delay_constant max="34e-12" min="34e-12" in_port="lcell_comb.datae" out_port="lcell_comb.combout"/>
                        <delay_constant max="4e-12" min="4e-12" in_port="lcell_comb.dataf" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datag" out_port="lcell_comb.combout"/>
                        <delay_constant max="198e-12" min="198e-12" in_port="lcell_comb.datah" out_port="lcell_comb.combout"/>

                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.sumout"/>
                        <delay_constant max="238e-12" min="238e-12" in_port="lcell_comb.datab" out_port="lcell_comb.sumout"/>
                        <delay_constant max="122e-12" min="122e-12" in_port="lcell_comb.datac" out_port="lcell_comb.sumout"/>
                        <delay_constant max="103e-12" min="103e-12" in_port="lcell_comb.datad" out_port="lcell_comb.sumout"/>
                        <delay_constant max="67e-12" min="67e-12" in_port="lcell_comb.cin" out_port="lcell_comb.sumout"/>

                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.dataa" out_port="lcell_comb.cout"/>
                        <delay_constant max="350e-12" min="350e-12" in_port="lcell_comb.datab" out_port="lcell_comb.cout"/>
                        <delay_constant max="205e-12" min="205e-12" in_port="lcell_comb.datac" out_port="lcell_comb.cout"/>
                        <delay_constant max="249e-12" min="249e-12" in_port="lcell_comb.datad" out_port="lcell_comb.cout"/>
                        <delay_constant max="40e-12" min="40e-12" in_port="lcell_comb.cin" out_port="lcell_comb.cout"/>
 
                      </pb_type>
                      <interconnect>
                        <!-- LUT inputs -->
                        <direct input="lut.lin[0]" name="in_comp1" output="lcell_comb.dataa"/>
                        <direct input="lut.lin[1]" name="in_comp2" output="lcell_comb.datab"/>
                        <direct input="lut.lin[2]" name="in_comp3" output="lcell_comb.datac"/>
                        <direct input="lut.lin[3]" name="in_comp4" output="lcell_comb.datad"/>
                        <direct input="lut.lin[4]" name="in_comp5" output="lcell_comb.datae"/>
                        <direct input="lut.lin[5]" name="in_comp6" output="lcell_comb.dataf"/>
                        <direct input="lut.lin[6]" name="in_comp7" output="lcell_comb.datag"/>
                        <direct input="lut.lin[7]" name="in_comp8" output="lcell_comb.datah"/>
                        <!-- LUT outputs -->
                        <direct input="lcell_comb.combout" name="out_comp1" output="lut.combout">
                          <!-- <pack_pattern name="LUT_FF" in_port="lcell_comb.combout" out_port="lut.combout"/> -->
                        </direct>
                        <direct input="lcell_comb.sumout" name="out_comp2" output="lut.sumout">
                          <!-- <pack_pattern name="LUT_FF" in_port="lcell_comb.sumout" out_port="lut.sumout"/> -->
                        </direct>
                        <!-- LUT carry chain -->
                        <direct input="lut.cin" name="lut_cin" output="lcell_comb.cin">
                          <pack_pattern name="LAB_carry_chain" in_port="lut.cin" out_port="lcell_comb.cin"/>
                        </direct>
                        <direct input="lcell_comb.cout" name="out_comp3" output="lut.cout">
                          <pack_pattern name="LAB_carry_chain" in_port="lcell_comb.cout" out_port="lut.cout"/>
                        </direct>
                      </interconnect>
                    </mode>
                    <mode name="names_lut">
                      <pb_type blif_model=".names" class="lut" name="lut6" num_pb="1">
                        <input name="in" num_pins="6" port_class="lut_in"/>
                        <output name="out" num_pins="1" port_class="lut_out"/>

                        <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                        261e-12
                      </delay_matrix>
                      <delay_matrix type="min" in_port="lut6.in" out_port="lut6.out">
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                        193e-12
                      </delay_matrix>
                      </pb_type>


                      <interconnect>
                        <complete input="lut.lin" name="l_complete1" output="lut6.in[5:0]"/>
                        <complete input="lut6.out" name="l_complete2" output="lut.sumout lut.combout"/>
                      </interconnect>
                    </mode>
                  </pb_type>
                  <interconnect>
                    <!-- Inputs to the LUTs -->
                    <complete input="comb_block.lin" name="in_lut0" output="lut[0].lin"/>
                    <complete input="comb_block.lin" name="in_lut1" output="lut[1].lin"/>
                    <!-- Combinational Block Carry Chain -->
                    <direct input="comb_block.cin" name="comb_block_cin" output="lut[0].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="comb_block.cin" out_port="lut[0].cin"/>
                    </direct>
                    <direct input="lut[0].cout" name="lut_to_lut_carry" output="lut[1].cin">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[0].cout" out_port="lut[1].cin"/>
                    </direct>
                    <direct input="lut[1].cout" name="alm_cout" output="comb_block.cout">
                      <pack_pattern name="LAB_carry_chain" in_port="lut[1].cout" out_port="comb_block.cout"/>
                    </direct>
                    <!-- Outputs to the Combinational Block -->
                    <direct input="lut[0].combout" name="lut0_comb" output="comb_block.combout[0]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[0].combout" out_port="comb_block.combout[0]"/> -->
                    </direct>
                    <direct input="lut[1].combout" name="lut1_comb" output=" comb_block.combout[1]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[1].combout" out_port="comb_block.combout[1]"/> -->
                    </direct>
                    <direct input="lut[0].sumout" name="lut0_sum" output=" comb_block.sumout[0]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[0].sumout" out_port="comb_block.sumout[0]"/> -->
                    </direct>
                    <direct input="lut[1].sumout" name="lut1_sum" output=" comb_block.sumout[1]">
                      <!-- <pack_pattern name="LUT_FF" in_port="lut[1].sumout" out_port="comb_block.sumout[1]"/> -->
                    </direct>
                  </interconnect>
              </mode>
              
            </pb_type>
            <pb_type name="dff" num_pb="2">
              <input name="clrn" num_pins="1"/>
              <input name="sclr" num_pins="1"/>
              <input name="ena" num_pins="1"/>
              <input name="d" num_pins="1"/>
              <output name="q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="stratix10_ff">
                <pb_type blif_model=".subckt fourteennm_ff" name="fourteennm_ff" num_pb="1">
                  <input name="clrn" num_pins="1"/>
                  <input name="sclr" num_pins="1"/>
                  <input name="ena" num_pins="1"/>
                  <input name="d" num_pins="1"/>
                  <output name="q" num_pins="1"/>
                  <clock name="clk" num_pins="1"/>
                  <T_setup value="89e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_setup value="89e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_hold value="162e-12" port="fourteennm_ff.clrn" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.sclr" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.ena" clock="clk"/>
                  <T_hold value="162e-12" port="fourteennm_ff.d" clock="clk"/>

                  <T_clock_to_Q max="283e-12" min="283e-12" port="fourteennm_ff.q" clock="clk"/>

                </pb_type>
                <interconnect>
                  <direct input="dff.clrn" name="fourteennm_ff_clrn" output="fourteennm_ff.clrn"/>
                  <direct input="dff.sclr" name="fourteennm_ff_sclr" output="fourteennm_ff.sclr"/>
                  <direct input="dff.ena" name="fourteennm_ff_ena" output="fourteennm_ff.ena"/>
                  <direct input="dff.d" name="fourteennm_ff_d" output="fourteennm_ff.d">
                    <!-- <pack_pattern name="LUT_FF" in_port="dff.d" out_port="fourteennm_ff.d"/> -->
                  </direct>
                  <direct input="fourteennm_ff.q" name="fourteennm_ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="fourteennm_ff_clk" output="fourteennm_ff.clk"/>
                </interconnect>
              </mode>
              <mode name="latch">
                <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="ff.D" clock="clk"/>
                  <T_hold value="37e-12" port="ff.D" clock="clk"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="ff.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.d" name="ff_d" output="ff.D"/>
                  <direct input="ff.Q" name="ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="ff_clk" output="ff.clk"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <!-- Inputs to LUTs -->
              <direct input="alm.data_in[2:7]" name="in_lut_2_7" output="comb_block.lin[2:7]"/>
              <mux input="alm.data_in[0] comb_block.sumout[0] dff[0].q" name="in_lut_0" output="comb_block.lin[0]"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1] dff[1].q" name="in_lut_1" output="comb_block.lin[1]"/>

              <!-- Inputs to FFs -->
              <complete input="alm.data_in[9:8]" name="in_dff" output="dff[1:0].d"/>
              <mux input="comb_block.sumout[0]" name="in_dff_0" output="dff[0].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.sumout[0]" out_port="dff[0].d"/> -->
              </mux>
              <direct input="comb_block.combout[0]" name="in_dff_1" output="dff[0].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.combout[0]" out_port="dff[0].d"/> -->
              </direct>
              <mux input=" comb_block.combout[0] comb_block.sumout[1]" name="in_dff_2" output="dff[1].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.sumout[1]" out_port="dff[1].d"/> -->
              </mux>
              <direct input="comb_block.combout[1]" name="in_dff_3" output="dff[1].d">
                <!-- <pack_pattern name="LUT_FF" in_port="comb_block.combout[1]" out_port="dff[1].d"/> -->
              </direct>

              <!-- ALM Outputs-->
              <mux input="dff[0].q alm.data_in[0] comb_block.combout[0] comb_block.sumout[0]" name="alm_out0" output="alm.data_out[0]"/>
              <mux input="dff[0].q alm.data_in[0] comb_block.combout[0] comb_block.sumout[0]" name="alm_out1" output="alm.data_out[1]"/>
              <mux input="dff[1].q alm.data_in[1] comb_block.combout[0] comb_block.combout[1] comb_block.sumout[1]" name="alm_out2" output="alm.data_out[2]"/>
              <mux input="dff[1].q alm.data_in[1] comb_block.combout[0] comb_block.combout[1] comb_block.sumout[1]" name="alm_out3" output="alm.data_out[3]"/>

              <!-- FF Clocks -->
              <direct input="alm.clock" name="clock_dff0" output="dff[0].clk"/>
              <direct input="alm.clock" name="clock_dff1" output="dff[1].clk"/>
              <!-- ALM Carry Chain -->
              <direct input="alm.cin" name="alm_cin" output="comb_block.cin">
                <pack_pattern name="LAB_carry_chain" in_port="alm.cin" out_port="comb_block.cin"/>
              </direct>

              <direct input="comb_block.cout" name="alm_cout" output="alm.cout">
                <pack_pattern name="LAB_carry_chain" in_port="comb_block.cout" out_port="alm.cout"/>
              </direct>

              <direct input="alm.control[4]" name="control_1_dff0" output="dff[0].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff0" output="dff[0].ena"/>
              <direct input="alm.control[3]" name="control_3_dff0" output="dff[0].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff3" output="dff[1].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff3" output="dff[1].ena"/>
              <direct input="alm.control[0]" name="control_3_dff3" output="dff[1].sclr"/>
            </interconnect>
          </mode>
        </pb_type>
        <interconnect>
          <!--LAB-ALM Interconnect-->
          <!-- LAB Input: Global Routing to ALM inputs -->
          <complete input="LABMLAB.data_in" name="LAB_datain" output="alm[9:0].data_in">
            <delay_constant max="145e-12" min="145e-12" in_port="LABMLAB.data_in" out_port="alm[9:0].data_in"/>
          </complete>
          <!-- ALM Outputs: directly drive global routing -->
          <complete input="alm[9:0].data_out" name="LAB_dataout" output="LABMLAB.data_out">
            <delay_constant max="56e-12" min="56e-12" in_port="alm[9:0].data_out" out_port="LABMLAB.data_out"/>
          </complete>   
          <!-- ALM Control Inputs -->
          <complete input="LABMLAB.control_in" name="LAB_control" output="alm[9:0].control">
            <delay_constant max="145e-12" min="145e-12" in_port="LABMLAB.control_in" out_port="alm[9:0].control"/>
          </complete>  
          <!-- LAB Clocks -->
          <complete input="LABMLAB.clk" name="LAB_clock" output="alm[9:0].clock"/>
          <!-- LAB Carry Chain mid-point entry/exit points, this allows the chain to jump early to
               the next LAB, if the full chain would overuse the number of LAB inputs -->
          <!--<complete input="alm[4].cout" name="alm4_midpoint_exit_carry" output="LABMLAB.data_out"/>-->
          <!--<complete input="LABMLAB.data_in" name="alm5_midpoint_entry_carry" output="alm[5].cin"/>-->
          <!--LAB carry chain-->
          <direct input="LABMLAB.cin" name="LAB_cin" output="alm[0].cin">
            <pack_pattern name="LAB_carry_chain" in_port="LABMLAB.cin" out_port="alm[0].cin"/>
          </direct>
          <direct input="alm[0].cout" name="alm0_alm1_carry" output="alm[1].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[0].cout" out_port="alm[1].cin"/>
          </direct>
          <direct input="alm[1].cout" name="alm1_alm2_carry" output="alm[2].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[1].cout" out_port="alm[2].cin"/>
          </direct>
          <direct input="alm[2].cout" name="alm2_alm3_carry" output="alm[3].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[2].cout" out_port="alm[3].cin"/>
          </direct>
          <direct input="alm[3].cout" name="alm3_alm4_carry" output="alm[4].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[3].cout" out_port="alm[4].cin"/>
          </direct>
          <direct input="alm[4].cout" name="alm4_alm5_carry" output="alm[5].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[4].cout" out_port="alm[5].cin"/>
          </direct>
          <direct input="alm[5].cout" name="alm5_alm6_carry" output="alm[6].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[5].cout" out_port="alm[6].cin"/>
          </direct>
          <direct input="alm[6].cout" name="alm6_alm7_carry" output="alm[7].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[6].cout" out_port="alm[7].cin"/>
          </direct>
          <direct input="alm[7].cout" name="alm7_alm8_carry" output="alm[8].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[7].cout" out_port="alm[8].cin"/>
          </direct>
          <direct input="alm[8].cout" name="alm8_alm9_carry" output="alm[9].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[8].cout" out_port="alm[9].cin"/>
          </direct>
          <direct input="alm[9].cout" name="LAB_cout" output="LABMLAB.cout">
            <pack_pattern name="LAB_carry_chain" in_port="alm[9].cout" out_port="LABMLAB.cout"/>
          </direct>


        </interconnect>
      </mode>
      <mode name="MLAB">

        <pb_type name="MLAB" num_pb="1">
          <clock name="clk0" num_pins="1"/>
          <input name="ena0" num_pins="1"/>
          <input name="clr" num_pins="1"/>
          <input name="portaaddr" num_pins="5"/>
          <input name="portabyteenamasks" num_pins="20"/>
          <input name="portadatain" num_pins="20"/>
          <input name="portbaddr" num_pins="5"/>
          <output name="portbdataout" num_pins="20"/>
          <mode name="mlab_cell">
          <pb_type blif_model=".subckt fourteennm_mlab_cell" name="mlab_cell" num_pb="10">
            <input name="ena0" num_pins="1"/>
            <clock name="clk0" num_pins="1"/>
            <input name="clr" num_pins="1"/>
            <input name="portaaddr" num_pins="5"/>
            <input name="portabyteenamasks" num_pins="2"/>
            <input name="portadatain" num_pins="2"/>
            <input name="portbaddr" num_pins="5"/>
            <output name="portbdataout" num_pins="2"/>
                  <T_setup value="66e-12" port="mlab_cell.ena0" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="mlab_cell.portbdataout" clock="clk0"/>

          </pb_type>
          <interconnect>
              <!-- Enable Input: From MLAB block to MLAB cells enable input -->
              <direct input="MLAB.ena0" name="ena0" output="mlab_cell[0].ena0"/>
              <direct input="MLAB.ena0" name="ena1" output="mlab_cell[1].ena0"/>
              <direct input="MLAB.ena0" name="ena2" output="mlab_cell[2].ena0"/>
              <direct input="MLAB.ena0" name="ena3" output="mlab_cell[3].ena0"/>
              <direct input="MLAB.ena0" name="ena4" output="mlab_cell[4].ena0"/>
              <direct input="MLAB.ena0" name="ena5" output="mlab_cell[5].ena0"/>
              <direct input="MLAB.ena0" name="ena6" output="mlab_cell[6].ena0"/>
              <direct input="MLAB.ena0" name="ena7" output="mlab_cell[7].ena0"/>
              <direct input="MLAB.ena0" name="ena8" output="mlab_cell[8].ena0"/>
              <direct input="MLAB.ena0" name="ena9" output="mlab_cell[9].ena0"/>

              <!-- Clear Input: From MLAB block to MLAB cells clear input -->
              <direct input="MLAB.clr" name="clr0" output="mlab_cell[0].clr"/>
              <direct input="MLAB.clr" name="clr1" output="mlab_cell[1].clr"/>
              <direct input="MLAB.clr" name="clr2" output="mlab_cell[2].clr"/>
              <direct input="MLAB.clr" name="clr3" output="mlab_cell[3].clr"/>
              <direct input="MLAB.clr" name="clr4" output="mlab_cell[4].clr"/>
              <direct input="MLAB.clr" name="clr5" output="mlab_cell[5].clr"/>
              <direct input="MLAB.clr" name="clr6" output="mlab_cell[6].clr"/>
              <direct input="MLAB.clr" name="clr7" output="mlab_cell[7].clr"/>
              <direct input="MLAB.clr" name="clr8" output="mlab_cell[8].clr"/>
              <direct input="MLAB.clr" name="clr9" output="mlab_cell[9].clr"/>

              <!-- Write Address: Input write address to the MLAB cells -->
              <direct input="MLAB.portaaddr" name="portaaddr0" output="mlab_cell[0].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr1" output="mlab_cell[1].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr2" output="mlab_cell[2].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr3" output="mlab_cell[3].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr4" output="mlab_cell[4].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr5" output="mlab_cell[5].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr6" output="mlab_cell[6].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr7" output="mlab_cell[7].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr8" output="mlab_cell[8].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr9" output="mlab_cell[9].portaaddr"/>

              <!-- Byte Enable Mask: Input byte enable mask to the MLAB cells -->
              <direct input="MLAB.portabyteenamasks[1:0]" name="portabytenamasks0" output="mlab_cell[0].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[3:2]" name="portabytenamasks1" output="mlab_cell[1].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[5:4]" name="portabytenamasks2" output="mlab_cell[2].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[7:6]" name="portabytenamasks3" output="mlab_cell[3].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[9:8]" name="portabytenamasks4" output="mlab_cell[4].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[11:10]" name="portabytenamasks5" output="mlab_cell[5].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[13:12]" name="portabytenamasks6" output="mlab_cell[6].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[15:14]" name="portabytenamasks7" output="mlab_cell[7].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[17:16]" name="portabytenamasks8" output="mlab_cell[8].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[19:18]" name="portabytenamasks9" output="mlab_cell[9].portabyteenamasks"/>

              <!-- Write Data: Input data to the MLAB cells -->
              <direct input="MLAB.portadatain[1:0]" name="portadatain0" output="mlab_cell[0].portadatain"/>
              <direct input="MLAB.portadatain[3:2]" name="portadatain1" output="mlab_cell[1].portadatain"/>
              <direct input="MLAB.portadatain[5:4]" name="portadatain2" output="mlab_cell[2].portadatain"/>
              <direct input="MLAB.portadatain[7:6]" name="portadatain3" output="mlab_cell[3].portadatain"/>
              <direct input="MLAB.portadatain[9:8]" name="portadatain4" output="mlab_cell[4].portadatain"/>
              <direct input="MLAB.portadatain[11:10]" name="portadatain5" output="mlab_cell[5].portadatain"/>
              <direct input="MLAB.portadatain[13:12]" name="portadatain6" output="mlab_cell[6].portadatain"/>
              <direct input="MLAB.portadatain[15:14]" name="portadatain7" output="mlab_cell[7].portadatain"/>
              <direct input="MLAB.portadatain[17:16]" name="portadatain8" output="mlab_cell[8].portadatain"/>
              <direct input="MLAB.portadatain[19:18]" name="portadatain9" output="mlab_cell[9].portadatain"/>

              <!-- Read Address: Input read address to the MLAB cells -->
              <direct input="MLAB.portbaddr" name="portbaddr0" output="mlab_cell[0].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr1" output="mlab_cell[1].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr2" output="mlab_cell[2].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr3" output="mlab_cell[3].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr4" output="mlab_cell[4].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr5" output="mlab_cell[5].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr6" output="mlab_cell[6].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr7" output="mlab_cell[7].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr8" output="mlab_cell[8].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr9" output="mlab_cell[9].portbaddr"/>

              <!-- Read data: Output data from MLAB cells to the MLAB output -->
              <direct input="mlab_cell[0].portbdataout" name="portbdataout0" output="MLAB.portbdataout[1:0]"/>
              <direct input="mlab_cell[1].portbdataout" name="portbdataout1" output="MLAB.portbdataout[3:2]"/>
              <direct input="mlab_cell[2].portbdataout" name="portbdataout2" output="MLAB.portbdataout[5:4]"/>
              <direct input="mlab_cell[3].portbdataout" name="portbdataout3" output="MLAB.portbdataout[7:6]"/>
              <direct input="mlab_cell[4].portbdataout" name="portbdataout4" output="MLAB.portbdataout[9:8]"/>
              <direct input="mlab_cell[5].portbdataout" name="portbdataout5" output="MLAB.portbdataout[11:10]"/>
              <direct input="mlab_cell[6].portbdataout" name="portbdataout6" output="MLAB.portbdataout[13:12]"/>
              <direct input="mlab_cell[7].portbdataout" name="portbdataout7" output="MLAB.portbdataout[15:14]"/>
              <direct input="mlab_cell[8].portbdataout" name="portbdataout8" output="MLAB.portbdataout[17:16]"/>
              <direct input="mlab_cell[9].portbdataout" name="portbdataout9" output="MLAB.portbdataout[19:18]"/>

              <!-- MLAB cell clocks -->
              <direct input="MLAB.clk0" name="clk0" output="mlab_cell[0].clk0"/>
              <direct input="MLAB.clk0" name="clk1" output="mlab_cell[1].clk0"/>
              <direct input="MLAB.clk0" name="clk2" output="mlab_cell[2].clk0"/>
              <direct input="MLAB.clk0" name="clk3" output="mlab_cell[3].clk0"/>
              <direct input="MLAB.clk0" name="clk4" output="mlab_cell[4].clk0"/>
              <direct input="MLAB.clk0" name="clk5" output="mlab_cell[5].clk0"/>
              <direct input="MLAB.clk0" name="clk6" output="mlab_cell[6].clk0"/>
              <direct input="MLAB.clk0" name="clk7" output="mlab_cell[7].clk0"/>
              <direct input="MLAB.clk0" name="clk8" output="mlab_cell[8].clk0"/>
              <direct input="MLAB.clk0" name="clk9" output="mlab_cell[9].clk0"/>
            </interconnect>
        </mode>
        </pb_type>
        <interconnect>
          <complete input="LABMLAB.clk" name="mlab_clk" output="MLAB.clk0"/>
          <complete input="LABMLAB.data_in" name="mlab_in1" output="MLAB.ena0"/>
          <complete input="LABMLAB.data_in" name="mlab_in2" output="MLAB.clr"/>
          <complete input="LABMLAB.data_in" name="mlab_in3" output="MLAB.portaaddr"/>
          <complete input="LABMLAB.data_in" name="mlab_in4" output="MLAB.portabyteenamasks"/>
          <complete input="LABMLAB.data_in" name="mlab_in5" output="MLAB.portadatain"/>
          <complete input="LABMLAB.data_in" name="mlab_in6" output="MLAB.portbaddr"/>
          <complete input="MLAB.portbdataout" name="mlab_out" output="LABMLAB.data_out"/>
        </interconnect>
      </mode>
    </pb_type>

    <pb_type name="OCT" >
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="1"/>

       <!-- the input pad is used is connected to rzqin pin -->
      <pb_type blif_model=".input" name="inpad" num_pb="1">
        <output name="inpad" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination" name="oct_block" num_pb="1">
        <input name="rzqin" num_pins="1"/> <!-- connects to an external reference resistor -->
        <input name="enserusr" num_pins="1"/> <!-- specifies the oct block to read from  -->
        <input name="nclrusr" num_pins="1"/> <!-- clear signal -->
        <input name="clkenusr" num_pins="1"/>
        <clock name="clkusr" num_pins="1"/>
        <input name="ser_data_dq_from_core" num_pins="1"/>
        <input name="ser_data_ca_from_core" num_pins="1"/>
        <input name="test_clkusr_en_n" num_pins="1"/>
        <input name="oct_scanin" num_pins="1"/>
        <output name="clkusr_dft_out" num_pins="1"/>
        <output name="oct_scanout" num_pins="1"/>
        <output name="compout_rdn" num_pins="1"/>
        <output name="compout_rup" num_pins="1"/>
        <output name="serdataout" num_pins="1"/>
        <output name="ser_data_dq_to_core" num_pins="1"/>
        <output name="ser_data_ca_to_core" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination_logic" name="oct_logic" num_pb="1">
        <input name="s2pload" num_pins="1"/>
        <input name="serdata" num_pins="1"/>
        <input name="scan_in" num_pins="1"/>
        <input name="scan_shift_in" num_pins="1"/>
        <output name="scan_out" num_pins="1"/>
        <output name="seriesterminationcontrol" num_pins="16"/>
        <output name="parallelterminationcontrol" num_pins="16"/>
      </pb_type>

      <interconnect>
        <direct input="OCT.clk" name="clk_to_oct_block" output="oct_block.clkusr"/>

        <!-- the rzqin pin is connected to an external resistor -->
        <direct input="inpad.inpad" name="rzqin_in" output="oct_block.rzqin"/>

        <!-- oct_block inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_block" output="oct_block.enserusr oct_block.nclrusr oct_block.clkenusr oct_block.ser_data_dq_from_core oct_block.ser_data_ca_from_core oct_block.test_clkusr_en_n oct_block.oct_scanin"/>

        <!-- oct_logic inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_logic" output="oct_logic.s2pload oct_logic.scan_in oct_logic.scan_shift_in" />
        <!-- oct_logic serdata coming from serdataout of the oct block -->
        <direct input="oct_block.serdataout" name="serdata_path" output="oct_logic.serdata">
          <pack_pattern name="OCT" in_port="oct_block.serdataout" out_port="oct_logic.serdata"/>
        </direct>
        <!-- oct_block outputs going to the core logic -->
        <complete input="oct_block.clkusr_dft_out oct_block.oct_scanout oct_block.compout_rdn oct_block.compout_rup oct_block.ser_data_dq_to_core oct_block.ser_data_ca_to_core" name="oct_block_to_core" output="OCT.core_out"/>

        <!-- oct_logic outputs going to the core logic -->
        <complete input="oct_logic.scan_out oct_logic.seriesterminationcontrol oct_logic.parallelterminationcontrol" name="oct_logic_to_core" output="OCT.core_out"/>
        
      </interconnect>
    </pb_type>

    <pb_type name="iolane">
      <input name="core_in" num_pins="55"/>
      <output name="core_out" num_pins="24"/>
      <clock name="clk" num_pins="1"/>

      <pb_type name="io_cell" num_pb="4">
        <input name="data_in" num_pins="36"/>
        <output name="data_out" num_pins="6"/>
        <clock name="clk" num_pins="1"/>

        <mode name="io_cell" num_pb="1">

          <pb_type name="pad" num_pb="1">
            <output name="recieve_off_chip" num_pins="1"/>
            <input name="drive_off_chip" num_pins="1"/>

            <pb_type blif_model=".input" name="inpad" num_pb="1">
              <output name="inpad" num_pins="1"/>
            </pb_type>

            <pb_type blif_model=".output" name="outpad" num_pb="1">
              <input name="outpad" num_pins="1"/>
            </pb_type>

            <interconnect>
            <direct input="inpad.inpad" name="inpad" output="pad.recieve_off_chip"/>
            <direct input="pad.drive_off_chip" name="outpad" output="outpad.outpad"/>
            </interconnect>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ff" name="oe_ff" num_pb="1">
            <input name="clrn" num_pins="1"/> <!-- driver signal for clrn, sclr, ena, and d comes from the core logic -->
            <input name="sclr" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="d" num_pins="1"/>
            <output name="q" num_pins="1"/> <!-- driving the output enable port of the output buffer -->
            <clock name="clk" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_obuf" name="obuf" num_pb="1">
            <input name="i" num_pins="1"/> <!-- can be driven by the core logic through obuf_i port of the parent pb_type or by the dataout port of the ddio_out -->
            <input name="oe" num_pins="1"/> <!-- output enable port driven by the q output of the OE flip flop or the core logic -->
            <input name="dynamicterminationcontrol" num_pins="1"/> <!-- the following three ports driven by the corresponding ports in the parent pb_type -->
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <!-- <input name="devoe" num_pins="1"/>
            <input name="emif_phy_in" num_pins="2"/> -->
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_ibuf" name="ibuf" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="dynamicterminationcontrol" num_pins="1"/>
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <output name="o" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_out" name="ddio_out" num_pb="1">
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <input name="clkhi" num_pins="1"/>
            <input name="clklo" num_pins="1"/>
            <input name="muxsel" num_pins="1"/>
            <input name="datainlo" num_pins="1"/>
            <input name="datainhi" num_pins="1"/>
            <output name="dataout" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="dffhi" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="hrbypass" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_in" name="ddio_in" num_pb="1">
            <clock name="clk" num_pins="1"/>
            <input name="clkn" num_pins="1"/>
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="datain" num_pins="1"/>
            <output name="regoutlo" num_pins="1"/>
            <output name="regouthi" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_pseudo_diff_out" name="pseudo_diff_out" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="oein" num_pins="1"/>
            <input name="oebin"  num_pins="1"/>
            <input name="dtcin" num_pins="1"/>
            <input name="dtcbarin" num_pins="1"/>
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
            <output name="oeout" num_pins="1"/>
            <output name="oebout" num_pins="1"/>
            <output name="dtc" num_pins="1"/>
            <output name="dtcbar" num_pins="1"/>
            <!-- <input name="emif_phy_in" num_pins="2"/>
            <input name="emif_phy_inb" num_pins="2"/>
            <output name="emif_phy_out" num_pins="2"/>
            <output name="emif_phy_outb" num_pins="2"/> -->
          </pb_type>

          <interconnect>
            <!-- inputs coming from the FPGA core and going to OE flip flop -->
            <complete input="io_cell.data_in" name="core_to_ff" output="oe_ff.clrn oe_ff.sclr oe_ff.ena oe_ff.d"/>
            <direct input="io_cell.clk" name="ff_clk" num_pins="1" output="oe_ff.clk"/>

            <!-- inputs coming from the FPGA core and going to ddio out primitive -->
            <complete input="io_cell.data_in" name="core_to_ddio_out" num_pins="1" output="ddio_out.areset ddio_out.sreset ddio_out.ena ddio_out.clkhi ddio_out.clklo ddio_out.muxsel ddio_out.datainlo ddio_out.datainhi"/>
            <direct input="io_cell.clk" name="ddio_out_clk" num_pins="1" output="ddio_out.clk"/>

            <!-- inputs coming from the FPGA core and going to the output buffer -->
            <complete input="io_cell.data_in" name="core_to_obuf" output="obuf.dynamicterminationcontrol obuf.seriesterminationcontrol obuf.parallelterminationcontrol"/>
            <!-- the i port of the output buffer can be driven by the output of the ddio out module or the core logic or the o output of the pseudo diff out-->
            <complete input="io_cell.data_in ddio_out.dataout pseudo_diff_out.o" name="i_obuff" num_pins="1" output="obuf.i"/>
            <!-- the oe port of the output buffer can be driven by the output of the oe flip flop or the core logic or the oeout output of the pseudo diff out-->
            <complete input="io_cell.data_in oe_ff.q pseudo_diff_out.oeout" name="oe_obuff" num_pins="1" output="obuf.oe"/>

            <!-- inputs coming from the FPGA core and going to the input buffer -->
            <complete input="io_cell.data_in" name="core_to_ibuff" output="ibuf.ibar ibuf.dynamicterminationcontrol ibuf.seriesterminationcontrol ibuf.parallelterminationcontrol"/>
            <!-- the output of the padin will directly drive the input buffer  -->
            <direct input="pad.recieve_off_chip" name="pad_receive" num_pins="1" output="ibuf.i">
              <pack_pattern name="pad_to_ibuf" in_port="pad.recieve_off_chip" out_port="ibuf.i"/>
            </direct>

            <!-- inputs coming from the FPGA core and going to pseudo diff out primitive -->
            <complete input="io_cell.data_in" name="core_to_pseudo_diff_out" num_pins="1" output="pseudo_diff_out.ibar pseudo_diff_out.oebin pseudo_diff_out.dtcin pseudo_diff_out.dtcbarin"/>
            <!-- the i port of the  pseudo diff out can be driven by the output of the ddio out module or the core logic -->
            <complete input="io_cell.data_in ddio_out.dataout" name="i_pseudo_diff" num_pins="1" output=" pseudo_diff_out.i"/>
            <!-- the oein port of the pseudo diff out can be driven by the output of the oe flip flop or the core logic -->
            <complete input="io_cell.data_in oe_ff.q" name="oe_pseudo_diff" num_pins="1" output="pseudo_diff_out.oein"/>

            <!-- inputs coming from the FPGA core and going to ddio in primitive -->
            <complete input="io_cell.data_in" name="core_to_ddio_in" num_pins="1" output="ddio_in.clkn ddio_in.areset ddio_in.sreset ddio_in.ena"/>
            <direct input="io_cell.clk" name="ddioi_clk" num_pins="1" output="ddio_in.clk"/>

            <!-- the data port of theddio in is driven by the output of the input buffer or by FPGA global routing -->
            <complete input="ibuf.o io_cell.data_in" name="ddioi_datain" num_pins="1" output="ddio_in.datain"/>

            <!-- the pad out can be driven by the output ports of the output buffer or by FPGA core  -->
            <complete input="io_cell.data_in obuf.o obuf.obar" name="pad_drive" num_pins="1" output="pad.drive_off_chip">
              <pack_pattern name="obuf_to_pad" in_port="obuf.o" out_port="pad.drive_off_chip"/>
            </complete>

            <!-- the outputs of the io_cell block going to the core -->
            <direct input="pseudo_diff_out.obar" name="io_cell_obar" num_pins="1" output="io_cell.data_out[0]"/>
            <direct input="pseudo_diff_out.oebout" name="io_cell_oeout" num_pins="1" output="io_cell.data_out[1]"/>
            <direct input="pseudo_diff_out.dtc" name="io_cell_dtc" num_pins="1" output="io_cell.data_out[2]"/>
            <direct input="pseudo_diff_out.dtcbar" name="io_cell_dtcbar" num_pins="1" output="io_cell.data_out[3]"/>
            <complete input="ibuf.o ddio_in.regoutlo pad.recieve_off_chip" name="io_cell_regoutlo" num_pins="1" output="io_cell.data_out[4]"/>
            <direct input="ddio_in.regouthi" name="io_cell_regouthi" num_pins="1" output="io_cell.data_out[5]"/>

          </interconnect>
        </mode>
      </pb_type>

      <interconnect>
        <complete input="iolane.core_in" name="core_to_io" output="io_cell.data_in"/>
        <complete input="io_cell.data_out" name="io_to_core" output="iolane.core_out"/>
        <direct input="iolane.clk" name="clk_connection0" output="io_cell[0].clk" />
        <direct input="iolane.clk" name="clk_connection1" output="io_cell[1].clk" />
        <direct input="iolane.clk" name="clk_connection2" output="io_cell[2].clk" />
        <direct input="iolane.clk" name="clk_connection3" output="io_cell[3].clk" />
      </interconnect>
    </pb_type>

    <pb_type name="DSP">
      <input name="dspin" num_pins="240"/>
      <input name="chainin" num_pins="64"/>
      <input name="scanin" num_pins="27"/>
      <clock name="clk" num_pins="3"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <output name="dftout" num_pins="1"/>
      <mode name="DSP">
        <pb_type name="dsp_prim" num_pb="1">
          <input name="datain" num_pins="110"/>
          <input name="chainin" num_pins="64"/>
          <input name="controlin" num_pins="17"/>
          <input name="scanin" num_pins="27"/>
          <clock name="clk" num_pins="3"/>
          <output name="result" num_pins="74"/>
          <output name="chainout" num_pins="64"/>
          <output name="scanout" num_pins="27"/>
          <output name="dftout" num_pins="1"/>
          <!-- 
              We model several different operation modes of the fourteennm_mac primitive:
                    independent multiplier 
                    multiplier adder sum 
                    18x19 multiplication summed with 36-bit input 
                    systolic fir 
                    27x27 independent multiplier 
                    single 18x18 multiplier

                As well as several operation modes of the fourteennm_fp_mac primitive:
                    multiplication
                    multiply accumulate
                    multiply add
                    adder or subtract
                    vector one mode
                    vector two mode

              We also model 4 variations of each operation mode to capture timing differences based on whether the inputs and/or outputs are 
              registered or combinational.

              This is itself an approximation of the actual Stratix 10 architecture, which can support multiple levels of internal registers
              inside each DSP block.  To model this would be extremely verbose and time consuming. The approximation mentioned above is a 
              reasonable compromise, since it captures the key timing characteristics of the fourteennm_mac or fourteennm_fp_mac from an external perspective (which is
              what most pack/place/route CAD tools would care about).  
            -->

            <!-- independent multiplier mode -->
          <mode name="m18x18_full.input_type{reg}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{comb}" name="mac18x18_full" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="coefselb" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="64"/>
              <output name="resultb" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
              <direct input="mac18x18_full.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_full.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
              <direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="dsp_prim.result[73:37]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_full.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_full.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_full.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_full.negate_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_full.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{reg}" name="mac18x18_full" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="coefselb" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="64"/>
              <output name="resultb" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
              <direct input="mac18x18_full.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_full.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
              <direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="dsp_prim.result[73:37]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_full.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_full.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_full.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_full.negate_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_full.input_type{comb}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{comb}.output_type{comb}" name="mac18x18_full" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="coefselb" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="64"/>
              <output name="resultb" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
              <direct input="mac18x18_full.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_full.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
              <direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="dsp_prim.result[73:37]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_full.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_full.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_full.output_clk"/> 
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_full.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_full.negate_clk"/>         
            </interconnect>
          </mode>

          <mode name="m18x18_full.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_full}.input_type{reg}.output_type{reg}" name="mac18x18_full" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="coefselb" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="64"/>
              <output name="resultb" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_full.scanin"/>
              <direct input="mac18x18_full.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_full.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_full.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_full.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_full.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_full.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_full.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_full.bz"/>
              <direct input="mac18x18_full.resulta[36:0]" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="mac18x18_full.resultb[36:0]" name="resultb_out" output="dsp_prim.result[73:37]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_full.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_full.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_full.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_full.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_full.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_full.dfxmisrena"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_full.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_full.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_full.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_full.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_full.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_full.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_full.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_full.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_full.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_full.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_full.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_full.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_full.negate_clk"/>
            </interconnect>
          </mode>

            <!-- multiplier adder sum mode -->
          <mode name="m18x18_sumof2.input_type{reg}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{comb}" name="mac18x18_sumof2" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
              <direct input="mac18x18_sumof2.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
              <direct input="mac18x18_sumof2.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_sumof2.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
              <direct input="mac18x18_sumof2.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_sumof2.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{reg}" name="mac18x18_sumof2" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
              <direct input="mac18x18_sumof2.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
              <direct input="mac18x18_sumof2.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_sumof2.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
              <direct input="mac18x18_sumof2.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_sumof2.input_type{comb}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{comb}.output_type{comb}" name="mac18x18_sumof2" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
              <direct input="mac18x18_sumof2.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
              <direct input="mac18x18_sumof2.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_sumof2.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
              <direct input="mac18x18_sumof2.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_sumof2.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_sumof2}.input_type{reg}.output_type{reg}" name="mac18x18_sumof2" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_sumof2.chainin"/>
              <direct input="mac18x18_sumof2.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_sumof2.scanin"/>
              <direct input="mac18x18_sumof2.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_sumof2.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_sumof2.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_sumof2.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_sumof2.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_sumof2.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_sumof2.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_sumof2.bz"/>
              <direct input="mac18x18_sumof2.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_sumof2.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_sumof2.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_sumof2.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_sumof2.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_sumof2.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_sumof2.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_sumof2.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_sumof2.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_sumof2.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_sumof2.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_sumof2.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_sumof2.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_sumof2.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_sumof2.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_sumof2.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_sumof2.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_sumof2.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_sumof2.coef_sel_b_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_sumof2.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_sumof2.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_sumof2.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_sumof2.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_sumof2.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_sumof2.chainout_clk"/>
            </interconnect>
          </mode>
    

            <!-- 18x19 multiplication summed with 36-bit input -->
          <mode name="m18x18_plus36.input_type{reg}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{comb}" name="mac18x18_plus36" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
              <direct input="mac18x18_plus36.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="mac18x18_plus36.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
              <direct input="dsp_prim.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
              <direct input="mac18x18_plus36.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_plus36.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{reg}" name="mac18x18_plus36" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
              <direct input="mac18x18_plus36.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="mac18x18_plus36.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
              <direct input="dsp_prim.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
              <direct input="mac18x18_plus36.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_plus36.input_type{comb}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{comb}.output_type{comb}" name="mac18x18_plus36" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
              <direct input="mac18x18_plus36.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="mac18x18_plus36.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
              <direct input="dsp_prim.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
              <direct input="mac18x18_plus36.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
            </interconnect>
          </mode>
          
          <mode name="m18x18_plus36.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_plus36}.input_type{reg}.output_type{reg}" name="mac18x18_plus36" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_plus36.chainin"/>
              <direct input="mac18x18_plus36.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="mac18x18_plus36.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_plus36.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_plus36.ay"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_plus36.bx"/>
              <direct input="dsp_prim.datain[90:73]" name="by_in" output="mac18x18_plus36.by"/>
              <direct input="mac18x18_plus36.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_plus36.clr"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_plus36.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_plus36.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_plus36.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_plus36.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_plus36.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_plus36.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_plus36.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_plus36.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_plus36.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_plus36.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_plus36.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_plus36.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_plus36.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_plus36.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_plus36.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_plus36.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_plus36.chainout_clk"/>
            </interconnect>
          </mode>


            <!-- systolic fir mode -->
          <mode name="m18x18_systolic.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_systolic}.input_type{comb}.output_type{reg}" name="mac18x18_systolic" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_systolic.chainin"/>
              <direct input="mac18x18_systolic.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_systolic.scanin"/>
              <direct input="mac18x18_systolic.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_systolic.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_systolic.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_systolic.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_systolic.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_systolic.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_systolic.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_systolic.bz"/>
              <direct input="mac18x18_systolic.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_systolic.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_systolic.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_systolic.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_systolic.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_systolic.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_systolic.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_systolic.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_systolic.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_systolic.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_systolic.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_systolic.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_systolic.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_systolic.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_systolic.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_systolic.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_systolic.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_systolic.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_systolic.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_systolic.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_systolic.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_systolic.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_systolic.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_systolic.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_systolic.coef_sel_b_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_systolic.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_systolic}.input_type{reg}.output_type{reg}" name="mac18x18_systolic" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="bx_clk" num_pins="1"/>
              <clock name="by_clk" num_pins="1"/>
              <clock name="bz_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
              <clock name="coef_sel_b_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac18x18_systolic.chainin"/>
              <direct input="mac18x18_systolic.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_systolic.scanin"/>
              <direct input="mac18x18_systolic.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_systolic.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_systolic.ax"/>
              <direct input="dsp_prim.datain[36:18]" name="ay_in" output="mac18x18_systolic.ay"/>
              <direct input="dsp_prim.datain[54:37]" name="az_in" output="mac18x18_systolic.az"/>
              <direct input="dsp_prim.datain[72:55]" name="bx_in" output="mac18x18_systolic.bx"/>
              <direct input="dsp_prim.datain[91:73]" name="by_in" output="mac18x18_systolic.by"/>
              <direct input="dsp_prim.datain[109:92]" name="bz_in" output="mac18x18_systolic.bz"/>
              <direct input="mac18x18_systolic.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_systolic.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_systolic.coefsela"/>
              <direct input="dsp_prim.controlin[7:5]" name="coefselb_in" output="mac18x18_systolic.coefselb"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_systolic.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_systolic.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_systolic.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac18x18_systolic.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac18x18_systolic.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_systolic.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_systolic.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_systolic.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_systolic.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_systolic.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in3" output="mac18x18_systolic.bx_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_systolic.by_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_systolic.bz_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_systolic.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac18x18_systolic.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac18x18_systolic.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac18x18_systolic.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac18x18_systolic.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in12" output="mac18x18_systolic.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in13" output="mac18x18_systolic.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in14" output="mac18x18_systolic.coef_sel_b_clk"/>
            </interconnect>
          </mode>

            <!-- 27x27 independent multiplier mode -->
          <mode name="m27x27.input_type{reg}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{comb}" name="mac27x27" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="27"/>
              <input name="ay" num_pins="27"/>
              <input name="az" num_pins="26"/>
              <input name="coefsela" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="scanin" num_pins="27"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="27"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac27x27.chainin"/>
              <direct input="mac27x27.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin" name="scan_in" output="mac27x27.scanin"/>
              <direct input="mac27x27.scanout" name="scan_out" output="dsp_prim.scanout"/>
              <direct input="mac27x27.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
              <direct input="dsp_prim.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
              <direct input="dsp_prim.datain[79:54]" name="az_in" output="mac27x27.az"/>
              <direct input="mac27x27.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac27x27.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac27x27.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac27x27.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac27x27.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac27x27.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac27x27.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac27x27.sub_clk"/>
            </interconnect>
          </mode>

          <mode name="m27x27.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{reg}" name="mac27x27" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="27"/>
              <input name="ay" num_pins="27"/>
              <input name="az" num_pins="26"/>
              <input name="coefsela" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="scanin" num_pins="27"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="27"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac27x27.chainin"/>
              <direct input="mac27x27.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin" name="scan_in" output="mac27x27.scanin"/>
              <direct input="mac27x27.scanout" name="scan_out" output="dsp_prim.scanout"/>
              <direct input="mac27x27.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
              <direct input="dsp_prim.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
              <direct input="dsp_prim.datain[79:54]" name="az_in" output="mac27x27.az"/>
              <direct input="mac27x27.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac27x27.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac27x27.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac27x27.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac27x27.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac27x27.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac27x27.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac27x27.sub_clk"/>
            </interconnect>
          </mode>

          <mode name="m27x27.input_type{comb}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{comb}" name="mac27x27" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="27"/>
              <input name="ay" num_pins="27"/>
              <input name="az" num_pins="26"/>
              <input name="coefsela" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="scanin" num_pins="27"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="27"/>
              <output name="dftout" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac27x27.chainin"/>
              <direct input="mac27x27.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin" name="scan_in" output="mac27x27.scanin"/>
              <direct input="mac27x27.scanout" name="scan_out" output="dsp_prim.scanout"/>
              <direct input="mac27x27.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
              <direct input="dsp_prim.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
              <direct input="dsp_prim.datain[79:54]" name="az_in" output="mac27x27.az"/>
              <direct input="mac27x27.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac27x27.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac27x27.sub"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac27x27.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac27x27.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac27x27.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac27x27.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac27x27.sub_clk"/>
            </interconnect>
          </mode>

          <mode name="m27x27.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{reg}" name="mac27x27" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="27"/>
              <input name="ay" num_pins="27"/>
              <input name="az" num_pins="26"/>
              <input name="coefsela" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="scanin" num_pins="27"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="27"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="loadconst_clk" num_pins="1"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="chainout_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.chainin" name="chain_in" output="mac27x27.chainin"/>
              <direct input="mac27x27.chainout" name="chain_out" output="dsp_prim.chainout"/>
              <direct input="dsp_prim.scanin" name="scan_in" output="mac27x27.scanin"/>
              <direct input="mac27x27.scanout" name="scan_out" output="dsp_prim.scanout"/>
              <direct input="mac27x27.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[26:0]" name="ax_in" output="mac27x27.ax"/>
              <direct input="dsp_prim.datain[53:27]" name="ay_in" output="mac27x27.ay"/>
              <direct input="dsp_prim.datain[79:54]" name="az_in" output="mac27x27.az"/>
              <direct input="mac27x27.resulta" name="resulta_out" output="dsp_prim.result[63:0]"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac27x27.negate"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac27x27.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac27x27.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac27x27.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac27x27.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac27x27.dfxmisrena"/>
              <direct input="dsp_prim.controlin[13]" name="accumulate_in" output="mac27x27.accumulate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac27x27.sub"/>
              <direct input="dsp_prim.controlin[14]" name="loadconst_in" output="mac27x27.loadconst"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac27x27.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac27x27.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac27x27.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac27x27.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac27x27.loadconst_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac27x27.accumulate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in8" output="mac27x27.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in9" output="mac27x27.chainout_clk"/>
              <complete input="dsp_prim.clk" name="clk_in10" output="mac27x27.coef_sel_a_clk"/>
              <complete input="dsp_prim.clk" name="clk_in11" output="mac27x27.sub_clk"/>
            </interconnect>
          </mode>

            <!-- single 18x18 multiplier mode -->
          <mode name="m18x18_top.input_type{reg}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{comb}" name="mac18x18_top" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="18"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="37"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
              <direct input="mac18x18_top.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_top.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
              <direct input="dsp_prim.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
              <direct input="dsp_prim.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
              <direct input="mac18x18_top.resulta" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_top.input_type{comb}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{reg}" name="mac18x18_top" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="18"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="37"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
              <direct input="mac18x18_top.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_top.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
              <direct input="dsp_prim.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
              <direct input="dsp_prim.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
              <direct input="mac18x18_top.resulta" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_top.input_type{comb}.output_type{comb}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{comb}.output_type{comb}" name="mac18x18_top" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="18"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="37"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
              <direct input="mac18x18_top.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_top.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
              <direct input="dsp_prim.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
              <direct input="dsp_prim.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
              <direct input="mac18x18_top.resulta" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
            </interconnect>
          </mode>

          <mode name="m18x18_top.input_type{reg}.output_type{reg}">
            <pb_type blif_model=".subckt fourteennm_mac.opmode{m18x18_top}.input_type{reg}.output_type{reg}" name="mac18x18_top" num_pb="1">
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="18"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="scanin" num_pins="19"/>
              <input name="ena" num_pins="3"/>
              <input name="sub" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>
              <output name="resulta" num_pins="37"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
              <clock name="ax_clk" num_pins="1"/>
              <clock name="ay_scan_in_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="sub_clk" num_pins="1"/>
              <clock name="negate_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <clock name="coef_sel_a_clk" num_pins="1"/>
            </pb_type>
            <interconnect>
              <direct input="dsp_prim.scanin[18:0]" name="scan_in" output="mac18x18_top.scanin"/>
              <direct input="mac18x18_top.scanout" name="scan_out" output="dsp_prim.scanout[18:0]"/>
              <direct input="mac18x18_top.dftout" name="dft_out" output="dsp_prim.dftout"/>
              <direct input="dsp_prim.datain[17:0]" name="ax_in" output="mac18x18_top.ax"/>
              <direct input="dsp_prim.datain[35:18]" name="ay_in" output="mac18x18_top.ay"/>
              <direct input="dsp_prim.datain[53:36]" name="az_in" output="mac18x18_top.az"/>
              <direct input="mac18x18_top.resulta" name="resulta_out" output="dsp_prim.result[36:0]"/>
              <direct input="dsp_prim.controlin[15]" name="negate_in" output="mac18x18_top.negate"/>
              <direct input="dsp_prim.controlin[16]" name="sub_in" output="mac18x18_top.sub"/>
              <direct input="dsp_prim.controlin[1:0]" name="clr_in" output="mac18x18_top.clr"/>
              <direct input="dsp_prim.controlin[4:2]" name="coefsela_in" output="mac18x18_top.coefsela"/>
              <direct input="dsp_prim.controlin[10:8]" name="ena_in" output="mac18x18_top.ena"/>
              <direct input="dsp_prim.controlin[11]" name="dfxlfsrena_in" output="mac18x18_top.dfxlfsrena"/>
              <direct input="dsp_prim.controlin[12]" name="dfxmisrena_in" output="mac18x18_top.dfxmisrena"/>
              <complete input="dsp_prim.clk" name="clk_in0" output="mac18x18_top.ax_clk"/>
              <complete input="dsp_prim.clk" name="clk_in1" output="mac18x18_top.ay_scan_in_clk"/>
              <complete input="dsp_prim.clk" name="clk_in2" output="mac18x18_top.az_clk"/>
              <complete input="dsp_prim.clk" name="clk_in4" output="mac18x18_top.sub_clk"/>
              <complete input="dsp_prim.clk" name="clk_in5" output="mac18x18_top.negate_clk"/>
              <complete input="dsp_prim.clk" name="clk_in6" output="mac18x18_top.output_clk"/>
              <complete input="dsp_prim.clk" name="clk_in7" output="mac18x18_top.coef_sel_a_clk"/>
            </interconnect>
          </mode>


          <!-- fp multiplication mode -->
          <mode name="sp_mult.input_type{reg}.output_type{comb}">
            <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_mult.chainin"/>
                  <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_mult.dftout" output="dsp_prim.dftout"/>

                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_mult.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_mult.az"/>

                  <direct name="resulta_out" input="fp_mac_mult.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_mult.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_mult.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_mult.ay_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_mult.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_mult.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_mult.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_mult.chainin"/>
                  <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_mult.dftout" output="dsp_prim.dftout"/>

                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_mult.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_mult.az"/>

                  <direct name="resulta_out" input="fp_mac_mult.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_mult.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_mult.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_mult.ay_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_mult.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_mult.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_mult.input_type{comb}.output_type{comb}">
            <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{comb}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>

                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_mult.chainin"/>
                  <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_mult.dftout" output="dsp_prim.dftout"/>

                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_mult.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_mult.az"/>

                  <direct name="resulta_out" input="fp_mac_mult.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_mult.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_mult.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_mult.dfxmisrena"/>


                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_mult.ay_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_mult.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_mult.output_clk"/>
              </interconnect> 
          </mode>

          <mode name="sp_mult.input_type{reg}.output_type{reg}">
            <pb_type name="fp_mac_mult" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_mult.chainin"/>
                  <direct name="chain_out" input="fp_mac_mult.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_mult.dftout" output="dsp_prim.dftout"/>

                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_mult.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_mult.az"/>

                  <direct name="resulta_out" input="fp_mac_mult.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="mult_inexact_out" input="fp_mac_mult.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_mult.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_mult.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_mult.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_mult.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_mult.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_mult.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_mult.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_mult.ay_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_mult.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_mult.output_clk"/>

              </interconnect> 
          </mode>

          <!-- fp multiply accumulate mode -->
          <mode name="sp_mult_acc.input_type{comb}.output_type{reg}">
            <pb_type name="fp_mac_multacc" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{comb}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="32"/>
              <input name="clr" num_pins="2"/>
              <clock name="accumulate_clk" num_pins="1"/>
              <clock name="az_clk" num_pins="1"/>
              <clock name="ay_clk" num_pins="1"/>
              <clock name="output_clk" num_pins="1"/>
              <input name="ay" num_pins="32"/>
              <input name="az" num_pins="32"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="32"/>
              <output name="resulta" num_pins="32"/>
              <output name="adder_inexact" num_pins="1"/>
              <output name="adder_invalid" num_pins="1"/>
              <output name="adder_overflow" num_pins="1"/>
              <output name="adder_underflow" num_pins="1"/>
              <output name="mult_inexact" num_pins="1"/>
              <output name="mult_invalid" num_pins="1"/>
              <output name="mult_overflow" num_pins="1"/>
              <output name="mult_underflow" num_pins="1"/>
              <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

              <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multacc.chainin"/>
              <direct name="chain_out" input="fp_mac_multacc.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
              <direct name="dft_out" input="fp_mac_multacc.dftout" output="dsp_prim.dftout"/>

              <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multacc.ay"/>
              <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multacc.az"/>

              <direct name="resulta_out" input="fp_mac_multacc.resulta" output="dsp_prim.result[31:0]"/>
              <direct name="adder_inexact_out" input="fp_mac_multacc.adder_inexact" output="dsp_prim.result[32]" />
              <direct name="adder_invalid_out" input="fp_mac_multacc.adder_invalid" output="dsp_prim.result[33]" />
              <direct name="adder_overflow_out" input="fp_mac_multacc.adder_overflow" output="dsp_prim.result[34]" />
              <direct name="adder_underflow_out" input="fp_mac_multacc.adder_underflow" output="dsp_prim.result[35]" />
              <direct name="mult_inexact_out" input="fp_mac_multacc.mult_inexact" output="dsp_prim.result[36]" />
              <direct name="mult_invlid_out" input="fp_mac_multacc.mult_invalid" output="dsp_prim.result[37]" />
              <direct name="mult_overflow_out" input="fp_mac_multacc.mult_overflow" output="dsp_prim.result[38]" />
              <direct name="mult_underflow_out" input="fp_mac_multacc.mult_underflow" output="dsp_prim.result[39]" />

              
              <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multacc.clr"/>
              <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multacc.ena"/>
              <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multacc.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multacc.dfxmisrena"/>
              <direct name="accumulate" input="dsp_prim.controlin[13]" output="fp_mac_multacc.accumulate"/>

              <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multacc.az_clk"/>
              <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multacc.ay_clk"/>
              <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multacc.output_clk"/>
              <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multacc.accumulate_clk"/>

            </interconnect> 
          </mode>

          <mode name="sp_mult_acc.input_type{reg}.output_type{reg}">
              <pb_type name="fp_mac_multacc" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_acc}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="accumulate" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <clock name="accumulate_clk" num_pins="1"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multacc.chainin"/>
                  <direct name="chain_out" input="fp_mac_multacc.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_multacc.dftout" output="dsp_prim.dftout"/>

                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multacc.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multacc.az"/>

                  <direct name="resulta_out" input="fp_mac_multacc.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_multacc.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_multacc.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_multacc.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_multacc.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_multacc.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_multacc.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_multacc.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_multacc.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multacc.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multacc.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multacc.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multacc.dfxmisrena"/>
                  <direct name="accumulate" input="dsp_prim.controlin[13]" output="fp_mac_multacc.accumulate"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multacc.az_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multacc.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multacc.output_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multacc.accumulate_clk"/>

              </interconnect> 
          </mode>

          <!-- fp multiply add mode -->
          <mode name="sp_mult_add.input_type{reg}.output_type{comb}">
              <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                  <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_multadd.dftout" output="dsp_prim.dftout"/>
                  
                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_multadd.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multadd.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multadd.az"/>

                  <direct name="resulta_out" input="fp_mac_multadd.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multadd.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multadd.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>
                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multadd.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multadd.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multadd.ay_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multadd.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_mult_add.input_type{comb}.output_type{reg}">
              <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                  <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_multadd.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_multadd.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multadd.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multadd.az"/>

                  <direct name="resulta_out" input="fp_mac_multadd.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multadd.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multadd.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multadd.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multadd.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multadd.ay_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multadd.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_mult_add.input_type{comb}.output_type{comb}">
              <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{comb}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>

                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                  <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_multadd.dftout" output="dsp_prim.dftout"/>
                  
                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_multadd.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multadd.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multadd.az"/>

                  <direct name="resulta_out" input="fp_mac_multadd.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multadd.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multadd.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multadd.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multadd.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multadd.ay_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multadd.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_mult_add.input_type{reg}.output_type{reg}">
              <pb_type name="fp_mac_multadd" blif_model=".subckt fourteennm_fp_mac.opmode{sp_mult_add}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_multadd.chainin"/>
                  <direct name="chain_out" input="fp_mac_multadd.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_multadd.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_multadd.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_multadd.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_multadd.az"/>

                  <direct name="resulta_out" input="fp_mac_multadd.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_multadd.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_multadd.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_multadd.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_multadd.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_multadd.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_multadd.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_multadd.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_multadd.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_multadd.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_multadd.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_multadd.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_multadd.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_multadd.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_multadd.az_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_multadd.ay_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_multadd.output_clk"/>

              </interconnect> 
          </mode>

          <!-- fp adder or subtract mode -->
          <mode name="sp_add.input_type{reg}.output_type{comb}">
              <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_add.chainin"/>
                  <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_add.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_add.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_add.ay"/>

                  <direct name="resulta_out" input="fp_mac_add.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="dsp_prim.result[35]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_add.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_add.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_add.dfxmisrena"/>
                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_add.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_add.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_add.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_add.input_type{comb}.output_type{reg}">
              <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_add.chainin"/>
                  <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_add.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_add.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_add.ay"/>

                  <direct name="resulta_out" input="fp_mac_add.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="dsp_prim.result[35]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_add.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_add.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_add.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_add.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_add.output_clk"/>
              </interconnect> 
          </mode>

          <mode name="sp_add.input_type{comb}.output_type{comb}">
              <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{comb}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_add.chainin"/>
                  <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_add.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_add.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_add.ay"/>

                  <direct name="resulta_out" input="fp_mac_add.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="dsp_prim.result[35]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_add.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_add.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_add.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_add.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_add.output_clk"/>

              </interconnect> 
          </mode>
          
          <mode name="sp_add.input_type{reg}.output_type{reg}">
              <pb_type name="fp_mac_add" blif_model=".subckt fourteennm_fp_mac.opmode{sp_add}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_add.chainin"/>
                  <direct name="chain_out" input="fp_mac_add.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_add.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_add.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_add.ay"/>

                  <direct name="resulta_out" input="fp_mac_add.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_add.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_add.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_add.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_add.adder_underflow" output="dsp_prim.result[35]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_add.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_add.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_add.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_add.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_add.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_add.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_add.output_clk"/>

              </interconnect> 
          </mode>

          <!-- fp vector one mode -->
          <mode name="sp_vector1.input_type{reg}.output_type{comb}">
              <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect1.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect1.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect1.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect1.az"/>

                  <direct name="resulta_out" input="fp_mac_vect1.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect1.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect1.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect1.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect1.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect1.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect1.output_clk"/>
              </interconnect> 
          </mode>

          <mode name="sp_vector1.input_type{comb}.output_type{reg}">
              <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect1.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect1.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect1.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect1.az"/>

                  <direct name="resulta_out" input="fp_mac_vect1.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect1.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect1.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>
                  
                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect1.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect1.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect1.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect1.output_clk"/>
            </interconnect> 
          </mode>

          <mode name="sp_vector1.input_type{comb}.output_type{comb}">
              <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{comb}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect1.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect1.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect1.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect1.az"/>

                  <direct name="resulta_out" input="fp_mac_vect1.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect1.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect1.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect1.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect1.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect1.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect1.output_clk"/>
              </interconnect> 
          </mode>

          <mode name="sp_vector1.input_type{reg}.output_type{reg}">
              <pb_type name="fp_mac_vect1" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector1}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect1.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect1.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect1.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect1.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect1.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect1.az"/>

                  <direct name="resulta_out" input="fp_mac_vect1.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect1.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect1.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect1.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect1.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect1.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect1.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect1.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect1.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect1.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect1.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect1.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect1.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect1.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect1.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect1.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect1.output_clk"/>
              </interconnect> 
          </mode>

          <!-- fp vector two mode -->
          <mode name="sp_vector2.input_type{reg}.output_type{comb}">
              <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect2.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect2.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect2.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect2.az"/>

                  <direct name="resulta_out" input="fp_mac_vect2.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect2.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect2.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect2.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect2.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect2.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect2.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_vector2.input_type{comb}.output_type{reg}">
              <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect2.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect2.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect2.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect2.az"/>

                  <direct name="resulta_out" input="fp_mac_vect2.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect2.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect2.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>
                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect2.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect2.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect2.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect2.output_clk"/>

              </interconnect> 
          </mode>

          <mode name="sp_vector2.input_type{comb}.output_type{comb}">
              <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{comb}.output_type{comb}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect2.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect2.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect2.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect2.az"/>

                  <direct name="resulta_out" input="fp_mac_vect2.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect2.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect2.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect2.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect2.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect2.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect2.output_clk"/>


              </interconnect> 
          </mode>

          <mode name="sp_vector2.input_type{reg}.output_type{reg}">
              <pb_type name="fp_mac_vect2" blif_model=".subckt fourteennm_fp_mac.opmode{sp_vector2}.input_type{reg}.output_type{reg}" num_pb="1">
                  <input name="chainin" num_pins="32"/>
                  <input name="clr" num_pins="2"/>
                  <clock name="ax_clk" num_pins="1"/>
                  <clock name="ay_clk" num_pins="1"/>
                  <clock name="az_clk" num_pins="1"/>
                  <clock name="output_clk" num_pins="1"/>
                  <input name="ax" num_pins="32"/>
                  <input name="ay" num_pins="32"/>
                  <input name="az" num_pins="32"/>
                  <input name="ena" num_pins="3"/>
                  <input name="dfxlfsrena" num_pins="1"/>
                  <input name="dfxmisrena" num_pins="1"/>

                  <output name="chainout" num_pins="32"/>
                  <output name="resulta" num_pins="32"/>
                  <output name="adder_inexact" num_pins="1"/>
                  <output name="adder_invalid" num_pins="1"/>
                  <output name="adder_overflow" num_pins="1"/>
                  <output name="adder_underflow" num_pins="1"/>
                  <output name="mult_inexact" num_pins="1"/>
                  <output name="mult_invalid" num_pins="1"/>
                  <output name="mult_overflow" num_pins="1"/>
                  <output name="mult_underflow" num_pins="1"/>
                  <output name="dftout" num_pins="1"/>
              </pb_type>

              <interconnect>

                  <direct name="chain_in" input="dsp_prim.chainin[31:0]" output="fp_mac_vect2.chainin"/>
                  <direct name="chain_out" input="fp_mac_vect2.chainout[31:0]" output="dsp_prim.chainout[31:0]"/>
                  <direct name="dft_out" input="fp_mac_vect2.dftout" output="dsp_prim.dftout"/>

                  <direct name="ax_in" input="dsp_prim.datain[31:0]" output="fp_mac_vect2.ax"/>
                  <direct name="ay_in" input="dsp_prim.datain[63:32]" output="fp_mac_vect2.ay"/>
                  <direct name="az_in" input="dsp_prim.datain[95:64]" output="fp_mac_vect2.az"/>

                  <direct name="resulta_out" input="fp_mac_vect2.resulta" output="dsp_prim.result[31:0]"/>
                  <direct name="adder_inexact_out" input="fp_mac_vect2.adder_inexact" output="dsp_prim.result[32]" />
                  <direct name="adder_invalid_out" input="fp_mac_vect2.adder_invalid" output="dsp_prim.result[33]" />
                  <direct name="adder_overflow_out" input="fp_mac_vect2.adder_overflow" output="dsp_prim.result[34]" />
                  <direct name="adder_underflow_out" input="fp_mac_vect2.adder_underflow" output="dsp_prim.result[35]" />
                  <direct name="mult_inexact_out" input="fp_mac_vect2.mult_inexact" output="dsp_prim.result[36]" />
                  <direct name="mult_invlid_out" input="fp_mac_vect2.mult_invalid" output="dsp_prim.result[37]" />
                  <direct name="mult_overflow_out" input="fp_mac_vect2.mult_overflow" output="dsp_prim.result[38]" />
                  <direct name="mult_underflow_out" input="fp_mac_vect2.mult_underflow" output="dsp_prim.result[39]" />

                  
                  <direct name="clr_in" input="dsp_prim.controlin[1:0]" output="fp_mac_vect2.clr"/>
                  <direct name="ena_in" input="dsp_prim.controlin[10:8]" output="fp_mac_vect2.ena"/>
                  <direct name="dfxlfsrena_in" input="dsp_prim.controlin[11]" output="fp_mac_vect2.dfxlfsrena"/>
                  <direct name="dfxmisrena_in" input="dsp_prim.controlin[12]" output="fp_mac_vect2.dfxmisrena"/>

                  <complete name="clk_in" input="dsp_prim.clk" output="fp_mac_vect2.ax_clk"/>
                  <complete name="clk_in2" input="dsp_prim.clk" output="fp_mac_vect2.ay_clk"/>
                  <complete name="clk_in3" input="dsp_prim.clk" output="fp_mac_vect2.az_clk"/>
                  <complete name="clk_in4" input="dsp_prim.clk" output="fp_mac_vect2.output_clk"/>

              </interconnect> 
          </mode>

        </pb_type>
        <interconnect>
          <direct input="DSP.scanin" name="scan_in" output="dsp_prim.scanin"/>
          <direct input="dsp_prim.scanout" name="scan_out" output="DSP.scanout"/>

          <direct input="DSP.chainin" name="chain_in" output="dsp_prim.chainin"/>
          <direct input="dsp_prim.chainout" name="chain_out" output="DSP.chainout"/>

          <direct input="dsp_prim.dftout" name="dft_out" output="DSP.dftout"/>
          <direct input="dsp_prim.result" name="result_out" output="DSP.result"/>

          <complete input="DSP.dspin" name="data_in" output="dsp_prim.datain"/>
          <complete input="DSP.dspin" name="control_in" output="dsp_prim.controlin"/>
          <complete input="DSP.clk" name="clk_in" output="dsp_prim.clk"/>
        </interconnect>
      </mode>
    </pb_type>
  </complexblocklist>
  <switchblocklist>
    <!-- Stratix 10 uses a uni-directional routing architecture with a Driver Input Mux (DIM) size of 12 (i.e.
           each wire can be driven by one of 12 block/outputs or wires) for the L4s.
           
           In the Stratix IV architecture the long wires (L16 here) are accessible only from the short wires, 
           and are not connected to the block pins (i.e. connection blocks). Furthermore, they only connect 
           to switch blocks every 4 LABs (to avoid expensive deep via stacks).
           We approximate the L16 DIM size as 40:1 (in reality it is a pair of 20:1 (?) muxes with a 2:1 swap mux
           in front, which has nearly the same connectivity as a full 40:1).

           L4 wires
           ================
           At a channel width of 300 there are 260 L4/L4prime wires. At an effective Fc_out of 0.075 
           and 40 LAB outputs this yeilds:

                40 * 2 = 80 outputs per channel  [2 LABs per-channel]

                80 * 0.075 = 6 outputs drive each L4 wire [output connection block]

           This leaves:

                12 - 6 = 6 inputs to the DIMs from other routing wires [switch block]

           Since L4s connect at every switch block, there are:

                260 L16 wires per channel + direction which can drive wires at a particular switchblock
                (via switchpoints 0, 1, 2, 3)

           And for each direction (260 wires) only:

               260 / 4 = 65 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there are 32 L4s starting, and 32 L4s ending; + 1 wire for the 65th)

           Which we allocate as follows:

                L4
                =====
                straight-through connection: 2 (from L4 or L16)
                clock-wise turn            : 2 (from L4 or L16)
                counter-clock-wise turn    : 2 (from L4 or L16)

           L16 wires
           =========
           At a channel width of 300 there are 40 L16 wires (20 in each direction), which do not connect to the input/output connection blocks.
           This leaves 40 inputs to the DIM to select from routing wires (long wires use larger DIMs to improve reachability,
           the area cost is relatively small since they are so rare).

           Since L16s only connect at every 4th switch block there are:

                40 / 4 = 10 L16 wires per channel (5 in each direction) which can drive wires at a particular switchblock
                (via switchpoints 0, 4, 8, 12)

           And for each direction (20 wires) only:

               40 / 16 = 2.25 => 2 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there is one L16 starting, and one L16 ending)
           
           We assign the 40 DIM inputs as follows:

                L16
                =====
                straight-through connection:  3 (from L16)
                straight-through connection: 11 (from L4)
                clock-wise turn            :  3 (from L16)
                clock-wise turn            : 10 (from L4)
                counter clock-wise turn    :  3 (from L16)
                counter clock-wise turn    : 10 (from L4)

           Switch pattern
           ==============
           This switch block is based on the Wilton switch block (see Page 103 of Steve Wilton's PhD Thesis 
           "Architecture and Algorithms for Field-Programmable Gate Arrays with Embedded Memory", 1997):

                left-to-top: W - t
                top-to-right: t + 1
                right-to-bottom: 2*W - 2 - t
                bottom-to-left: t + 1
                left-to-right: t
                top-to-bottom: t

           Since Wilton assumed bidirection routing (while we use unidirectional routing),
           we mirror the clock-wise turns to match the conter-clock-wise specification.
    -->
    <!-- Short H wires have DIM of size 12
         Fan-in distribution: 
         5 of the inputs come from logic block outputs - This is modelled by setting fc_out to the right value
         1 input coming from a long wire - It is assumed that for short wires on the right/left the long wires are coming from the top/bottom
         2 stitches - one from wire of the same type one from other short wires
         4 inputs from short V wires of different type
    -->  
    <!-- Short V wires have DIM of size 15
         Fan-in distribution: 
         6 of the inputs come from logic block outputs - This is modelled by setting fc_out to the right value
         1 input coming from a long wire - It is assumed that for short wires on the top/bottom the long wires are coming from the left/right
         1 stitch from wire of the same type 
         7 inputs from short H wires of different types
    -->  
    <!-- Long wires have DIM of size 50
         The wires share four 12:1 muxes - since this cannot be modelled with the current switch box syntax
         it is approximated that each wire has 50 separate inputs. 
         Fan-in distribution: 
         2 stitches - one optimal and one suboptimal
         10 long wires for turns - 5 from each side 
         38 short wires - only short H wires can drive long wires   
    -->  
    <!-- Describing SB connections from vertical sides to horizontal sides in counter-clockwise direction -->
    <switchblock name="wilton_turn_counter_clockwise_v2h_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="tl" formula="W-t"/>
        <!-- top to left -->
        <func type="br" formula="2*W-2-t"/>
        <!-- bottom to right -->
      </switchfuncs>
      
      <!--  H2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V2" from_switchpoint="0,1" to_type="H2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H2" to_switchpoint="0" from_order="shuffled"/>

      <!-- H4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V2" from_switchpoint="0,1" to_type="H4" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H4" to_switchpoint="0" from_order="shuffled"/>


      <!-- H10 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V2" from_switchpoint="0,1" to_type="H10" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H10" to_switchpoint="0" from_order="shuffled"/>

      <!-- H24 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The five inputs coming from the long wires of one vertical side -->
      <wireconn num_conns="5*to" from_type="V16" from_switchpoint="0,8,12" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
    </switchblock>

    <!-- Describing SB connections from vertical sides to horizontal sides in clockwise direction -->
    <switchblock name="wilton_turn_clockwise_v2h_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="tr" formula="t+1"/>
        <!-- top to right -->
        <func type="bl" formula="t+1"/>
        <!-- bottom to left -->
      </switchfuncs>
      
      <!--  H2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="V16" from_switchpoint="0,8,12" to_type="H2" to_switchpoint="0" from_order="shuffled"/>
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V4" from_switchpoint="0,1,2,3" to_type="H2" to_switchpoint="0" from_order="shuffled"/>

      <!-- H4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="V16" from_switchpoint="0,8,12" to_type="H4" to_switchpoint="0" from_order="shuffled"/>
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H4" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V4" from_switchpoint="0,1,2,3" to_type="H4" to_switchpoint="0" from_order="shuffled"/>


      <!-- H10 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="V16" from_switchpoint="0,8,12" to_type="H10" to_switchpoint="0" from_order="shuffled"/>
      <!-- Half of the four inputs coming from the short v wires (the other half comes from the other vertical side) -->
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0,1,2" to_type="H10" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V4" from_switchpoint="0,1,2,3" to_type="H10" to_switchpoint="0" from_order="shuffled"/>

      <!-- H24 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The five inputs coming from the long wires of one vertical side -->
      <wireconn num_conns="5*to" from_type="V16" from_switchpoint="0,8,12" to_type="H24" to_switchpoint="0" from_order="shuffled"/>

    </switchblock>

    <!-- Describing SB connections going straight in horizontal direction -->
    <switchblock name="wilton_turn_straight_h2h_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="lr" formula="t"/>
        <!-- left to right -->
        <func type="rl" formula="t"/>
        <!-- right to left -->
      </switchfuncs>
      
      <!--  H2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The two stitches -->
      <wireconn num_conns="to" from_type="H2" from_switchpoint="0" to_type="H2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H10" from_switchpoint="0" to_type="H2" to_switchpoint="0" from_order="shuffled"/>

      <!-- H4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The two stitches -->
      <wireconn num_conns="to" from_type="H10" from_switchpoint="0" to_type="H4" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H4" from_switchpoint="0" to_type="H4" to_switchpoint="0" from_order="shuffled"/>

      <!-- H10 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The two stitches -->
      <wireconn num_conns="to" from_type="H4" from_switchpoint="0" to_type="H10" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H10" from_switchpoint="0" to_type="H10" to_switchpoint="0" from_order="shuffled"/>


      <!-- H24 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- 38 inputs coming from short h wires -->
      <wireconn num_conns="4*to" from_type="H2" from_switchpoint="0,1" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="14*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="20*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
      <!-- one optimal and one sub-optimal stitch -->
      <wireconn num_conns="to" from_type="H24" from_switchpoint="0" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H24" from_switchpoint="23" to_type="H24" to_switchpoint="0" from_order="shuffled"/>
    </switchblock>

    <!-- Describing SB connections from horizontal sides to vertical sides in counter-clockwise direction -->
    <switchblock name="wilton_turn_counter_clockwise_h2v_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="rt" formula="t+1"/>
        <!-- right to top -->
        <func type="lb" formula="t+1"/>
        <!-- left to bottom -->
      </switchfuncs>
      
      <!--  V2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Three of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="to" from_type="H2" from_switchpoint="0,1" to_type="V2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V2" to_switchpoint="0" from_order="shuffled"/>

      <!-- V3 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Three of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="2*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V3" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V3" to_switchpoint="0" from_order="shuffled"/>


      <!-- V4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- Three of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V4" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="2*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V4" to_switchpoint="0" from_order="shuffled"/>

      <!-- V16 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The five inputs coming from the long wires of one horizontal side -->
      <wireconn num_conns="5*to" from_type="H24" from_switchpoint="0,7,15" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <!-- half of the 38 inputs coming from short h wires (the remaining comes from the other horizontal side)-->
      <wireconn num_conns="2*to" from_type="H2" from_switchpoint="0,1" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="7*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="10*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
    </switchblock>

    <!-- Describing SB connections from horizontal sides to vertical sides in clockwise direction -->
    <switchblock name="wilton_turn_clockwise_h2v_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="rt" formula="t+1"/>
        <!-- right to top -->
        <func type="lb" formula="t+1"/>
        <!-- left to bottom -->
      </switchfuncs>
      
      <!--  V2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="H24" from_switchpoint="0,7,15" to_type="V2" to_switchpoint="0" from_order="shuffled"/>
      <!-- Four of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="to" from_type="H2" from_switchpoint="0,1" to_type="V2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V2" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="2*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V2" to_switchpoint="0" from_order="shuffled"/>

      <!-- V3 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="H24" from_switchpoint="0,7,15" to_type="V3" to_switchpoint="0" from_order="shuffled"/>
      <!-- Four of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="2*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V3" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="2*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V3" to_switchpoint="0" from_order="shuffled"/>


      <!-- V4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The input coming from the long wire -->
      <wireconn num_conns="to" from_type="H24" from_switchpoint="0,7,15" to_type="V4" to_switchpoint="0" from_order="shuffled"/>
      <!-- Four of the seven inputs coming from the short h wires (the remaining comes from the other horizontal side) -->
      <wireconn num_conns="2*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V4" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="2*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V4" to_switchpoint="0" from_order="shuffled"/>

      <!-- V16 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- The five inputs coming from the long wires of one horizontal side -->
      <wireconn num_conns="5*to" from_type="H24" from_switchpoint="0,7,15" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <!-- half of the 38 inputs coming from short h wires (the remaining comes from the other horizontal side)-->
      <wireconn num_conns="3*to" from_type="H2" from_switchpoint="0,1" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="7*to" from_type="H4" from_switchpoint="0,1,2,3" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="9*to" from_type="H10" from_switchpoint="0,2,4,6,8" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
    </switchblock>


    <!-- Describing SB connections going straight in vertical direction -->
    <switchblock name="wilton_turn_straight_v2v_core" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="lr" formula="t"/>
        <!-- left to right -->
        <func type="rl" formula="t"/>
        <!-- right to left -->
      </switchfuncs>
      
      <!--  V2 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- one stitch -->
      <wireconn num_conns="to" from_type="V2" from_switchpoint="0" to_type="V2" to_switchpoint="0" from_order="shuffled"/>

      <!-- V3 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- one stitch -->
      <wireconn num_conns="to" from_type="V3" from_switchpoint="0" to_type="V3" to_switchpoint="0" from_order="shuffled"/>

      <!-- V4 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- one stitch -->
      <wireconn num_conns="to" from_type="V4" from_switchpoint="0" to_type="V4" to_switchpoint="0" from_order="shuffled"/>


      <!-- V16 drivers -->
      <!-- shuffling switchpoints for more diversity -->
      <!-- one optimal and one sub-optimal stitch -->
      <wireconn num_conns="to" from_type="V16" from_switchpoint="0" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
      <wireconn num_conns="to" from_type="V16" from_switchpoint="15" to_type="V16" to_switchpoint="0" from_order="shuffled"/>
    </switchblock>

  </switchblocklist>
</architecture>