  <models>

    <!-- LAB Primitives -->
    <model name="fourteennm_lcell_comb">
      <input_ports>
        <port name="dataa" combinational_sink_ports="combout sumout cout"/>
        <port name="datab" combinational_sink_ports="combout sumout cout"/>
        <port name="datac" combinational_sink_ports="combout sumout cout"/>
        <port name="datad" combinational_sink_ports="combout sumout cout"/>
        <port name="datae" combinational_sink_ports="combout"/>
        <port name="dataf" combinational_sink_ports="combout"/>
        <port name="datag" combinational_sink_ports="combout"/>
        <port name="datah" combinational_sink_ports="combout"/>
        <port name="cin" combinational_sink_ports="sumout cout"/>
      </input_ports>
      <output_ports>
        <port name="combout"/>
        <port name="sumout"/>
        <port name="cout"/>
      </output_ports>
    </model>

    <model name="fourteennm_ff">
      <input_ports>
        <port name="clk" is_clock="1"/>
        <port name="ena" clock="clk"/>
        <port name="clrn" clock="clk"/>
        <port name="sclr" clock="clk"/>
        <port name="d" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="q" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_mlab_cell">
      <input_ports>
        <port name="clk0" is_clock="1"/>
        <port name="ena0" clock="clk0"/>
        <port name="clr" clock="clk0"/>
        <port name="portaaddr" clock="clk0"/>
        <port name="portabyteenamasks" clock="clk0"/>
        <port name="portadatain" clock="clk0"/>
        <port name="portbaddr" clock="clk0"/>
      </input_ports>
      <output_ports>
        <port name="portbdataout" clock="clk0"/>
      </output_ports>
    </model>

    <!-- OCT Primitives -->
    <model name="fourteennm_termination">
      <input_ports>
        <port name="rzqin" clock="clkusr"/> 
        <port name="enserusr" clock="clkusr"/> 
        <port name="nclrusr" clock="clkusr"/>
        <port name="clkenusr" clock="clkusr"/>
        <port name="clkusr" is_clock="1"/>
        <port name="ser_data_dq_from_core" clock="clkusr"/>
        <port name="ser_data_ca_from_core" clock="clkusr"/>
        <port name="test_clkusr_en_n" clock="clkusr"/>
        <port name="oct_scanin" clock="clkusr"/>
      </input_ports>
      <output_ports>
        <port name="clkusr_dft_out" clock="clkusr"/>
        <port name="oct_scanout" clock="clkusr"/>
        <port name="compout_rdn" clock="clkusr"/>
        <port name="compout_rup" clock="clkusr"/>
        <port name="serdataout" clock="clkusr"/>
        <port name="ser_data_dq_to_core" clock="clkusr"/>
        <port name="ser_data_ca_to_core" clock="clkusr"/>
      </output_ports>
    </model>

    <model name="fourteennm_termination_logic">
      <input_ports>
        <port name="s2pload" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="serdata" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
        <port name="scan_shift_in" combinational_sink_ports="scan_out seriesterminationcontrol parallelterminationcontrol" />
      </input_ports>
      <output_ports>
        <port name="scan_out" />
        <port name="seriesterminationcontrol" />
        <port name="parallelterminationcontrol" />
      </output_ports>
    </model>

    <!-- PLL Primitive -->
    <model name="fourteennm_iopll">
      <input_ports>
        <port name="clkena" clock="refclk"/>
        <port name="cnt_sel" clock="refclk"/> 
        <port name="core_refclk" clock="refclk"/> 
        <port name="dps_rst_n" clock="refclk"/> 
        <port name="extswitch" clock="refclk"/> 
        <port name="fbclk_in" clock="refclk"/> 
        <port name="fblvds_in" clock="refclk"/> 
        <port name="refclk" is_clock="1"/> 
        <port name="mdio_dis" clock="refclk"/>
        <port name="rst_n" clock="refclk"/>
        <port name="num_phase_shifts" clock="refclk"/> 
        <port name="pfden" clock="refclk"/> 
        <port name="pll_cascade_in" clock="refclk"/> 
        <port name="scan_mode_n" clock="refclk"/> 
        <port name="scan_shift_n" clock="refclk"/>
        <port name="uc_cal_writedata" clock="refclk"/>  -->
        <port name="up_dn" clock="refclk"/> 
        <port name="user_mode" clock="refclk"/> 
        <port name="zdb_in" clock="refclk"/> 
      </input_ports>
      <output_ports>
        <port name="block_select" clock="refclk"/>
        <port name="clk0_bad" clock="refclk"/> 
        <port name="clk1_bad" clock="refclk"/> 
        <port name="clksel" clock="refclk"/>
        <port name="cal_ok" clock="refclk"/> 
        <port name="core_avl_busy" clock="refclk"/>
        <port name="core_cal_done" clock="refclk"/>
        <port name="extclk_output" clock="refclk"/> 
        <port name="extclk_dft" clock="refclk"/>
        <port name="fblvds_out" clock="refclk"/>
        <port name="lf_reset" clock="refclk"/> 
        <port name="loaden" clock="refclk"/> 
        <port name="lock" clock="refclk"/> 
        <port name="lock2io12lane0" clock="refclk"/> 
        <port name="lock2io12lane1" clock="refclk"/> 
        <port name="lock2io12lane2" clock="refclk"/> 
        <port name="lock2io12lane3" clock="refclk"/> 
        <port name="lock2iohmc" clock="refclk"/> 
        <port name="phase_done" clock="refclk"/> 
        <port name="pll_cascade_out" clock="refclk"/> 
        <port name="pll_pd" clock="refclk"/> 
        <port name="outclk" clock="refclk"/> 
        <port name="dll_output" clock="refclk"/> 
        <port name="fbclk_out" clock="refclk"/> 
        <port name="uc_cal_readdata" clock="refclk"/>
        <port name="vcop_en" clock="refclk"/>
        <port name="vcoph" clock="refclk"/> 
        <port name="iopll_out_sig1" clock="refclk"/>
        <port name="iopll_out_sig2" clock="refclk"/>
      </output_ports>
    </model>

    <!-- IO Primitives -->
    <model name="fourteennm_io_obuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar"/> 
        <port name="oe" combinational_sink_ports="o obar"/> 
        <port name="dynamicterminationcontrol" combinational_sink_ports="o obar"/> 
        <port name="seriesterminationcontrol" combinational_sink_ports="o obar"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o obar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
      </output_ports>
    </model>

    <model name="fourteennm_io_ibuf">
      <input_ports>
        <port name="i" combinational_sink_ports="o"/>
        <port name="ibar" combinational_sink_ports="o"/>
        <port name="dynamicterminationcontrol" combinational_sink_ports="o"/>
        <port name="seriesterminationcontrol" combinational_sink_ports="o"/>
        <port name="parallelterminationcontrol" combinational_sink_ports="o"/>
      </input_ports>
      <output_ports>
        <port name="o" />
      </output_ports>
    </model>

    <model name="fourteennm_pseudo_diff_out">
      <input_ports>
        <port name="i" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="ibar" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oein" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="oebin"  combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
        <port name="dtcbarin" combinational_sink_ports="o obar oeout oebout dtc dtcbar"/>
      </input_ports>
      <output_ports>
        <port name="o" />
        <port name="obar" />
        <port name="oeout" />
        <port name="oebout" />
        <port name="dtc" />
        <port name="dtcbar" />
      </output_ports>
    </model>

    <model name="fourteennm_ddio_out">
      <input_ports>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <clock name="clk" is_clock="1"/>
        <port name="clkhi" clock="clk"/>
        <port name="clklo" clock="clk"/>
        <port name="muxsel" clock="clk"/>
        <port name="datainlo" clock="clk"/>
        <port name="datainhi" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="dataout" clock="clk"/>
      </output_ports>
    </model>

    <model name="fourteennm_ddio_in">
      <input_ports>
        <clock name="clk" is_clock="1"/>
        <port name="clkn" clock="clk"/>
        <port name="areset" clock="clk"/>
        <port name="sreset" clock="clk"/>
        <port name="ena" clock="clk"/>
        <port name="datain" clock="clk"/>
      </input_ports>
      <output_ports>
        <port name="regoutlo" clock="clk"/>
        <port name="regouthi" clock="clk"/>
      </output_ports>
    </model>
  </models>
  <tiles>
    <tile name="LAB">
      <sub_tile name="LAB">
        <equivalent_sites>
          <site pb_type="LAB" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="data_in" num_pins="80" equivalent="full"/>
        <input name="control_in" num_pins="5" equivalent="full"/>
        <input name="cin" num_pins="1" equivalent="none"/>
        <!-- Stratix 10 does have instance equivalence only for the data_out port
             where ALM outputs can be swapped to reach the most suitable pin location
             for routers. However, it may require significant changes to packing results
             which is not supported yet.
             Therefore, we assume full equivalence here, so that ALM outputs can be swapped
             through a local routing architecture without changing packing results.
             Please note that this may cause optimistic routing results, being
             better in routability than what actual hardware can support
          -->
        <output name="data_out" num_pins="40" equivalent="full"/>
        <output name="cout" num_pins="1" equivalent="none"/>
        <clock name="clk" num_pins="2"/>
        <fc in_type="frac" in_val="0.0275" out_type="frac" out_val="0.0375">
          <!-- Based on mux size info Startix 10 has approximately the following effective Fc values:
                   Fc_in: 0.055
                   Fc_out: 0.075

               However, we allow half the pins to connect to the left side, the other half to the right side
               and all pins to connect to the top side of the LAB (3-sided architecture).

               As a result we divide the effective Fc values by 2 (since each pin can connect to two sides)
               to keep roughly the same number of switches, yielding:

                    Fc_in: 0.0275
                    Fc_out: 0.0375
               -->
          <!--Chains do not connect to general global routing-->
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
          <!-- Stratix 10 is a 3 sided architecture, the LABs can connect to routing on their
               left, top, and right.  To model this we spread the various ports around the three sides.

               The exceptions to the above are the LAB chain ports, which propogate downward between blocks.

               We model that half the pins can connect to each vertical channel (left/right),
               and all can connect to the horizontal channel (top). This models the fact that
               each block pin can connect to some Vertical and some Horizontal wires in Stratix IV.
               Note that Fc_in/Fc_out have been scaled to account for this.
             -->
          <loc side="left">  LAB.data_in[0:39]  LAB.control_in[0:3] LAB.data_out[0:19]  LAB.clk</loc>
          <loc side="right"> LAB.data_in[40:79] LAB.control_in[4:6] LAB.data_out[20:39]</loc>
          <loc side="top">   LAB.data_in        LAB.control_in      LAB.data_out        LAB.clk    LAB.cin LAB.sharein</loc>
          <loc side="bottom">LAB.cout</loc>
        </pinlocations>
      </sub_tile>
    </tile>

   <tile height="1" name="PLL">
      <sub_tile name="PLL">
        <equivalent_sites>
          <site pb_type="PLL" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="in_signal" num_pins="14"/>
        <clock name="in_clock" num_pins="2"/>
        <output name="out_clock" num_pins="10"/>
        <output name="out_signal" num_pins="10"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">PLL.in_signal PLL.in_clock PLL.out_clock PLL.out_signal</loc>
          <loc side="right">PLL.in_signal PLL.in_clock PLL.out_clock PLL.out_signal</loc>
          <loc side="top">PLL.in_signal PLL.in_clock PLL.out_clock PLL.out_signal</loc>
          <loc side="bottom">PLL.in_signal PLL.in_clock PLL.out_clock PLL.out_signal</loc>
        </pinlocations>
      </sub_tile>
    </tile>

    <tile height="1" name="PLL">
      <sub_tile name="PLL">
        <equivalent_sites>
          <site pb_type="PLL" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="core_in" num_pins="10"/>
        <output name="core_out" num_pins="36"/>
        <clock name="clk" num_pins="2"/>
        <fc in_type="frac" in_val="0.055" out_type="frac" out_val="0.075"/>
        <pinlocations pattern="custom">
          <loc side="left">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="right">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="top">PLL.core_in PLL.core_out PLL.clk </loc>
          <loc side="bottom">PLL.core_in PLL.core_out PLL.clk </loc>
        </pinlocations>
      </sub_tile>
    </tile>

  </tiles>
  <complexblocklist>

    <pb_type name="PLL" num_pb="1">
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="2"/>

      <pb_type blif_model=".subckt fourteennm_iopll" name="iopll" num_pb="1">
        <input name="clkena" num_pins="2"/>
        <input name="cnt_sel" num_pins="4"/> <!-- counter selector for dynamic phase shift -->
        <!--<input name="dprio_address" num_pins="9"/>  --><!--  Avalon-MM Interface - address of the databus for dynamic partial reconfiguration -->
        <!--<input name="dprio_clk" num_pins="1"/> --> <!--  Avalon-MM Interface - clock port for dynamic partial reconfiguration -->
        <!--<input name="read" num_pins="1"/>  --><!--  Avalon-MM Interface - indicate a read operation during dynamic partial reconfiguration -->
        <!--<input name="write" num_pins="1"/>  --><!--  Avalon-MM Interface - indicate a write operation during dynamic partial reconfiguration -->
        <!--<input name="writedata" num_pins="8"/> --> <!--  Avalon-MM Interface - data to be written to the given address during dynamic partial reconfiguration -->
        <input name="core_refclk" num_pins="1"/> <!-- use core clock as an input reference clock -->
        <!--<input name="csr_clk" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface - clock signal-->
        <!--<input name="csr_en" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface - enable signal-->
        <!--<input name="csr_in" num_pins="1"/>--> <!--Avalon-MM control-and-status register (CSR) agent interface -->
        <!--<<input name="dprio_rst_n" num_pins="1"/>>--> <!--  Avalon-MM Interface - reset port for dynamic partial reconfiguration -->
        <input name="dps_rst_n" num_pins="1"/> <!--  dynamic phase shift reset -->
        <input name="extswitch" num_pins="1"/> <!--  controlling clock switchover -->
        <input name="fbclk_in" num_pins="1"/> <!--  feedback clock used for external feedback compensation -->
        <input name="fblvds_in" num_pins="1"/> <!--  feedback clock used for LVDS compensation -->
        <clock name="refclk" num_pins="4"/> <!--  reference clock source driving the IO PLL -->
        <input name="mdio_dis" num_pins="1"/>
        <input name="rst_n" num_pins="1"/>
        <input name="num_phase_shifts" num_pins="3"/> <!--  number of phase shifts per dynamic phase shift operation -->
        <input name="pfden" num_pins="1"/> <!--  enabling dynamic phase shift operation -->
        <!--<input name="pipeline_global_en_n" num_pins="1"/>-->
        <!--  <input name="pma_csr_test_dis" num_pins="1"/> --> <!-- disable PMA CSR test  -->
        <input name="pll_cascade_in" num_pins="1"/> <!-- cascade input from IO PLL in the same IO column  -->
        <input name="scan_mode_n" num_pins="1"/> <!-- dynamic phase shift clock -->
        <input name="scan_shift_n" num_pins="1"/>
        <!-- <input name="uc_cal_addr" num_pins="20"/>
        <input name="uc_cal_clk" num_pins="1"/>
        <input name="uc_cal_read" num_pins="1"/>
        <input name="uc_cal_write" num_pins="1"/>
        <input name="uc_cal_writedata" num_pins="8"/>  -->
        <input name="up_dn" num_pins="1"/> <!-- direction of phase shift -->
        <input name="user_mode" num_pins="1"/> <!-- enable user mode  -->
        <input name="zdb_in" num_pins="1"/> <!-- zero delay buffer compensation feedback -->

        <output name="block_select" num_pins="1"/>
        <output name="clk0_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clk1_bad" num_pins="1"/> <!-- indicates the status of reference clock (whether it is good or bad) -->
        <output name="clksel" num_pins="1"/>
        <output name="cal_ok" num_pins="1"/> <!-- indicates the calibration status -->
        <output name="core_avl_busy" num_pins="1"/>
        <output name="core_cal_done" num_pins="1"/>
        <!--<output name="readdata" num_pins="8"/> --> <!-- Avalon-MM Interface - data read from the given address during dynamic partial reconfiguration -->
        <!--<output name="csr_out" num_pins="1"/> --> <!--Avalon-MM control-and-status register (CSR) agent interface !-->
        <output name="extclk_output" num_pins="2"/> <!-- external clock output port -->
        <output name="extclk_dft" num_pins="2"/>
        <output name="fblvds_out" num_pins="1"/>
        <output name="lf_reset" num_pins="1"/> <!-- loop filter reset -->
        <output name="loaden" num_pins="2"/> <!-- signal to the LVDS receiver -->
        <output name="lock" num_pins="1"/> <!-- indicate wether the PLL is locked - signal to the core logic -->
        <output name="lock2io12lane0" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 0 -->
        <output name="lock2io12lane1" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 1 -->
        <output name="lock2io12lane2" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 2 -->
        <output name="lock2io12lane3" num_pins="1"/> <!-- indicate wether the PLL is locked - going to the IO Lane 3 -->
        <output name="lock2iohmc" num_pins="1"/> <!-- indicate wether the PLL is locked - going to Hybrid Memory Cube (HMC)-->
        <!--<output name="lvds_clk" num_pins="2"/> --> <!-- the output clk feeding the LVDS SERDES block -->
        <output name="phase_done" num_pins="1"/> <!-- indicates completion of dynamic phase shift operation -->
        <output name="pll_cascade_out" num_pins="1"/> <!-- the output from the source PLL feeding the downstream PLL in cascade mode -->
        <output name="pll_pd" num_pins="1"/> <!-- indicating power down - going to the exteral PLLs  -->
        <output name="outclk" num_pins="9"/> <!-- PLL output clocks -->
        <output name="dll_output" num_pins="1"/> <!-- going to the External Memory Interface DLL -->
        <output name="fbclk_out" num_pins="1"/> <!-- output of the M counter -->
        <output name="uc_cal_readdata" num_pins="8"/>
        <output name="vcop_en" num_pins="1"/>
        <output name="vcoph" num_pins="8"/> <!-- VCO output clocks -->
        <output name="iopll_out_sig1" num_pins="1"/>
        <output name="iopll_out_sig2" num_pins="1"/>
      </pb_type>

      <complete input="PLL.core_in" name="core_to_pll" output="iopll.clkena iopll.cnt_sel iopll.core_refclk iopll.dps_rst_n iopll.extswitch iopll.fbclk_in iopll.fblvds_in
          iopll.mdio_dis iopll.rst_n iopll.num_phase_shifts iopll.pfden iopll.pll_cascade_in iopll.scan_mode_n iopll.scan_shift_n iopll.up_dn iopll.user_mode iopll.zdb_in"/>

      <complete input="PLL.clk" name="pll_clock" output="iopll.refclk"/>

      <complete input="iopll.block_select iopll.clk0_bad iopll.clk1_bad iopll.clksel iopll.cal_ok iopll.core_avl_busy iopll.core_cal_done iopll.extclk_output
          iopll.extclk_dft iopll.fblvds_out iopll.lf_reset iopll.loaden iopll.lock iopll.lock2io12lane0 iopll.lock2io12lane1 iopll.lock2io12lane2 iopll.lock2io12lane2 iopll.lock2io12lane3
          iopll.lock2iohmc iopll.phase_done iopll.pll_cascade_out iopll.pll_pd iopll.outclk iopll.dll_output iopll.fbclk_out iopll.uc_cal_readdata iopll.vcop_en iopll.vcoph iopll.iopll_out_sig1 iopll.iopll_out_sig2" name="pll_to_core" output="PLL.core_out"/>
    </pb_type>

    <pb_type name="LAB">
      <input name="data_in" num_pins="80" equivalent="full"/>
      <input name="control_in" num_pins="5" equivalent="none"/>
      <input name="cin" num_pins="1" equivalent="none"/>
      <output name="data_out" num_pins="40" equivalent="full"/>
      <output name="cout" num_pins="1" equivalent="none"/>
      <clock name="clk" num_pins="1"/>
      <mode name="LAB">
        <pb_type name="alm" num_pb="10">
          <input name="data_in" num_pins="8"/>
          <input name="control" num_pins="5"/>
          <input name="cin" num_pins="1"/>
          <output name="data_out" num_pins="4"/>
          <output name="cout" num_pins="1"/>
          <clock name="clock" num_pins="1"/>
          <mode name="alm">
            <pb_type name="comb_block" num_pb="1">
              <input name="lin" num_pins="8"/>
              <input name="cin" num_pins="1"/>
              <output name="combout" num_pins="2"/>
              <output name="sumout" num_pins="2"/>
              <output name="cout" num_pins="1"/>
              <mode name="comb_block">
                <pb_type name="lut" num_pb="2">
                  <input name="lin" num_pins="8"/>
                  <input name="cin" num_pins="1"/>
                  <output name="combout" num_pins="1"/>
                  <output name="sumout" num_pins="1"/>
                  <output name="cout" num_pins="1"/>
                  <mode name="fourteennm_lcell">
                    <pb_type blif_model=".subckt fourteennm_lcell_comb" name="lcell_comb" num_pb="1">
                      <input name="dataa" num_pins="1"/>
                      <input name="datab" num_pins="1"/>
                      <input name="datac" num_pins="1"/>
                      <input name="datad" num_pins="1"/>
                      <input name="datae" num_pins="1"/>
                      <input name="dataf" num_pins="1"/>
                      <input name="datag" num_pins="1"/>
                      <input name="datah" num_pins="1"/>
                      <input name="cin" num_pins="1"/>
                      <output name="combout" num_pins="1"/>
                      <output name="sumout" num_pins="1"/>
                      <output name="cout" num_pins="1"/>
                    </pb_type>
                    <interconnect>
                      <!-- LUT inputs -->
                      <direct input="lut.lin[0]" name="in_comp1" output="lcell_comb.dataa"/>
                      <direct input="lut.lin[1]" name="in_comp2" output="lcell_comb.datab"/>
                      <direct input="lut.lin[2]" name="in_comp3" output="lcell_comb.datac"/>
                      <direct input="lut.lin[3]" name="in_comp4" output="lcell_comb.datad"/>
                      <direct input="lut.lin[4]" name="in_comp5" output="lcell_comb.datae"/>
                      <direct input="lut.lin[5]" name="in_comp6" output="lcell_comb.dataf"/>
                      <direct input="lut.lin[6]" name="in_comp7" output="lcell_comb.datag"/>
                      <direct input="lut.lin[7]" name="in_comp8" output="lcell_comb.datah"/>
                      <!-- LUT outputs -->
                      <direct input="lcell_comb.combout" name="out_comp1" output="lut.combout"/>
                      <direct input="lcell_comb.sumout" name="out_comp2" output="lut.sumout"/>
                      <!-- LUT carry chain -->
                      <direct input="lut.cin" name="lut_cin" output="lcell_comb.cin">
                        <pack_pattern name="LAB_carry_chain" in_port="lut.cin" out_port="lcell_comb.cin"/>
                      </direct>
                      <direct input="lcell_comb.cout" name="out_comp3" output="lut.cout">
                        <pack_pattern name="LAB_carry_chain" in_port="lcell_comb.cout" out_port="lut.cout"/>
                      </direct>
                    </interconnect>
                  </mode>
                  <mode name="names_lut">
                    <pb_type blif_model=".names" class="lut" name="lut6" num_pb="1">
                      <input name="in" num_pins="6" port_class="lut_in"/>
                      <output name="out" num_pins="1" port_class="lut_out"/>
                    </pb_type>


                    <interconnect>
                      <complete input="lut.lin" name="l_complete1" output="lut6.in[5:0]"/>
                      <complete input="lut6.out" name="l_complete2" output="lut.sumout lut.combout"/>
                    </interconnect>
                  </mode>
                </pb_type>

                <interconnect>
                  <!-- Inputs to the LUTs -->
                  <complete input="comb_block.lin" name="in_lut0" output="lut[0].lin"/>
                  <complete input="comb_block.lin" name="in_lut1" output="lut[1].lin"/>
                  <!-- Combinational Block Carry Chain -->
                  <direct input="comb_block.cin" name="comb_block_cin" output="lut[0].cin">
                    <pack_pattern name="LAB_carry_chain" in_port="comb_block.cin" out_port="lut[0].cin"/>
                  </direct>
                  <direct input="lut[0].cout" name="lut_to_lut_carry" output="lut[1].cin">
                    <pack_pattern name="LAB_carry_chain" in_port="lut[0].cout" out_port="lut[1].cin"/>
                  </direct>
                  <direct input="lut[1].cout" name="alm_cout" output="comb_block.cout">
                    <pack_pattern name="LAB_carry_chain" in_port="lut[1].cout" out_port="comb_block.cout"/>
                  </direct>
                  <!-- Outputs to the Combinational Block -->
                  <direct input="lut[0].combout" name="lut0_comb" output=" comb_block.combout[0]"/>
                  <direct input="lut[1].combout" name="lut1_comb" output=" comb_block.combout[1]"/>
                  <direct input="lut[0].sumout" name="lut0_sum" output=" comb_block.sumout[0]"/>
                  <direct input="lut[1].sumout" name="lut1_sum" output=" comb_block.sumout[1]"/>

                </interconnect>              
              </mode>
            </pb_type>
            <pb_type name="dff" num_pb="4">
              <input name="clrn" num_pins="1"/>
              <input name="sclr" num_pins="1"/>
              <input name="ena" num_pins="1"/>
              <input name="d" num_pins="1"/>
              <output name="q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="stratix10_ff">
                <pb_type blif_model=".subckt fourteennm_ff" name="fourteennm_ff" num_pb="1">
                  <input name="clrn" num_pins="1"/>
                  <input name="sclr" num_pins="1"/>
                  <input name="ena" num_pins="1"/>
                  <input name="d" num_pins="1"/>
                  <output name="q" num_pins="1"/>
                  <clock name="clk" num_pins="1"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.clrn" name="fourteennm_ff_clrn" output="fourteennm_ff.clrn"/>
                  <direct input="dff.sclr" name="fourteennm_ff_sclr" output="fourteennm_ff.sclr"/>
                  <direct input="dff.ena" name="fourteennm_ff_ena" output="fourteennm_ff.ena"/>
                  <direct input="dff.d" name="fourteennm_ff_d" output="fourteennm_ff.d"/>
                  <direct input="fourteennm_ff.q" name="fourteennm_ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="fourteennm_ff_clk" output="fourteennm_ff.clk"/>
                </interconnect>
              </mode>
               <mode name="latch">
                <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                </pb_type>
                <interconnect>
                  <direct input="dff.d" name="ff_d" output="ff.D"/>
                  <direct input="ff.Q" name="ff_q" output="dff.q"/>
                  <direct input="dff.clk" name="ff_clk" output="ff.clk"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <!-- Inputs to LUTs -->
              <direct input="alm.data_in[2:7]" name="in_lut_2_7" output="comb_block.lin[2:7]"/>
              <mux input="alm.data_in[0] comb_block.sumout[0] dff[0].q" name="in_lut_0" output="comb_block.lin[0]"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1] dff[2].q" name="in_lut_1" output="comb_block.lin[1]"/>

              <!-- Inputs to FFs -->
              <mux input="alm.data_in[0] comb_block.sumout[0]" name="in_dff_0" output="dff[0].d"/>
              <direct input="comb_block.combout[0]" name="in_dff_1" output="dff[1].d"/>
              <mux input="alm.data_in[1] comb_block.combout[0] comb_block.sumout[1]" name="in_dff_2" output="dff[2].d"/>
              <direct input="comb_block.combout[1]" name="in_dff_3" output="dff[3].d"/>

              <!-- ALM Outputs-->
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out0" output="alm.data_out[0]"/>
              <mux input="dff[0].q alm.data_in[0] dff[1].q comb_block.combout[0] comb_block.sumout[0]" name="alm_out1" output="alm.data_out[1]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out2" output="alm.data_out[2]"/>
              <mux input="dff[2].q alm.data_in[1] comb_block.combout[0] dff[3].q comb_block.combout[1] comb_block.sumout[1]" name="alm_out3" output="alm.data_out[3]"/>

              <!-- FF Clocks -->
              <direct input="alm.clock" name="clock_dff0" output="dff[0].clk"/>
              <direct input="alm.clock" name="clock_dff1" output="dff[1].clk"/>

              <!-- ALM Carry Chain -->
              <direct input="alm.cin" name="alm_cin" output="comb_block.cin">
                <pack_pattern name="LAB_carry_chain" in_port="alm.cin" out_port="comb_block.cin"/>
              </direct>

              <direct input="comb_block.cout" name="alm_cout" output="alm.cout">
                <pack_pattern name="LAB_carry_chain" in_port="comb_block.cout" out_port="alm.cout"/>
              </direct>

              <!-- FF Control Signals -->

              <!--
                Here is how the alm control signals correspond to the lab wide control signals listed in Stratix 10 LAB user guide:

                synclr0 -> alm.control[0]
                labclkena0 -> alm.control[1]
                labclkena1 -> alm.control[2]
                synclr1 -> alm.control[3]
                labclr1 -> alm.control[4]
              -->
              <direct input="alm.control[4]" name="control_1_dff0" output="dff[0].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff0" output="dff[0].ena"/>
              <direct input="alm.control[3]" name="control_3_dff0" output="dff[0].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff1" output="dff[1].clrn"/>
              <direct input="alm.control[2]" name="control_2_dff1" output="dff[1].ena"/>
              <direct input="alm.control[3]" name="control_3_dff1" output="dff[1].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff2" output="dff[2].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff2" output="dff[2].ena"/>
              <direct input="alm.control[0]" name="control_3_dff2" output="dff[2].sclr"/>
              <direct input="alm.control[4]" name="control_1_dff3" output="dff[3].clrn"/>
              <direct input="alm.control[1]" name="control_2_dff3" output="dff[3].ena"/>
              <direct input="alm.control[0]" name="control_3_dff3" output="dff[3].sclr"/>
            </interconnect>
          </mode>
        </pb_type>
        <interconnect>
          <!--LAB-ALM Interconnect-->
          <!-- LAB Input: Global Routing to ALM inputs -->
          <complete input="LAB.data_in" name="LAB_datain" output="alm[9:0].data_in"/>

          <!-- ALM feedback: The ALM outputs feedback to the ALM inputs  -->
          <complete input="alm[9:0].data_out[0] alm[9:0].data_out[3]" name="LAB_alm_feedback" output="alm[9:0].data_in"/>

          <!-- ALM Outputs: directly drive global routing -->
          <complete input="alm[9:0].data_out[1] alm[9:0].data_out[2]" name="LAB_dataout" output="LAB.data_out"/>

          <!-- ALM Control Inputs -->
           <complete input="LAB.control_in" name="LAB_control" output="alm[9:0].control"/>

          <!-- LAB Clocks -->
          <direct input="LAB.clk" name="LAB_clock" output="alm[0].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[1].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[2].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[3].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[4].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[5].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[6].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[7].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[8].clock"/>
          <direct input="LAB.clk" name="LAB_clock" output="alm[9].clock"/>

          <!--LAB carry chain-->
          <direct input="LAB.cin" name="LAB_cin" output="alm[0].cin">
            <pack_pattern name="LAB_carry_chain" in_port="LAB.cin" out_port="alm[0].cin"/>
          </direct>
          <direct input="alm[0].cout" name="alm0_alm1_carry" output="alm[1].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[0].cout" out_port="alm[1].cin"/>
          </direct>
          <direct input="alm[1].cout" name="alm1_alm2_carry" output="alm[2].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[1].cout" out_port="alm[2].cin"/>
          </direct>
          <direct input="alm[2].cout" name="alm2_alm3_carry" output="alm[3].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[2].cout" out_port="alm[3].cin"/>
          </direct>
          <direct input="alm[3].cout" name="alm3_alm4_carry" output="alm[4].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[3].cout" out_port="alm[4].cin"/>
          </direct>
          <direct input="alm[4].cout" name="alm4_alm5_carry" output="alm[5].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[4].cout" out_port="alm[5].cin"/>
          </direct>
          <direct input="alm[5].cout" name="alm5_alm6_carry" output="alm[6].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[5].cout" out_port="alm[6].cin"/>
          </direct>
          <direct input="alm[6].cout" name="alm6_alm7_carry" output="alm[7].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[6].cout" out_port="alm[7].cin"/>
          </direct>
          <direct input="alm[7].cout" name="alm7_alm8_carry" output="alm[8].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[7].cout" out_port="alm[8].cin"/>
          </direct>
          <direct input="alm[8].cout" name="alm8_alm9_carry" output="alm[9].cin">
            <pack_pattern name="LAB_carry_chain" in_port="alm[8].cout" out_port="alm[9].cin"/>
          </direct>
          <direct input="alm[9].cout" name="LAB_cout" output="LAB.cout">
            <pack_pattern name="LAB_carry_chain" in_port="alm[9].cout" out_port="LAB.cout"/>
          </direct>

        </interconnect>
      </mode>
      <mode name="MLAB">

        <pb_type name="MLAB" num_pb="1">
          <clock name="clk0" num_pins="1"/>
          <input name="ena0" num_pins="1"/>
          <input name="clr" num_pins="1"/>
          <input name="portaaddr" num_pins="5"/>
          <input name="portabyteenamasks" num_pins="20"/>
          <input name="portadatain" num_pins="20"/>
          <input name="portbaddr" num_pins="5"/>
          <output name="portbdataout" num_pins="20"/>
          <mode name="mlab_cell">
          <pb_type blif_model=".subckt fourteennm_mlab_cell" name="mlab_cell" num_pb="10">
            <input name="ena0" num_pins="1"/>
            <clock name="clk0" num_pins="1"/>
            <input name="clr" num_pins="1"/>
            <input name="portaaddr" num_pins="5"/>
            <input name="portabyteenamasks" num_pins="2"/>
            <input name="portadatain" num_pins="2"/>
            <input name="portbaddr" num_pins="5"/>
            <output name="portbdataout" num_pins="2"/>
                  <T_setup value="66e-12" port="mlab_cell.ena0" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_setup value="66e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.clr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portaaddr" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portabyteenamasks" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portadatain" clock="clk0"/>
                  <T_hold value="37e-12" port="mlab_cell.portbaddr" clock="clk0"/>
                  <T_clock_to_Q max="42e-12" min="37e-12" port="mlab_cell.portbdataout" clock="clk0"/>

          </pb_type>
          <interconnect>
              <!-- Enable Input: From MLAB block to MLAB cells enable input -->
              <direct input="MLAB.ena0" name="ena0" output="mlab_cell[0].ena0"/>
              <direct input="MLAB.ena0" name="ena1" output="mlab_cell[1].ena0"/>
              <direct input="MLAB.ena0" name="ena2" output="mlab_cell[2].ena0"/>
              <direct input="MLAB.ena0" name="ena3" output="mlab_cell[3].ena0"/>
              <direct input="MLAB.ena0" name="ena4" output="mlab_cell[4].ena0"/>
              <direct input="MLAB.ena0" name="ena5" output="mlab_cell[5].ena0"/>
              <direct input="MLAB.ena0" name="ena6" output="mlab_cell[6].ena0"/>
              <direct input="MLAB.ena0" name="ena7" output="mlab_cell[7].ena0"/>
              <direct input="MLAB.ena0" name="ena8" output="mlab_cell[8].ena0"/>
              <direct input="MLAB.ena0" name="ena9" output="mlab_cell[9].ena0"/>

              <!-- Clear Input: From MLAB block to MLAB cells clear input -->
              <direct input="MLAB.clr" name="clr0" output="mlab_cell[0].clr"/>
              <direct input="MLAB.clr" name="clr1" output="mlab_cell[1].clr"/>
              <direct input="MLAB.clr" name="clr2" output="mlab_cell[2].clr"/>
              <direct input="MLAB.clr" name="clr3" output="mlab_cell[3].clr"/>
              <direct input="MLAB.clr" name="clr4" output="mlab_cell[4].clr"/>
              <direct input="MLAB.clr" name="clr5" output="mlab_cell[5].clr"/>
              <direct input="MLAB.clr" name="clr6" output="mlab_cell[6].clr"/>
              <direct input="MLAB.clr" name="clr7" output="mlab_cell[7].clr"/>
              <direct input="MLAB.clr" name="clr8" output="mlab_cell[8].clr"/>
              <direct input="MLAB.clr" name="clr9" output="mlab_cell[9].clr"/>

              <!-- Write Address: Input write address to the MLAB cells -->
              <direct input="MLAB.portaaddr" name="portaaddr0" output="mlab_cell[0].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr1" output="mlab_cell[1].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr2" output="mlab_cell[2].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr3" output="mlab_cell[3].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr4" output="mlab_cell[4].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr5" output="mlab_cell[5].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr6" output="mlab_cell[6].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr7" output="mlab_cell[7].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr8" output="mlab_cell[8].portaaddr"/>
              <direct input="MLAB.portaaddr" name="portaaddr9" output="mlab_cell[9].portaaddr"/>

              <!-- Byte Enable Mask: Input byte enable mask to the MLAB cells -->
              <direct input="MLAB.portabyteenamasks[1:0]" name="portabytenamasks0" output="mlab_cell[0].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[3:2]" name="portabytenamasks1" output="mlab_cell[1].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[5:4]" name="portabytenamasks2" output="mlab_cell[2].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[7:6]" name="portabytenamasks3" output="mlab_cell[3].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[9:8]" name="portabytenamasks4" output="mlab_cell[4].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[11:10]" name="portabytenamasks5" output="mlab_cell[5].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[13:12]" name="portabytenamasks6" output="mlab_cell[6].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[15:14]" name="portabytenamasks7" output="mlab_cell[7].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[17:16]" name="portabytenamasks8" output="mlab_cell[8].portabyteenamasks"/>
              <direct input="MLAB.portabyteenamasks[19:18]" name="portabytenamasks9" output="mlab_cell[9].portabyteenamasks"/>

              <!-- Write Data: Input data to the MLAB cells -->
              <direct input="MLAB.portadatain[1:0]" name="portadatain0" output="mlab_cell[0].portadatain"/>
              <direct input="MLAB.portadatain[3:2]" name="portadatain1" output="mlab_cell[1].portadatain"/>
              <direct input="MLAB.portadatain[5:4]" name="portadatain2" output="mlab_cell[2].portadatain"/>
              <direct input="MLAB.portadatain[7:6]" name="portadatain3" output="mlab_cell[3].portadatain"/>
              <direct input="MLAB.portadatain[9:8]" name="portadatain4" output="mlab_cell[4].portadatain"/>
              <direct input="MLAB.portadatain[11:10]" name="portadatain5" output="mlab_cell[5].portadatain"/>
              <direct input="MLAB.portadatain[13:12]" name="portadatain6" output="mlab_cell[6].portadatain"/>
              <direct input="MLAB.portadatain[15:14]" name="portadatain7" output="mlab_cell[7].portadatain"/>
              <direct input="MLAB.portadatain[17:16]" name="portadatain8" output="mlab_cell[8].portadatain"/>
              <direct input="MLAB.portadatain[19:18]" name="portadatain9" output="mlab_cell[9].portadatain"/>

              <!-- Read Address: Input read address to the MLAB cells -->
              <direct input="MLAB.portbaddr" name="portbaddr0" output="mlab_cell[0].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr1" output="mlab_cell[1].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr2" output="mlab_cell[2].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr3" output="mlab_cell[3].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr4" output="mlab_cell[4].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr5" output="mlab_cell[5].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr6" output="mlab_cell[6].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr7" output="mlab_cell[7].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr8" output="mlab_cell[8].portbaddr"/>
              <direct input="MLAB.portbaddr" name="portbaddr9" output="mlab_cell[9].portbaddr"/>

              <!-- Read data: Output data from MLAB cells to the MLAB output -->
              <direct input="mlab_cell[0].portbdataout" name="portbdataout0" output="MLAB.portbdataout[1:0]"/>
              <direct input="mlab_cell[1].portbdataout" name="portbdataout1" output="MLAB.portbdataout[3:2]"/>
              <direct input="mlab_cell[2].portbdataout" name="portbdataout2" output="MLAB.portbdataout[5:4]"/>
              <direct input="mlab_cell[3].portbdataout" name="portbdataout3" output="MLAB.portbdataout[7:6]"/>
              <direct input="mlab_cell[4].portbdataout" name="portbdataout4" output="MLAB.portbdataout[9:8]"/>
              <direct input="mlab_cell[5].portbdataout" name="portbdataout5" output="MLAB.portbdataout[11:10]"/>
              <direct input="mlab_cell[6].portbdataout" name="portbdataout6" output="MLAB.portbdataout[13:12]"/>
              <direct input="mlab_cell[7].portbdataout" name="portbdataout7" output="MLAB.portbdataout[15:14]"/>
              <direct input="mlab_cell[8].portbdataout" name="portbdataout8" output="MLAB.portbdataout[17:16]"/>
              <direct input="mlab_cell[9].portbdataout" name="portbdataout9" output="MLAB.portbdataout[19:18]"/>

              <!-- MLAB cell clocks -->
              <direct input="MLAB.clk0" name="clk0" output="mlab_cell[0].clk0"/>
              <direct input="MLAB.clk0" name="clk1" output="mlab_cell[1].clk0"/>
              <direct input="MLAB.clk0" name="clk2" output="mlab_cell[2].clk0"/>
              <direct input="MLAB.clk0" name="clk3" output="mlab_cell[3].clk0"/>
              <direct input="MLAB.clk0" name="clk4" output="mlab_cell[4].clk0"/>
              <direct input="MLAB.clk0" name="clk5" output="mlab_cell[5].clk0"/>
              <direct input="MLAB.clk0" name="clk6" output="mlab_cell[6].clk0"/>
              <direct input="MLAB.clk0" name="clk7" output="mlab_cell[7].clk0"/>
              <direct input="MLAB.clk0" name="clk8" output="mlab_cell[8].clk0"/>
              <direct input="MLAB.clk0" name="clk9" output="mlab_cell[9].clk0"/>
            </interconnect>
        </mode>
        </pb_type>
        <interconnect>
          <complete input="LAB.clk" name="mlab_clk" output="MLAB.clk0"/>
          <complete input="LAB.data_in" name="mlab_in1" output="MLAB.ena0"/>
          <complete input="LAB.data_in" name="mlab_in2" output="MLAB.clr"/>
          <complete input="LAB.data_in" name="mlab_in3" output="MLAB.portaaddr"/>
          <complete input="LAB.data_in" name="mlab_in4" output="MLAB.portabyteenamasks"/>
          <complete input="LAB.data_in" name="mlab_in5" output="MLAB.portadatain"/>
          <complete input="LAB.data_in" name="mlab_in6" output="MLAB.portbaddr"/>
          <complete input="MLAB.portbdataout" name="mlab_out" output="LAB.data_out"/>
        </interconnect>
      </mode>
    </pb_type>

    <pb_type name="OCT" num_pb="1">
      <input name="core_in" num_pins="10"/>
      <output name="core_out" num_pins="36"/>
      <clock name="clk" num_pins="1"/>

       <!-- the input pad is used is connected to rzqin pin -->
      <pb_type blif_model=".input" name="inpad" num_pb="1">
        <output name="inpad" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination" name="oct_block" num_pb="1">
        <input name="rzqin" num_pins="1"/> <!-- connects to an external reference resistor -->
        <input name="enserusr" num_pins="1"/> <!-- specifies the oct block to read from  -->
        <input name="nclrusr" num_pins="1"/> <!-- clear signal -->
        <input name="clkenusr" num_pins="1"/>
        <clock name="clkusr" num_pins="1"/>
        <input name="ser_data_dq_from_core" num_pins="1"/>
        <input name="ser_data_ca_from_core" num_pins="1"/>
        <input name="test_clkusr_en_n" num_pins="1"/>
        <input name="oct_scanin" num_pins="1"/>
        <output name="clkusr_dft_out" num_pins="1"/>
        <output name="oct_scanout" num_pins="1"/>
        <output name="compout_rdn" num_pins="1"/>
        <output name="compout_rup" num_pins="1"/>
        <output name="serdataout" num_pins="1"/>
        <output name="ser_data_dq_to_core" num_pins="1"/>
        <output name="ser_data_ca_to_core" num_pins="1"/>
      </pb_type>

      <pb_type blif_model=".subckt fourteennm_termination_logic" name="oct_logic" num_pb="1">
        <input name="s2pload" num_pins="1"/>
        <input name="serdata" num_pins="1"/>
        <input name="scan_in" num_pins="1"/>
        <input name="scan_shift_in" num_pins="1"/>
        <output name="scan_out" num_pins="1"/>
        <output name="seriesterminationcontrol" num_pins="16"/>
        <output name="parallelterminationcontrol" num_pins="16"/>
      </pb_type>

      <interconnect>
        <direct input="OCT.clk" name="clk_to_oct_block" output="oct_block.clkusr"/>

        <!-- the rzqin pin is connected to an external resistor -->
        <direct input="inpad.inpad" name="rzqin_in" output="oct_block.rzqin"/>

        <!-- oct_block inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_block" output="oct_block.enserusr oct_block.nclrusr oct_block.clkenusr oct_block.ser_data_dq_from_core oct_block.ser_data_ca_from_core oct_block.test_clkusr_en_n oct_block.oct_scanin"/>

        <!-- oct_logic inputs coming from the core logic -->
        <complete input="OCT.core_in" name="core_to_oct_logic" output="oct_block.s2pload oct_block.scan_in oct_block.scan_shift_in"/>
        <!-- oct_logic serdata coming from serdataout of the oct block -->
        <direct input="oct_block.serdataout" name="serdata_path" output="oct_logic.serdata"/>

        <!-- oct_block outputs going to the core logic -->
        <complete input="oct_block.clkusr_dft_out oct_block.oct_scanout oct_block.compout_rdn oct_block.compout_rup oct_block.ser_data_dq_to_core oct_block.ser_data_ca_to_core" name="oct_block_to_core" output="OCT.core_out"/>

        <!-- oct_logic outputs going to the core logic -->
        <complete input="oct_logic.scan_out oct_logic.seriesterminationcontrol oct_logic.parallelterminationcontrol" name="oct_logic_to_core" output="OCT.core_out"/>
        
      </interconnect>
    </pb_type>

    <pb_type name="iolane" num_pb="1">
      <input name="core_in" num_pins="55"/>
      <output name="core_out" num_pins="24"/>

      <pb_type name="io_cell" num_pb="4">
        <input name="data_in" num_pins="36"/>
        <output name="data_out" num_pins="6"/>
        <clock name="clk" num_pins="1"/>

        <mode name="io_cell" num_pb="1">

          <pb_type name="pad" num_pb="1">
            <output name="recieve_off_chip" num_pins="1"/>
            <input name="drive_off_chip" num_pins="1"/>

            <pb_type blif_model=".input" name="inpad" num_pb="1">
              <output name="inpad" num_pins="1"/>
            </pb_type>

            <pb_type blif_model=".output" name="outpad" num_pb="1">
              <input name="outpad" num_pins="1"/>
            </pb_type>

            <interconnect>
            <direct input="inpad.inpad" name="inpad" output="pad.recieve_off_chip"/>
            <direct input="pad.drive_off_chip" name="outpad" output="outpad.outpad"/>
            </interconnect>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ff" name="oe_ff" num_pb="1">
            <input name="clrn" num_pins="1"/> <!-- driver signal for clrn, sclr, ena, and d comes from the core logic -->
            <input name="sclr" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="d" num_pins="1"/>
            <output name="q" num_pins="1"/> <!-- driving the output enable port of the output buffer -->
            <clock name="clk" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_obuf" name="obuf" num_pb="1">
            <input name="i" num_pins="1"/> <!-- can be driven by the core logic through obuf_i port of the parent pb_type or by the dataout port of the ddio_out -->
            <input name="oe" num_pins="1"/> <!-- output enable port driven by the q output of the OE flip flop or the core logic -->
            <input name="dynamicterminationcontrol" num_pins="1"/> <!-- the following three ports driven by the corresponding ports in the parent pb_type -->
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <!-- <input name="devoe" num_pins="1"/>
            <input name="emif_phy_in" num_pins="2"/> -->
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_io_ibuf" name="ibuf" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="dynamicterminationcontrol" num_pins="1"/>
            <input name="seriesterminationcontrol" num_pins="16"/>
            <input name="parallelterminationcontrol" num_pins="16"/>
            <output name="o" num_pins="1"/>
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_out" name="ddio_out" num_pb="1">
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <input name="clkhi" num_pins="1"/>
            <input name="clklo" num_pins="1"/>
            <input name="muxsel" num_pins="1"/>
            <input name="datainlo" num_pins="1"/>
            <input name="datainhi" num_pins="1"/>
            <output name="dataout" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="dffhi" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="hrbypass" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_ddio_in" name="ddio_in" num_pb="1">
            <clock name="clk" num_pins="1"/>
            <input name="clkn" num_pins="1"/>
            <input name="areset" num_pins="1"/>
            <input name="sreset" num_pins="1"/>
            <input name="ena" num_pins="1"/>
            <input name="datain" num_pins="1"/>
            <output name="regoutlo" num_pins="1"/>
            <output name="regouthi" num_pins="1"/>
            <!-- <input name="dfflo" num_pins="1"/>
            <input name="devpor" num_pins="1"/>
            <input name="devclrn" num_pins="1"/> -->
          </pb_type>

          <pb_type blif_model=".subckt fourteennm_pseudo_diff_out" name="pseudo_diff_out" num_pb="1">
            <input name="i" num_pins="1"/>
            <input name="ibar" num_pins="1"/>
            <input name="oein" num_pins="1"/>
            <input name="oebin"  num_pins="1"/>
            <input name="dtcin" num_pins="1"/>
            <input name="dtcbarin" num_pins="1"/>
            <output name="o" num_pins="1"/>
            <output name="obar" num_pins="1"/>
            <output name="oeout" num_pins="1"/>
            <output name="oebout" num_pins="1"/>
            <output name="dtc" num_pins="1"/>
            <output name="dtcbar" num_pins="1"/>
            <!-- <input name="emif_phy_in" num_pins="2"/>
            <input name="emif_phy_inb" num_pins="2"/>
            <output name="emif_phy_out" num_pins="2"/>
            <output name="emif_phy_outb" num_pins="2"/> -->
          </pb_type>

          <interconnect>
            <!-- inputs coming from the FPGA core and going to OE flip flop -->
            <complete input="io_cell.data_in" name="core_to_ff" output="oe_ff.clrn oe_ff.sclr oe_ff.ena oe_ff.d"/>
            <direct input="io_cell.clk" name="ff_clk" num_pins="1" output="oe_ff.clk"/>

            <!-- inputs coming from the FPGA core and going to ddio out primitive -->
            <complete input="io_cell.data_in" name="core_to_ddio_out" num_pins="1" output="ddio_out.areset ddio_out.sreset ddio_out.ena ddio_out.clkhi ddio_out.clklo ddio_out.muxsel ddio_out.datainlo ddio_out.datainhi"/>
            <direct input="io_cell.clk" name="ddio_out_clk" num_pins="1" output="ddio_out.clk"/>

            <!-- inputs coming from the FPGA core and going to the output buffer -->
            <direct input="iocell.data_in" name="core_to_obuf" output="obuf.dynamicterminationcontrol obuf.seriesterminationcontrol obuf.parallelterminationcontrol"/>
            <!-- the i port of the output buffer can be driven by the output of the ddio out module or the core logic or the o output of the pseudo diff out-->
            <complete input="io_cell.data_in ddio_out.dataout pseudo_diff_out.o" name="i_obuff" num_pins="1" output="obuf.i"/>
            <!-- the oe port of the output buffer can be driven by the output of the oe flip flop or the core logic or the oeout output of the pseudo diff out-->
            <complete input="io_cell.data_in oe_ff.q pseudo_diff_out.oeout" name="oe_obuff" num_pins="1" output="obuf.oe"/>

            <!-- inputs coming from the FPGA core and going to the input buffer -->
            <direct input="iocell.data_in" name="core_to_ibuff" output="ibuf.ibar ibuf.dynamicterminationcontrol ibuf.seriesterminationcontrol ibuf.parallelterminationcontrol"/>
            <!-- the output of the padin will directly drive the input buffer  -->
            <direct input="pad.recieve_off_chip" name="pad_receive" num_pins="1" output="ibuf.i"/>

            <!-- inputs coming from the FPGA core and going to pseudo diff out primitive -->
            <direct input="io_cell.data_in" name="core_to_pseudo_diff_out" num_pins="1" output="pseudo_diff_out.ibar pseudo_diff_out.oebin pseudo_diff_out.dtcin pseudo_diff_out.dtcbarin"/>
            <!-- the i port of the  pseudo diff out can be driven by the output of the ddio out module or the core logic -->
            <complete input="io_cell.data_in ddio_out.dataout" name="i_pseudo_diff" num_pins="1" output=" pseudo_diff_out.i"/>
            <!-- the oein port of the pseudo diff out can be driven by the output of the oe flip flop or the core logic -->
            <complete input="io_cell.data_in oe_ff.q" name="oe_pseudo_diff" num_pins="1" output="diff_out.oein"/>

            <!-- inputs coming from the FPGA core and going to ddio in primitive -->
            <direct input="io_cell.data_in" name="core_to_ddio_in" num_pins="1" output="ddio_in.clkn ddio_in.areset ddio_in.sreset ddio_in.ena"/>
            <direct input="io_cell.clk" name="ddioi_clk" num_pins="1" output="ddio_in.clk"/>

            <!-- the data port of theddio in is driven by the output of the input buffer -->
            <direct input="ibuf.o" name="ddioi_datain" num_pins="1" output="ddio_in.datain"/>

            <!-- the pad out can be driven by the output ports of the output buffer  -->
            <complete input="obuf.o obuf.obar" name="pad_drive" num_pins="1" output="pad.drive_off_chip"/>

            <!-- the outputs of the iocell block going to the core -->
            <direct input="pseudo_diff_out.obar" name="iocell_obar" num_pins="1" output="iocell.data_out[0]"/>
            <direct input="pseudo_diff_out.oebout" name="iocell_oeout" num_pins="1" output="iocell.data_out[1]"/>
            <direct input="pseudo_diff_out.dtc" name="iocell_dtc" num_pins="1" output="iocell.data_out[2]"/>
            <direct input="pseudo_diff_out.dtcbar" name="iocell_dtcbar" num_pins="1" output="iocell.data_out[3]"/>
            <complete input="ibuf.o ddio_in.regoutlo" name="iocell_regoutlo" num_pins="1" output="iocell.data_out[4]"/>
            <direct input="ddio_in.regouthi" name="iocell_regouthi" num_pins="1" output="iocell.data_out[5]"/>

          </interconnect>
        </mode>
      </pb_type>

      <interconnect>
        <complete input="iolane.core_in" name="core_to_io" output="io_cell.data_in"/>
        <complete input="iocell.data_out" name="io_to_core" output="io_lane.core_out"/>
      </interconnect>
    </pb_type>

    <pb_type name="DSP">
      <input name="datain" num_pins="110"/>
      <input name="chainin" num_pins="64"/>
      <input name="controlin" num_pins="17"/>
      <input name="scanin" num_pins="27"/>
      <clock name="clk" num_pins="3"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <output name="dftout" num_pins="1"/>
      <!-- 
           We model several different operation modes of the fourteennm_mac primitive:
                independent multiplier 
                multiplier adder sum 
                18x19 multiplication summed with 36-bit input 
                systolic fir 
                27x27 independent multiplier 
                single 18x18 multiplier

            As well as several operation modes of the fourteennm_fp_mac primitive:
                multiplication
                multiply accumulate
                multiply add
                adder or subtract
                vector one mode
                vector two mode

           We also model 4 variations of each operation mode to capture timing differences based on whether the inputs and/or outputs are 
           registered or combinational.

           This is itself an approximation of the actual Stratix 10 architecture, which can support multiple levels of internal registers
           inside each DSP block.  To model this would be extremely verbose and time consuming. The approximation mentioned above is a 
           reasonable compromise, since it captures the key timing characteristics of the fourteennm_mac or fourteennm_fp_mac from an external perspective (which is
           what most pack/place/route CAD tools would care about).  
        -->

        <!-- independent multiplier mode -->
        <mode name="m18×18_full.input_type{reg}.output_type{comb}">
            <pb_type name="mac18×18_full" blif_model=".subckt fourteennm_mac.opmode{m18×18_full}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="18"/>
                <input name="ay" num_pins="19"/>
                <input name="az" num_pins="18"/>
                <input name="coefsela" num_pins="3"/>
                <input name="bx" num_pins="18"/>
                <input name="by" num_pins="19"/>
                <input name="bz" num_pins="18"/>
                <input name="coefselb" num_pins="3"/>
                <input name="scanin" num_pins="19"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="37"/>
                <output name="resultb" num_pins="37"/>
                <output name="scanout" num_pins="19"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac18×18_full.chainin"/>
                <direct name="chain_out" input="mac18×18_full.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_full.scanin"/>
                <direct name="scan_out" input="mac18×18_full.scanout" output="DSP.scanout[18:0]"/>
                <direct name="dft_out" input="mac18×18_full.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_full.ax"/>
                <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_full.ay"/>
                <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_full.az"/>
                <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_full.bx"/>
                <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_full.by"/>
                <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_full.bz"/>

                <direct name="resulta_out" input="mac18×18_full.resulta" output="DSP.result[36:0]"/>
                <direct name="resultb_out" input="mac18×18_full.resultb" output="DSP.result[73:37]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_full.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_full.coefsela"/>
                <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_full.coefselb"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_full.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_full.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_full.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="mac18×18_full.clk"/>

            </interconnect>
        </mode>

        <mode name="m18×18_full.input_type{comb}.output_type{reg}">
            <pb_type name="mac18×18_full" blif_model=".subckt fourteennm_mac.opmode{m18×18_full}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="18"/>
                <input name="ay" num_pins="19"/>
                <input name="az" num_pins="18"/>
                <input name="coefsela" num_pins="3"/>
                <input name="bx" num_pins="18"/>
                <input name="by" num_pins="19"/>
                <input name="bz" num_pins="18"/>
                <input name="coefselb" num_pins="3"/>
                <input name="scanin" num_pins="19"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="37"/>
                <output name="resultb" num_pins="37"/>
                <output name="scanout" num_pins="19"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac18×18_full.chainin"/>
                <direct name="chain_out" input="mac18×18_full.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_full.scanin"/>
                <direct name="scan_out" input="mac18×18_full.scanout" output="DSP.scanout[18:0]"/>
                <direct name="dft_out" input="mac18×18_full.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_full.ax"/>
                <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_full.ay"/>
                <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_full.az"/>
                <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_full.bx"/>
                <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_full.by"/>
                <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_full.bz"/>

                <direct name="resulta_out" input="mac18×18_full.resulta" output="DSP.result[36:0]"/>
                <direct name="resultb_out" input="mac18×18_full.resultb" output="DSP.result[73:37]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_full.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_full.coefsela"/>
                <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_full.coefselb"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_full.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_full.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_full.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="mac18×18_full.clk"/>

            </interconnect>
        </mode>

        <mode name="m18×18_full.input_type{comb}.output_type{comb}">
            <pb_type name="mac18×18_full" blif_model=".subckt fourteennm_mac.opmode{m18×18_full}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="18"/>
                <input name="ay" num_pins="19"/>
                <input name="az" num_pins="18"/>
                <input name="coefsela" num_pins="3"/>
                <input name="bx" num_pins="18"/>
                <input name="by" num_pins="19"/>
                <input name="bz" num_pins="18"/>
                <input name="coefselb" num_pins="3"/>
                <input name="scanin" num_pins="19"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="37"/>
                <output name="resultb" num_pins="37"/>
                <output name="scanout" num_pins="19"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac18×18_full.chainin"/>
                <direct name="chain_out" input="mac18×18_full.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_full.scanin"/>
                <direct name="scan_out" input="mac18×18_full.scanout" output="DSP.scanout[18:0]"/>
                <direct name="dft_out" input="mac18×18_full.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_full.ax"/>
                <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_full.ay"/>
                <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_full.az"/>
                <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_full.bx"/>
                <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_full.by"/>
                <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_full.bz"/>

                <direct name="resulta_out" input="mac18×18_full.resulta" output="DSP.result[36:0]"/>
                <direct name="resultb_out" input="mac18×18_full.resultb" output="DSP.result[73:37]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_full.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_full.coefsela"/>
                <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_full.coefselb"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_full.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_full.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_full.dfxmisrena"/>

            </interconnect>
        </mode>

        <mode name="m18×18_full.input_type{reg}.output_type{reg}">
            <pb_type name="mac18×18_full" blif_model=".subckt fourteennm_mac.opmode{m18×18_full}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="18"/>
                <input name="ay" num_pins="19"/>
                <input name="az" num_pins="18"/>
                <input name="coefsela" num_pins="3"/>
                <input name="bx" num_pins="18"/>
                <input name="by" num_pins="19"/>
                <input name="bz" num_pins="18"/>
                <input name="coefselb" num_pins="3"/>
                <input name="scanin" num_pins="19"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="37"/>
                <output name="resultb" num_pins="37"/>
                <output name="scanout" num_pins="19"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac18×18_full.chainin"/>
                <direct name="chain_out" input="mac18×18_full.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_full.scanin"/>
                <direct name="scan_out" input="mac18×18_full.scanout" output="DSP.scanout[18:0]"/>
                <direct name="dft_out" input="mac18×18_full.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_full.ax"/>
                <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_full.ay"/>
                <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_full.az"/>
                <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_full.bx"/>
                <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_full.by"/>
                <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_full.bz"/>

                <direct name="resulta_out" input="mac18×18_full.resulta" output="DSP.result[36:0]"/>
                <direct name="resultb_out" input="mac18×18_full.resultb" output="DSP.result[73:37]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_full.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_full.coefsela"/>
                <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_full.coefselb"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_full.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_full.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_full.dfxmisrena"/>

                <complete name="clk_in" input="DSP.clk" output="mac18×18_full.clk"/>

            </interconnect>
        </mode>

        <!-- multiplier adder sum mode -->
        <mode name="m18×18_sumof2.input_type{reg}.output_type{comb}">
          <pb_type name="mac18×18_sumof2" blif_model=".subckt fourteennm_mac.opmode{m18×18_sumof2}.input_type{reg}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_sumof2.chainin"/>
              <direct name="chain_out" input="mac18×18_sumof2.chainout" output="DSP.chainout"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_sumof2.scanin"/>
              <direct name="scan_out" input="mac18×18_sumof2.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18×18_sumof2.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_sumof2.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_sumof2.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_sumof2.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_sumof2.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_sumof2.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_sumof2.bz"/>

              <direct name="resulta_out" input="mac18×18_sumof2.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_sumof2.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_sumof2.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_sumof2.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_sumof2.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_sumof2.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_sumof2.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_sumof2.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_sumof2.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_sumof2.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_sumof2.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18×18_sumof2.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_sumof2.input_type{comb}.output_type{reg}">
          <pb_type name="mac18×18_sumof2" blif_model=".subckt fourteennm_mac.opmode{m18×18_sumof2}.input_type{cpmb}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_sumof2.chainin"/>
              <direct name="chain_out" input="mac18×18_sumof2.chainout" output="DSP.chainout"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_sumof2.scanin"/>
              <direct name="scan_out" input="mac18×18_sumof2.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18×18_sumof2.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_sumof2.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_sumof2.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_sumof2.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_sumof2.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_sumof2.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_sumof2.bz"/>

              <direct name="resulta_out" input="mac18×18_sumof2.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_sumof2.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_sumof2.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_sumof2.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_sumof2.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_sumof2.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_sumof2.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_sumof2.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_sumof2.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_sumof2.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_sumof2.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18×18_sumof2.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_sumof2.input_type{comb}.output_type{comb}">
          <pb_type name="mac18×18_sumof2" blif_model=".subckt fourteennm_mac.opmode{m18×18_sumof2}.input_type{comb}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_sumof2.chainin"/>
              <direct name="chain_out" input="mac18×18_sumof2.chainout" output="DSP.chainout"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18×18_sumof2.scanin"/>
              <direct name="scan_out" input="mac18×18_sumof2.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18×18_sumof2.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_sumof2.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_sumof2.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18×18_sumof2.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_sumof2.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_sumof2.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18×18_sumof2.bz"/>

              <direct name="resulta_out" input="mac18×18_sumof2.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_sumof2.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18×18_sumof2.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18×18_sumof2.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_sumof2.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_sumof2.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_sumof2.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_sumof2.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_sumof2.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_sumof2.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_sumof2.sub"/>

          </interconnect>
        </mode>

        <mode name="m18×18_sumof2.input_type{reg}.output_type{reg}">
        </mode>   

        <!-- 18x19 multiplication summed with 36-bit input -->
        <mode name="m18×18_plus36.input_type{reg}.output_type{comb}">
          <pb_type name="mac18×18_plus36" blif_model=".subckt fourteennm_mac.opmode{m18×18_plus36}.input_type{reg}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_plus36.chainin"/>
              <direct name="chain_out" input="mac18×18_plus36.chainout" output="DSP.chainout"/>
              <direct name="dft_out" input="mac18×18_plus36.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_plus36.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_plus36.ay"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_plus36.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_plus36.by"/>

              <direct name="resulta_out" input="mac18×18_plus36.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_plus36.clr"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_plus36.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_plus36.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_plus36.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_plus36.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_plus36.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_plus36.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_plus36.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18×18_plus36.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_plus36.input_type{comb}.output_type{reg}">
          <pb_type name="mac18×18_plus36" blif_model=".subckt fourteennm_mac.opmode{m18×18_plus36}.input_type{comb}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_plus36.chainin"/>
              <direct name="chain_out" input="mac18×18_plus36.chainout" output="DSP.chainout"/>
              <direct name="dft_out" input="mac18×18_plus36.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_plus36.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_plus36.ay"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_plus36.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_plus36.by"/>

              <direct name="resulta_out" input="mac18×18_plus36.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_plus36.clr"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_plus36.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_plus36.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_plus36.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_plus36.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_plus36.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_plus36.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_plus36.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18×18_plus36.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_plus36.input_type{comb}.output_type{comb}">
          <pb_type name="mac18×18_plus36" blif_model=".subckt fourteennm_mac.opmode{m18×18_plus36}.input_type{comb}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_plus36.chainin"/>
              <direct name="chain_out" input="mac18×18_plus36.chainout" output="DSP.chainout"/>
              <direct name="dft_out" input="mac18×18_plus36.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_plus36.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_plus36.ay"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_plus36.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_plus36.by"/>

              <direct name="resulta_out" input="mac18×18_plus36.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_plus36.clr"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_plus36.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_plus36.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_plus36.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_plus36.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_plus36.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_plus36.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_plus36.sub"/>

          </interconnect>
        </mode>

        <mode name="m18×18_plus36.input_type{reg}.output_type{reg}">
          <pb_type name="mac18×18_plus36" blif_model=".subckt fourteennm_mac.opmode{m18×18_plus36}.input_type{reg}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="64"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="18"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="64"/>
              <output name="resulta" num_pins="64"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin" output="mac18×18_plus36.chainin"/>
              <direct name="chain_out" input="mac18×18_plus36.chainout" output="DSP.chainout"/>
              <direct name="dft_out" input="mac18×18_plus36.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18×18_plus36.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18×18_plus36.ay"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18×18_plus36.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18×18_plus36.by"/>

              <direct name="resulta_out" input="mac18×18_plus36.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18×18_plus36.clr"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18×18_plus36.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18×18_plus36.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18×18_plus36.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18×18_plus36.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18×18_plus36.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18×18_plus36.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18×18_plus36.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18×18_plus36.clk"/>
          </interconnect>
        </mode>

        <!-- systolic fir mode -->
        <mode name="m18×18_systolic.input_type{reg}.output_type{comb}">
          <pb_type name="mac18×18_systolic" blif_model=".subckt fourteennm_mac.opmode{m18×18_systolic}.input_type{reg}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="43"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="43"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin[42:0]" output="mac18x18_systolic.chainin"/>
              <direct name="chain_out" input="mac18x18_systolic.chainout" output="DSP.chainout[42:0]"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18x18_systolic.scanin"/>
              <direct name="scan_out" input="mac18x18_systolic.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18x18_systolic.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18x18_systolic.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18x18_systolic.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18x18_systolic.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18x18_systolic.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18x18_systolic.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18x18_systolic.bz"/>

              <direct name="resulta_out" input="mac18x18_systolic.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18x18_systolic.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18x18_systolic.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18x18_systolic.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18x18_systolic.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18x18_systolic.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18x18_systolic.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18x18_systolic.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18x18_systolic.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18x18_systolic.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18x18_systolic.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18x18_systolic.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_systolic.input_type{comb}.output_type{reg}">
          <pb_type name="mac18×18_systolic" blif_model=".subckt fourteennm_mac.opmode{m18×18_systolic}.input_type{comb}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="43"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="43"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin[42:0]" output="mac18x18_systolic.chainin"/>
              <direct name="chain_out" input="mac18x18_systolic.chainout" output="DSP.chainout[42:0]"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18x18_systolic.scanin"/>
              <direct name="scan_out" input="mac18x18_systolic.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18x18_systolic.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18x18_systolic.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18x18_systolic.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18x18_systolic.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18x18_systolic.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18x18_systolic.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18x18_systolic.bz"/>

              <direct name="resulta_out" input="mac18x18_systolic.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18x18_systolic.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18x18_systolic.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18x18_systolic.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18x18_systolic.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18x18_systolic.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18x18_systolic.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18x18_systolic.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18x18_systolic.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18x18_systolic.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18x18_systolic.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18x18_systolic.clk"/>
          </interconnect>
        </mode>

        <mode name="m18×18_systolic.input_type{comb}.output_type{comb}">
          <pb_type name="mac18×18_systolic" blif_model=".subckt fourteennm_mac.opmode{m18×18_systolic}.input_type{comb}.output_type{comb}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="43"/>
              <input name="clr" num_pins="2"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="43"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin[42:0]" output="mac18x18_systolic.chainin"/>
              <direct name="chain_out" input="mac18x18_systolic.chainout" output="DSP.chainout[42:0]"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18x18_systolic.scanin"/>
              <direct name="scan_out" input="mac18x18_systolic.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18x18_systolic.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18x18_systolic.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18x18_systolic.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18x18_systolic.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18x18_systolic.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18x18_systolic.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18x18_systolic.bz"/>

              <direct name="resulta_out" input="mac18x18_systolic.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18x18_systolic.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18x18_systolic.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18x18_systolic.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18x18_systolic.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18x18_systolic.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18x18_systolic.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18x18_systolic.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18x18_systolic.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18x18_systolic.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18x18_systolic.sub"/>

          </interconnect>
        </mode>

        <mode name="m18×18_systolic.input_type{reg}.output_type{reg}">
          <pb_type name="mac18×18_systolic" blif_model=".subckt fourteennm_mac.opmode{m18×18_systolic}.input_type{reg}.output_type{reg}" num_pb="1">
              <input name="accumulate" num_pins="1"/>
              <input name="chainin" num_pins="43"/>
              <input name="clr" num_pins="2"/>
              <clock name="clk" num_pins="3"/>
              <input name="ax" num_pins="18"/>
              <input name="ay" num_pins="19"/>
              <input name="az" num_pins="18"/>
              <input name="coefsela" num_pins="3"/>
              <input name="bx" num_pins="18"/>
              <input name="by" num_pins="19"/>
              <input name="bz" num_pins="18"/>
              <input name="coefselb" num_pins="3"/>
              <input name="loadconst" num_pins="1"/>
              <input name="negate" num_pins="1"/>
              <input name="scanin" num_pins="19"/>
              <input name="sub" num_pins="1"/>
              <input name="ena" num_pins="3"/>
              <input name="dfxlfsrena" num_pins="1"/>
              <input name="dfxmisrena" num_pins="1"/>

              <output name="chainout" num_pins="43"/>
              <output name="resulta" num_pins="64"/>
              <output name="scanout" num_pins="19"/>
              <output name="dftout" num_pins="1"/>
          </pb_type>

          <interconnect>

              <direct name="chain_in" input="DSP.chainin[42:0]" output="mac18x18_systolic.chainin"/>
              <direct name="chain_out" input="mac18x18_systolic.chainout" output="DSP.chainout[42:0]"/>
              <direct name="scan_in" input="DSP.scanin[18:0]" output="mac18x18_systolic.scanin"/>
              <direct name="scan_out" input="mac18x18_systolic.scanout" output="DSP.scanout[18:0]"/>
              <direct name="dft_out" input="mac18x18_systolic.dftout" output="DSP.dftout"/>

              <direct name="ax_in" input="DSP.datain[17:0]" output="mac18x18_systolic.ax"/>
              <direct name="ay_in" input="DSP.datain[36:18]" output="mac18x18_systolic.ay"/>
              <direct name="az_in" input="DSP.datain[54:37]" output="mac18x18_systolic.az"/>
              <direct name="bx_in" input="DSP.datain[72:55]" output="mac18x18_systolic.bx"/>
              <direct name="by_in" input="DSP.datain[91:73]" output="mac18x18_systolic.by"/>
              <direct name="bz_in" input="DSP.datain[109:92]" output="mac18x18_systolic.bz"/>

              <direct name="resulta_out" input="mac18x18_systolic.resulta" output="DSP.result[63:0]"/>

              
              <direct name="clr_in" input="DSP.controlin[1:0]" output="mac18x18_systolic.clr"/>
              <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac18x18_systolic.coefsela"/>
              <direct name="coefselb_in" input="DSP.controlin[7:5]" output="mac18x18_systolic.coefselb"/>
              <direct name="ena_in" input="DSP.controlin[10:8]" output="mac18x18_systolic.ena"/>
              <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac18x18_systolic.dfxlfsrena"/>
              <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac18x18_systolic.dfxmisrena"/>
              <direct name="accumulate_in" input="DSP.controlin[13]" output="mac18x18_systolic.accumulate"/>
              <direct name="loadconst_in" input="DSP.controlin[14]" output="mac18x18_systolic.loadconst"/>
              <direct name="negate_in" input="DSP.controlin[15]" output="mac18x18_systolic.negate"/>
              <direct name="sub_in" input="DSP.controlin[16]" output="mac18x18_systolic.sub"/>

              <complete name="clk_in" input="DSP.clk" output="mac18x18_systolic.clk"/>
          </interconnect>
        </mode>

        <!-- 27x27 independent multiplier mode -->
        <mode name="m27x27.input_type{reg}.output_type{comb}">
            <pb_type name="mac27x27" blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{comb}" num_pb="1">
                <input name="accumulate" num_pins="1"/>
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="27"/>
                <input name="ay" num_pins="27"/>
                <input name="az" num_pins="26"/>
                <input name="coefsela" num_pins="3"/>
                <input name="loadconst" num_pins="1"/>
                <input name="negate" num_pins="1"/>
                <input name="scanin" num_pins="27"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="64"/>
                <output name="scanout" num_pins="27"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac27x27.chainin"/>
                <direct name="chain_out" input="mac27x27.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin" output="mac27x27.scanin"/>
                <direct name="scan_out" input="mac27x27.scanout" output="DSP.scanout"/>
                <direct name="dft_out" input="mac27x27.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[26:0]" output="mac27x27.ax"/>
                <direct name="ay_in" input="DSP.datain[53:27]" output="mac27x27.ay"/>
                <direct name="az_in" input="DSP.datain[79:54]" output="mac27x27.az"/>

                <direct name="resulta_out" input="mac27x27.resulta" output="DSP.result[63:0]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac27x27.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac27x27.coefsela"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac27x27.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac27x27.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac27x27.dfxmisrena"/>
                <direct name="accumulate_in" input="DSP.controlin[13]" output="mac27x27.accumulate"/>
                <direct name="loadconst_in" input="DSP.controlin[14]" output="mac27x27.loadconst"/>
                <direct name="negate_in" input="DSP.controlin[15]" output="mac27x27.negate"/>

                <complete name="clk_in" input="DSP.clk" output="mac27x27.clk"/>

            </interconnect>
        </mode>

        <mode name="m27x27.input_type{comb}.output_type{reg}">
            <pb_type name="mac27x27" blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{reg}" num_pb="1">
                <input name="accumulate" num_pins="1"/>
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="27"/>
                <input name="ay" num_pins="27"/>
                <input name="az" num_pins="26"/>
                <input name="coefsela" num_pins="3"/>
                <input name="loadconst" num_pins="1"/>
                <input name="negate" num_pins="1"/>
                <input name="scanin" num_pins="27"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="64"/>
                <output name="scanout" num_pins="27"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac27x27.chainin"/>
                <direct name="chain_out" input="mac27x27.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin" output="mac27x27.scanin"/>
                <direct name="scan_out" input="mac27x27.scanout" output="DSP.scanout"/>
                <direct name="dft_out" input="mac27x27.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[26:0]" output="mac27x27.ax"/>
                <direct name="ay_in" input="DSP.datain[53:27]" output="mac27x27.ay"/>
                <direct name="az_in" input="DSP.datain[79:54]" output="mac27x27.az"/>

                <direct name="resulta_out" input="mac27x27.resulta" output="DSP.result[63:0]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac27x27.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac27x27.coefsela"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac27x27.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac27x27.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac27x27.dfxmisrena"/>
                <direct name="accumulate_in" input="DSP.controlin[13]" output="mac27x27.accumulate"/>
                <direct name="loadconst_in" input="DSP.controlin[14]" output="mac27x27.loadconst"/>
                <direct name="negate_in" input="DSP.controlin[15]" output="mac27x27.negate"/>

                <complete name="clk_in" input="DSP.clk" output="mac27x27.clk"/>

            </interconnect>
        </mode>

        <mode name="m27x27.input_type{comb}.output_type{comb}">
            <pb_type name="mac27x27" blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{comb}.output_type{comb}" num_pb="1">
                <input name="accumulate" num_pins="1"/>
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <input name="ax" num_pins="27"/>
                <input name="ay" num_pins="27"/>
                <input name="az" num_pins="26"/>
                <input name="coefsela" num_pins="3"/>
                <input name="loadconst" num_pins="1"/>
                <input name="negate" num_pins="1"/>
                <input name="scanin" num_pins="27"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="64"/>
                <output name="scanout" num_pins="27"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac27x27.chainin"/>
                <direct name="chain_out" input="mac27x27.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin" output="mac27x27.scanin"/>
                <direct name="scan_out" input="mac27x27.scanout" output="DSP.scanout"/>
                <direct name="dft_out" input="mac27x27.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[26:0]" output="mac27x27.ax"/>
                <direct name="ay_in" input="DSP.datain[53:27]" output="mac27x27.ay"/>
                <direct name="az_in" input="DSP.datain[79:54]" output="mac27x27.az"/>

                <direct name="resulta_out" input="mac27x27.resulta" output="DSP.result[63:0]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac27x27.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac27x27.coefsela"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac27x27.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac27x27.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac27x27.dfxmisrena"/>
                <direct name="accumulate_in" input="DSP.controlin[13]" output="mac27x27.accumulate"/>
                <direct name="loadconst_in" input="DSP.controlin[14]" output="mac27x27.loadconst"/>
                <direct name="negate_in" input="DSP.controlin[15]" output="mac27x27.negate"/>


            </interconnect>
        </mode>

        <mode name="m27x27.input_type{reg}.output_type{reg}">
            <pb_type name="mac27x27" blif_model=".subckt fourteennm_mac.opmode{m27x27}.input_type{reg}.output_type{reg}" num_pb="1">
                <input name="accumulate" num_pins="1"/>
                <input name="chainin" num_pins="64"/>
                <input name="clr" num_pins="2"/>
                <clock name="clk" num_pins="3"/>
                <input name="ax" num_pins="27"/>
                <input name="ay" num_pins="27"/>
                <input name="az" num_pins="26"/>
                <input name="coefsela" num_pins="3"/>
                <input name="loadconst" num_pins="1"/>
                <input name="negate" num_pins="1"/>
                <input name="scanin" num_pins="27"/>
                <input name="ena" num_pins="3"/>
                <input name="dfxlfsrena" num_pins="1"/>
                <input name="dfxmisrena" num_pins="1"/>

                <output name="chainout" num_pins="64"/>
                <output name="resulta" num_pins="64"/>
                <output name="scanout" num_pins="27"/>
                <output name="dftout" num_pins="1"/>
            </pb_type>

            <interconnect>

                <direct name="chain_in" input="DSP.chainin" output="mac27x27.chainin"/>
                <direct name="chain_out" input="mac27x27.chainout" output="DSP.chainout"/>
                <direct name="scan_in" input="DSP.scanin" output="mac27x27.scanin"/>
                <direct name="scan_out" input="mac27x27.scanout" output="DSP.scanout"/>
                <direct name="dft_out" input="mac27x27.dftout" output="DSP.dftout"/>

                <direct name="ax_in" input="DSP.datain[26:0]" output="mac27x27.ax"/>
                <direct name="ay_in" input="DSP.datain[53:27]" output="mac27x27.ay"/>
                <direct name="az_in" input="DSP.datain[79:54]" output="mac27x27.az"/>

                <direct name="resulta_out" input="mac27x27.resulta" output="DSP.result[63:0]"/>

                
                <direct name="clr_in" input="DSP.controlin[1:0]" output="mac27x27.clr"/>
                <direct name="coefsela_in" input="DSP.controlin[4:2]" output="mac27x27.coefsela"/>
                <direct name="ena_in" input="DSP.controlin[10:8]" output="mac27x27.ena"/>
                <direct name="dfxlfsrena_in" input="DSP.controlin[11]" output="mac27x27.dfxlfsrena"/>
                <direct name="dfxmisrena_in" input="DSP.controlin[12]" output="mac27x27.dfxmisrena"/>
                <direct name="accumulate_in" input="DSP.controlin[13]" output="mac27x27.accumulate"/>
                <direct name="loadconst_in" input="DSP.controlin[14]" output="mac27x27.loadconst"/>
                <direct name="negate_in" input="DSP.controlin[15]" output="mac27x27.negate"/>

                <complete name="clk_in" input="DSP.clk" output="mac27x27.clk"/>

            </interconnect>
        </mode>

        

    </pb_type>

  </complexblocklist>
